


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > LExecutor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">mindustry.logic</a>
</div>

<h1>Coverage Summary for Class: LExecutor (mindustry.logic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LExecutor</td>
<td class="coverageStat">
  <span class="percent">
    31.6%
  </span>
  <span class="absValue">
    (6/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.4%
  </span>
  <span class="absValue">
    (23/84)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LExecutor$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$ApplyEffectI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$ClientDataI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$ControlI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (8/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$CutsceneI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.9%
  </span>
  <span class="absValue">
    (7/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$DrawFlushI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$DrawI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$EffectI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.8%
  </span>
  <span class="absValue">
    (7/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$EndI</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$ExplosionI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$FetchI</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.3%
  </span>
  <span class="absValue">
    (20/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$FlushMessageI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.9%
  </span>
  <span class="absValue">
    (5/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$FormatI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$GetBlockI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (6/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$GetFlagI</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$GetLinkI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$JumpI</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.4%
  </span>
  <span class="absValue">
    (14/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$LInstruction</td>
  </tr>
  <tr>
    <td class="name">LExecutor$LocalePrintI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$LookupI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$MakeMarkerI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$NoopI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$OpI</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$PackColorI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$PlaySoundI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$PrintFlushI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$PrintI</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (2/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$RadarI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$ReadI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SenseI</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.4%
  </span>
  <span class="absValue">
    (9/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SenseWeatherI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetBlockI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetFlagI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.3%
  </span>
  <span class="absValue">
    (3/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetMarkerI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetPropI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetRateI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetRuleI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.1%
  </span>
  <span class="absValue">
    (8/53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SetWeatherI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SpawnUnitI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (7/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SpawnWaveI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19%
  </span>
  <span class="absValue">
    (4/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$StopI</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$SyncI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$UnitBindI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$UnitControlI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/135)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$UnitLocateI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$UnitLocateI$Cache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$WaitI</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LExecutor$WriteI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    19.8%
  </span>
  <span class="absValue">
    (32/162)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.5%
  </span>
  <span class="absValue">
    (162/981)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package mindustry.logic;
&nbsp;
&nbsp;import arc.*;
&nbsp;import arc.audio.*;
&nbsp;import arc.graphics.*;
&nbsp;import arc.math.*;
&nbsp;import arc.math.geom.*;
&nbsp;import arc.struct.*;
&nbsp;import arc.util.*;
&nbsp;import mindustry.*;
&nbsp;import mindustry.ai.types.*;
&nbsp;import mindustry.annotations.Annotations.*;
&nbsp;import mindustry.content.*;
&nbsp;import mindustry.core.*;
&nbsp;import mindustry.ctype.*;
&nbsp;import mindustry.entities.*;
&nbsp;import mindustry.game.EventType.*;
&nbsp;import mindustry.game.*;
&nbsp;import mindustry.game.MapObjectives.*;
&nbsp;import mindustry.game.Teams.*;
&nbsp;import mindustry.gen.*;
&nbsp;import mindustry.logic.LogicFx.*;
&nbsp;import mindustry.type.*;
&nbsp;import mindustry.ui.*;
&nbsp;import mindustry.world.*;
&nbsp;import mindustry.world.blocks.environment.*;
&nbsp;import mindustry.world.blocks.logic.*;
&nbsp;import mindustry.world.blocks.logic.LogicBlock.*;
&nbsp;import mindustry.world.blocks.logic.LogicDisplay.*;
&nbsp;import mindustry.world.blocks.logic.MemoryBlock.*;
&nbsp;import mindustry.world.blocks.logic.MessageBlock.*;
&nbsp;import mindustry.world.blocks.payloads.*;
&nbsp;import mindustry.world.meta.*;
&nbsp;
&nbsp;import static mindustry.Vars.*;
&nbsp;
<b class="fc">&nbsp;public class LExecutor{</b>
&nbsp;    public static final int maxInstructions = 1000;
&nbsp;
&nbsp;    public static final int
&nbsp;    maxGraphicsBuffer = 256,
&nbsp;    maxDisplayBuffer = 1024,
&nbsp;    maxTextBuffer = 400;
&nbsp;
<b class="fc">&nbsp;    public LInstruction[] instructions = {};</b>
&nbsp;    /** Non-constant variables used for network sync */
<b class="fc">&nbsp;    public LVar[] vars = {};</b>
&nbsp;    
&nbsp;    public LVar counter, unit, thisv, ipt;
&nbsp;    
&nbsp;    public int[] binds;
&nbsp;    public boolean yield;
&nbsp;
<b class="fc">&nbsp;    public LongSeq graphicsBuffer = new LongSeq();</b>
<b class="fc">&nbsp;    public StringBuilder textBuffer = new StringBuilder();</b>
<b class="fc">&nbsp;    public Building[] links = {};</b>
&nbsp;    public @Nullable LogicBuild build;
<b class="fc">&nbsp;    public IntSet linkIds = new IntSet();</b>
<b class="fc">&nbsp;    public Team team = Team.derelict;</b>
<b class="fc">&nbsp;    public boolean privileged = false;</b>
&nbsp;
&nbsp;    //yes, this is a minor memory leak, but it&#39;s probably not significant enough to matter
<b class="fc">&nbsp;    protected static IntFloatMap unitTimeouts = new IntFloatMap();</b>
&nbsp;
&nbsp;    static{
<b class="fc">&nbsp;        Events.on(ResetEvent.class, e -&gt; unitTimeouts.clear());</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean timeoutDone(Unit unit, float delay){
<b class="nc">&nbsp;        return Time.time &gt;= unitTimeouts.get(unit.id) + delay;</b>
&nbsp;    }
&nbsp;
&nbsp;    void updateTimeout(Unit unit){
<b class="nc">&nbsp;        unitTimeouts.put(unit.id, Time.time);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean initialized(){
<b class="fc">&nbsp;        return instructions.length &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Runs a single instruction. */
&nbsp;    public void runOnce(){
&nbsp;        //reset to start
<b class="fc">&nbsp;        if(counter.numval &gt;= instructions.length || counter.numval &lt; 0){</b>
<b class="nc">&nbsp;            counter.numval = 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if(counter.numval &lt; instructions.length){</b>
<b class="fc">&nbsp;            instructions[(int)(counter.numval++)].run(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Loads with a specified assembler. Resets all variables. */
&nbsp;    public void load(LAssembler builder){
<b class="fc">&nbsp;        vars = builder.vars.values().toSeq().retainAll(var -&gt; !var.constant).toArray(LVar.class);</b>
<b class="fc">&nbsp;        for(int i = 0; i &lt; vars.length; i++){</b>
<b class="fc">&nbsp;            vars[i].id = i;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        instructions = builder.instructions;</b>
<b class="fc">&nbsp;        counter = builder.getVar(&quot;@counter&quot;);</b>
<b class="fc">&nbsp;        unit = builder.getVar(&quot;@unit&quot;);</b>
<b class="fc">&nbsp;        thisv = builder.getVar(&quot;@this&quot;);</b>
<b class="fc">&nbsp;        ipt = builder.putConst(&quot;@ipt&quot;, build != null ? build.ipt : 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    //region utility
&nbsp;
&nbsp;    /** @return a Var from this processor. May be null if out of bounds. */
&nbsp;    public @Nullable LVar optionalVar(int index){
<b class="nc">&nbsp;        return index &lt; 0 || index &gt;= vars.length ? null : vars[index];</b>
&nbsp;    }
&nbsp;
&nbsp;    //endregion
&nbsp;
&nbsp;    //region instruction types
&nbsp;
&nbsp;    public interface LInstruction{
&nbsp;        void run(LExecutor exec);
&nbsp;    }
&nbsp;
&nbsp;    /** Binds the processor to a unit based on some filters. */
&nbsp;    public static class UnitBindI implements LInstruction{
&nbsp;        public LVar type;
&nbsp;
<b class="nc">&nbsp;        public UnitBindI(LVar type){</b>
<b class="nc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public UnitBindI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(exec.binds == null || exec.binds.length != content.units().size){</b>
<b class="nc">&nbsp;                exec.binds = new int[content.units().size];</b>
&nbsp;            }
&nbsp;
&nbsp;            //binding to `null` was previously possible, but was too powerful and exploitable
<b class="nc">&nbsp;            if(type.obj() instanceof UnitType type &amp;&amp; type.logicControllable){</b>
<b class="nc">&nbsp;                Seq&lt;Unit&gt; seq = exec.team.data().unitCache(type);</b>
&nbsp;
<b class="nc">&nbsp;                if(seq != null &amp;&amp; seq.any()){</b>
<b class="nc">&nbsp;                    exec.binds[type.id] %= seq.size;</b>
<b class="nc">&nbsp;                    if(exec.binds[type.id] &lt; seq.size){</b>
&nbsp;                        //bind to the next unit
<b class="nc">&nbsp;                        exec.unit.setconst(seq.get(exec.binds[type.id]));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    exec.binds[type.id] ++;</b>
&nbsp;                }else{
&nbsp;                    //no units of this type found
<b class="nc">&nbsp;                    exec.unit.setconst(null);</b>
&nbsp;                }
<b class="nc">&nbsp;            }else if(type.obj() instanceof Unit u &amp;&amp; (u.team == exec.team || exec.privileged) &amp;&amp; u.type.logicControllable){</b>
&nbsp;                //bind to specific unit object
<b class="nc">&nbsp;                exec.unit.setconst(u);</b>
&nbsp;            }else{
<b class="nc">&nbsp;                exec.unit.setconst(null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Uses a unit to find something that may not be in its range. */
&nbsp;    public static class UnitLocateI implements LInstruction{
<b class="nc">&nbsp;        public LLocate locate = LLocate.building;</b>
<b class="nc">&nbsp;        public BlockFlag flag = BlockFlag.core;</b>
&nbsp;        public LVar enemy, ore;
&nbsp;        public LVar outX, outY, outFound, outBuild;
&nbsp;
<b class="nc">&nbsp;        public UnitLocateI(LLocate locate, BlockFlag flag, LVar enemy, LVar ore, LVar outX, LVar outY, LVar outFound, LVar outBuild){</b>
<b class="nc">&nbsp;            this.locate = locate;</b>
<b class="nc">&nbsp;            this.flag = flag;</b>
<b class="nc">&nbsp;            this.enemy = enemy;</b>
<b class="nc">&nbsp;            this.ore = ore;</b>
<b class="nc">&nbsp;            this.outX = outX;</b>
<b class="nc">&nbsp;            this.outY = outY;</b>
<b class="nc">&nbsp;            this.outFound = outFound;</b>
<b class="nc">&nbsp;            this.outBuild = outBuild;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public UnitLocateI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Object unitObj = exec.unit.obj();</b>
<b class="nc">&nbsp;            LogicAI ai = UnitControlI.checkLogicAI(exec, unitObj);</b>
&nbsp;
<b class="nc">&nbsp;            if(unitObj instanceof Unit unit &amp;&amp; ai != null){</b>
<b class="nc">&nbsp;                ai.controlTimer = LogicAI.logicControlTimeout;</b>
&nbsp;
<b class="nc">&nbsp;                Cache cache = (Cache)ai.execCache.get(this, Cache::new);</b>
&nbsp;
<b class="nc">&nbsp;                if(ai.checkTargetTimer(this)){</b>
<b class="nc">&nbsp;                    Tile res = null;</b>
<b class="nc">&nbsp;                    boolean build = false;</b>
&nbsp;
<b class="pc">&nbsp;                    switch(locate){</b>
&nbsp;                        case ore -&gt; {
<b class="nc">&nbsp;                            if(ore.obj() instanceof Item item){</b>
<b class="nc">&nbsp;                                res = indexer.findClosestOre(unit, item);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                        case building -&gt; {
<b class="nc">&nbsp;                            Building b = Geometry.findClosest(unit.x, unit.y, enemy.bool() ? indexer.getEnemy(unit.team, flag) : indexer.getFlagged(unit.team, flag));</b>
<b class="nc">&nbsp;                            res = b == null ? null : b.tile;</b>
<b class="nc">&nbsp;                            build = true;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                        case spawn -&gt; {
<b class="nc">&nbsp;                            res = Geometry.findClosest(unit.x, unit.y, Vars.spawner.getSpawns());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                        case damaged -&gt; {
<b class="nc">&nbsp;                            Building b = Units.findDamagedTile(unit.team, unit.x, unit.y);</b>
<b class="nc">&nbsp;                            res = b == null ? null : b.tile;</b>
<b class="nc">&nbsp;                            build = true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if(res != null &amp;&amp; (!build || res.build != null)){</b>
<b class="nc">&nbsp;                        cache.found = true;</b>
&nbsp;                        //set result if found
<b class="nc">&nbsp;                        outX.setnum(cache.x = World.conv(build ? res.build.x : res.worldx()));</b>
<b class="nc">&nbsp;                        outY.setnum(cache.y = World.conv(build ? res.build.y : res.worldy()));</b>
<b class="nc">&nbsp;                        outFound.setnum(1);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        cache.found = false;</b>
<b class="nc">&nbsp;                        outFound.setnum(0);</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if(res != null &amp;&amp; res.build != null &amp;&amp; </b>
<b class="nc">&nbsp;                        (unit.within(res.build.x, res.build.y, Math.max(unit.range(), buildingRange)) || res.build.team == exec.team)){</b>
<b class="nc">&nbsp;                        cache.build = res.build;</b>
<b class="nc">&nbsp;                        outBuild.setobj(res.build);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        outBuild.setobj(null);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }else{</b>
<b class="nc">&nbsp;                    outBuild.setobj(cache.build);</b>
<b class="nc">&nbsp;                    outFound.setbool(cache.found);</b>
<b class="nc">&nbsp;                    outX.setnum(cache.x);</b>
<b class="nc">&nbsp;                    outY.setnum(cache.y);</b>
&nbsp;                }
<b class="nc">&nbsp;            }else{</b>
<b class="nc">&nbsp;                outFound.setbool(false);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        static class Cache{</b>
&nbsp;            float x, y;
&nbsp;            boolean found;
&nbsp;            Building build;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Controls the unit based on some parameters. */
&nbsp;    public static class UnitControlI implements LInstruction{
<b class="nc">&nbsp;        public LUnitControl type = LUnitControl.move;</b>
&nbsp;        public LVar p1, p2, p3, p4, p5;
&nbsp;
<b class="nc">&nbsp;        public UnitControlI(LUnitControl type, LVar p1, LVar p2, LVar p3, LVar p4, LVar p5){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.p1 = p1;</b>
<b class="nc">&nbsp;            this.p2 = p2;</b>
<b class="nc">&nbsp;            this.p3 = p3;</b>
<b class="nc">&nbsp;            this.p4 = p4;</b>
<b class="nc">&nbsp;            this.p5 = p5;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public UnitControlI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Checks is a unit is valid for logic AI control, and returns the controller. */
&nbsp;        @Nullable
&nbsp;        public static LogicAI checkLogicAI(LExecutor exec, Object unitObj){
<b class="nc">&nbsp;            if(unitObj instanceof Unit unit &amp;&amp; unit.isValid() &amp;&amp; exec.unit.obj() == unit &amp;&amp; (unit.team == exec.team || exec.privileged) &amp;&amp; unit.controller().isLogicControllable()){</b>
<b class="nc">&nbsp;                if(unit.controller() instanceof LogicAI la){</b>
<b class="nc">&nbsp;                    la.controller = exec.thisv.building();</b>
<b class="nc">&nbsp;                    return la;</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    var la = new LogicAI();</b>
<b class="nc">&nbsp;                    la.controller = exec.thisv.building();</b>
&nbsp;
<b class="nc">&nbsp;                    unit.controller(la);</b>
&nbsp;                    //clear old state
<b class="nc">&nbsp;                    unit.mineTile = null;</b>
<b class="nc">&nbsp;                    unit.clearBuilding();</b>
&nbsp;
<b class="nc">&nbsp;                    return la;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Object unitObj = exec.unit.obj();</b>
<b class="nc">&nbsp;            LogicAI ai = checkLogicAI(exec, unitObj);</b>
&nbsp;
&nbsp;            //only control standard AI units
<b class="nc">&nbsp;            if(unitObj instanceof Unit unit &amp;&amp; ai != null){</b>
<b class="nc">&nbsp;                ai.controlTimer = LogicAI.logicControlTimeout;</b>
<b class="nc">&nbsp;                float x1 = World.unconv(p1.numf()), y1 = World.unconv(p2.numf()), d1 = World.unconv(p3.numf());</b>
&nbsp;
<b class="pc">&nbsp;                switch(type){</b>
&nbsp;                    case idle, autoPathfind -&gt; {
<b class="nc">&nbsp;                        ai.control = type;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case move, stop, approach, pathfind -&gt; {
<b class="nc">&nbsp;                        ai.control = type;</b>
<b class="nc">&nbsp;                        ai.moveX = x1;</b>
<b class="nc">&nbsp;                        ai.moveY = y1;</b>
<b class="nc">&nbsp;                        if(type == LUnitControl.approach){</b>
<b class="nc">&nbsp;                            ai.moveRad = d1;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //stop mining/building
<b class="nc">&nbsp;                        if(type == LUnitControl.stop){</b>
<b class="nc">&nbsp;                            unit.mineTile = null;</b>
<b class="nc">&nbsp;                            unit.clearBuilding();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    case unbind -&gt; {
&nbsp;                        //TODO is this a good idea? will allocate
<b class="nc">&nbsp;                        unit.resetController();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case within -&gt; {
<b class="nc">&nbsp;                        p4.setnum(unit.within(x1, y1, d1) ? 1 : 0);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case target -&gt; {
<b class="nc">&nbsp;                        ai.posTarget.set(x1, y1);</b>
<b class="nc">&nbsp;                        ai.aimControl = type;</b>
<b class="nc">&nbsp;                        ai.mainTarget = null;</b>
<b class="nc">&nbsp;                        ai.shoot = p3.bool();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case targetp -&gt; {
<b class="nc">&nbsp;                        ai.aimControl = type;</b>
<b class="nc">&nbsp;                        ai.mainTarget = p1.obj() instanceof Teamc t ? t : null;</b>
<b class="nc">&nbsp;                        ai.shoot = p2.bool();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case boost -&gt; {
<b class="nc">&nbsp;                        ai.boost = p1.bool();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case flag -&gt; {
<b class="nc">&nbsp;                        unit.flag = p1.num();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case mine -&gt; {
<b class="nc">&nbsp;                        Tile tile = world.tileWorld(x1, y1);</b>
<b class="nc">&nbsp;                        if(unit.canMine()){</b>
<b class="nc">&nbsp;                            unit.mineTile = unit.validMine(tile) ? tile : null;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case payDrop -&gt; {
<b class="nc">&nbsp;                        if(!exec.timeoutDone(unit, LogicAI.transferDelay)) return;</b>
&nbsp;
<b class="nc">&nbsp;                        if(unit instanceof Payloadc pay &amp;&amp; pay.hasPayload()){</b>
<b class="nc">&nbsp;                            Call.payloadDropped(unit, unit.x, unit.y);</b>
<b class="nc">&nbsp;                            exec.updateTimeout(unit);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case payTake -&gt; {
<b class="nc">&nbsp;                        if(!exec.timeoutDone(unit, LogicAI.transferDelay)) return;</b>
&nbsp;
<b class="nc">&nbsp;                        if(unit instanceof Payloadc pay){</b>
&nbsp;                            //units
<b class="nc">&nbsp;                            if(p1.bool()){</b>
<b class="nc">&nbsp;                                Unit result = Units.closest(unit.team, unit.x, unit.y, unit.type.hitSize * 2f, u -&gt; u.isAI() &amp;&amp; u.isGrounded() &amp;&amp; pay.canPickup(u) &amp;&amp; u.within(unit, u.hitSize + unit.hitSize * 1.2f));</b>
&nbsp;
<b class="nc">&nbsp;                                if(result != null){</b>
<b class="nc">&nbsp;                                    Call.pickedUnitPayload(unit, result);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }else{ //buildings</b>
<b class="nc">&nbsp;                                Building build = world.buildWorld(unit.x, unit.y);</b>
&nbsp;
&nbsp;                                //TODO copy pasted code
<b class="nc">&nbsp;                                if(build != null &amp;&amp; build.team == unit.team){</b>
<b class="nc">&nbsp;                                    Payload current = build.getPayload();</b>
<b class="nc">&nbsp;                                    if(current != null &amp;&amp; pay.canPickupPayload(current)){</b>
<b class="nc">&nbsp;                                        Call.pickedBuildPayload(unit, build, false);</b>
&nbsp;                                        //pick up whole building directly
<b class="nc">&nbsp;                                    }else if(build.block.buildVisibility != BuildVisibility.hidden &amp;&amp; build.canPickup() &amp;&amp; pay.canPickup(build)){</b>
<b class="nc">&nbsp;                                        Call.pickedBuildPayload(unit, build, true);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            exec.updateTimeout(unit);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case payEnter -&gt; {
<b class="nc">&nbsp;                        Building build = world.buildWorld(unit.x, unit.y);</b>
<b class="nc">&nbsp;                        if(build != null &amp;&amp; unit.team() == build.team &amp;&amp; build.canControlSelect(unit)){</b>
<b class="nc">&nbsp;                            Call.unitBuildingControlSelect(unit, build);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case build -&gt; {
<b class="nc">&nbsp;                        if((state.rules.logicUnitBuild || exec.privileged) &amp;&amp; unit.canBuild() &amp;&amp; p3.obj() instanceof Block block &amp;&amp; block.canBeBuilt() &amp;&amp; (block.unlockedNow() || unit.team.isAI())){</b>
<b class="nc">&nbsp;                            int x = World.toTile(x1 - block.offset/tilesize), y = World.toTile(y1 - block.offset/tilesize);</b>
<b class="nc">&nbsp;                            int rot = Mathf.mod(p4.numi(), 4);</b>
&nbsp;
&nbsp;                            //reset state of last request when necessary
<b class="nc">&nbsp;                            if(ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()){</b>
<b class="nc">&nbsp;                                ai.plan.progress = 0;</b>
<b class="nc">&nbsp;                                ai.plan.initialized = false;</b>
<b class="nc">&nbsp;                                ai.plan.stuck = false;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            var conf = p5.obj();</b>
<b class="nc">&nbsp;                            ai.plan.set(x, y, rot, block);</b>
<b class="nc">&nbsp;                            ai.plan.config = conf instanceof Content c ? c : conf instanceof Building b ? b : null;</b>
&nbsp;
<b class="nc">&nbsp;                            unit.clearBuilding();</b>
<b class="nc">&nbsp;                            Tile tile = ai.plan.tile();</b>
&nbsp;
<b class="nc">&nbsp;                            if(tile != null &amp;&amp; !(tile.block() == block &amp;&amp; tile.build != null &amp;&amp; tile.build.rotation == rot)){</b>
<b class="nc">&nbsp;                                unit.updateBuilding = true;</b>
<b class="nc">&nbsp;                                unit.addBuild(ai.plan);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case getBlock -&gt; {
<b class="nc">&nbsp;                        float range = Math.max(unit.range(), unit.type.buildRange);</b>
<b class="nc">&nbsp;                        if(!unit.within(x1, y1, range)){</b>
<b class="nc">&nbsp;                            p3.setobj(null);</b>
<b class="nc">&nbsp;                            p4.setobj(null);</b>
<b class="nc">&nbsp;                            p5.setobj(null);</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            Tile tile = world.tileWorld(x1, y1);</b>
<b class="nc">&nbsp;                            if(tile == null){</b>
<b class="nc">&nbsp;                                p3.setobj(null);</b>
<b class="nc">&nbsp;                                p4.setobj(null);</b>
<b class="nc">&nbsp;                                p5.setobj(null);</b>
&nbsp;                            }else{
<b class="nc">&nbsp;                                p3.setobj(tile.block());</b>
<b class="nc">&nbsp;                                p4.setobj(tile.build != null ? tile.build : null);</b>
&nbsp;                                //Allows reading of ore tiles if they are present (overlay is not air) otherwise returns the floor
<b class="nc">&nbsp;                                p5.setobj(tile.overlay() == Blocks.air ? tile.floor() : tile.overlay());</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case itemDrop -&gt; {
<b class="nc">&nbsp;                        if(!exec.timeoutDone(unit, LogicAI.transferDelay)) return;</b>
&nbsp;
&nbsp;                        //clear item when dropping to @air
<b class="nc">&nbsp;                        if(p1.obj() == Blocks.air){</b>
&nbsp;                            //only server-side; no need to call anything, as items are synced in snapshots
<b class="nc">&nbsp;                            if(!net.client()){</b>
<b class="nc">&nbsp;                                unit.clearItem();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            exec.updateTimeout(unit);</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            Building build = p1.building();</b>
<b class="nc">&nbsp;                            int dropped = Math.min(unit.stack.amount, p2.numi());</b>
<b class="nc">&nbsp;                            if(build != null &amp;&amp; build.team == unit.team &amp;&amp; build.isValid() &amp;&amp; dropped &gt; 0 &amp;&amp; unit.within(build, logicItemTransferRange + build.block.size * tilesize/2f)){</b>
<b class="nc">&nbsp;                                int accepted = build.acceptStack(unit.item(), dropped, unit);</b>
<b class="nc">&nbsp;                                if(accepted &gt; 0){</b>
<b class="nc">&nbsp;                                    Call.transferItemTo(unit, unit.item(), accepted, unit.x, unit.y, build);</b>
<b class="nc">&nbsp;                                    exec.updateTimeout(unit);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case itemTake -&gt; {
<b class="nc">&nbsp;                        if(!exec.timeoutDone(unit, LogicAI.transferDelay)) return;</b>
&nbsp;
<b class="nc">&nbsp;                        Building build = p1.building();</b>
<b class="nc">&nbsp;                        int amount = p3.numi();</b>
&nbsp;
<b class="nc">&nbsp;                        if(build != null &amp;&amp; build.team == unit.team &amp;&amp; build.isValid() &amp;&amp; build.items != null &amp;&amp;</b>
<b class="nc">&nbsp;                            p2.obj() instanceof Item item &amp;&amp; unit.within(build, logicItemTransferRange + build.block.size * tilesize/2f)){</b>
<b class="nc">&nbsp;                            int taken = Math.min(build.items.get(item), Math.min(amount, unit.maxAccepted(item)));</b>
&nbsp;
<b class="nc">&nbsp;                            if(taken &gt; 0){</b>
<b class="nc">&nbsp;                                Call.takeItems(build, item, taken, unit);</b>
<b class="nc">&nbsp;                                exec.updateTimeout(unit);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    default -&gt; {}
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Controls a building&#39;s state. */
&nbsp;    public static class ControlI implements LInstruction{
&nbsp;        public LVar target;
<b class="fc">&nbsp;        public LAccess type = LAccess.enabled;</b>
&nbsp;        public LVar p1, p2, p3, p4;
&nbsp;
<b class="fc">&nbsp;        public ControlI(LAccess type, LVar target, LVar p1, LVar p2, LVar p3, LVar p4){</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.p1 = p1;</b>
<b class="fc">&nbsp;            this.p2 = p2;</b>
<b class="fc">&nbsp;            this.p3 = p3;</b>
<b class="fc">&nbsp;            this.p4 = p4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ControlI(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Object obj = target.obj();</b>
<b class="nc">&nbsp;            if(obj instanceof Building b &amp;&amp; (exec.privileged || (b.team == exec.team &amp;&amp; exec.linkIds.contains(b.id)))){</b>
&nbsp;
<b class="nc">&nbsp;                if(type == LAccess.enabled &amp;&amp; !p1.bool()){</b>
<b class="nc">&nbsp;                    b.lastDisabler = exec.build;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(type == LAccess.enabled &amp;&amp; p1.bool()){</b>
<b class="nc">&nbsp;                    b.noSleep();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(type.isObj &amp;&amp; p1.isobj){</b>
<b class="nc">&nbsp;                    b.control(type, p1.obj(), p2.num(), p3.num(), p4.num());</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    b.control(type, p1.num(), p2.num(), p3.num(), p4.num());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class GetLinkI implements LInstruction{
&nbsp;        public LVar output, index;
&nbsp;
<b class="nc">&nbsp;        public GetLinkI(LVar output, LVar index){</b>
<b class="nc">&nbsp;            this.index = index;</b>
<b class="nc">&nbsp;            this.output = output;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public GetLinkI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            int address = index.numi();</b>
&nbsp;
<b class="nc">&nbsp;            output.setobj(address &gt;= 0 &amp;&amp; address &lt; exec.links.length ? exec.links[address] : null);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ReadI implements LInstruction{
&nbsp;        public LVar target, position, output;
&nbsp;
<b class="nc">&nbsp;        public ReadI(LVar target, LVar position, LVar output){</b>
<b class="nc">&nbsp;            this.target = target;</b>
<b class="nc">&nbsp;            this.position = position;</b>
<b class="nc">&nbsp;            this.output = output;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ReadI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            int address = position.numi();</b>
<b class="nc">&nbsp;            Building from = target.building();</b>
&nbsp;
<b class="nc">&nbsp;            if(from instanceof MemoryBuild mem &amp;&amp; (exec.privileged || (from.team == exec.team &amp;&amp; !mem.block.privileged))){</b>
<b class="nc">&nbsp;                output.setnum(address &lt; 0 || address &gt;= mem.memory.length ? 0 : mem.memory[address]);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class WriteI implements LInstruction{
&nbsp;        public LVar target, position, value;
&nbsp;
<b class="nc">&nbsp;        public WriteI(LVar target, LVar position, LVar value){</b>
<b class="nc">&nbsp;            this.target = target;</b>
<b class="nc">&nbsp;            this.position = position;</b>
<b class="nc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public WriteI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            int address = position.numi();</b>
<b class="nc">&nbsp;            Building from = target.building();</b>
&nbsp;
<b class="nc">&nbsp;            if(from instanceof MemoryBuild mem &amp;&amp; (exec.privileged || (from.team == exec.team &amp;&amp; !mem.block.privileged)) &amp;&amp; address &gt;= 0 &amp;&amp; address &lt; mem.memory.length){</b>
<b class="nc">&nbsp;                mem.memory[address] = value.num();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SenseI implements LInstruction{
&nbsp;        public LVar from, to, type;
&nbsp;
<b class="fc">&nbsp;        public SenseI(LVar from, LVar to, LVar type){</b>
<b class="fc">&nbsp;            this.from = from;</b>
<b class="fc">&nbsp;            this.to = to;</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SenseI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="fc">&nbsp;            Object target = from.obj();</b>
<b class="fc">&nbsp;            Object sense = type.obj();</b>
&nbsp;
<b class="fc">&nbsp;            if(target == null &amp;&amp; sense == LAccess.dead){</b>
<b class="nc">&nbsp;                to.setnum(1);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            //note that remote units/buildings can be sensed as well
<b class="fc">&nbsp;            if(target instanceof Senseable se){</b>
<b class="nc">&nbsp;                if(sense instanceof Content co){</b>
<b class="nc">&nbsp;                    to.setnum(se.sense(co));</b>
<b class="nc">&nbsp;                }else if(sense instanceof LAccess la){</b>
<b class="nc">&nbsp;                    Object objOut = se.senseObject(la);</b>
&nbsp;
<b class="nc">&nbsp;                    if(objOut == Senseable.noSensed){</b>
&nbsp;                        //numeric output
<b class="nc">&nbsp;                        to.setnum(se.sense(la));</b>
&nbsp;                    }else{
&nbsp;                        //object output
<b class="nc">&nbsp;                        to.setobj(objOut);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }else{
<b class="fc">&nbsp;                to.setobj(null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class RadarI implements LInstruction{
<b class="nc">&nbsp;        public RadarTarget target1 = RadarTarget.enemy, target2 = RadarTarget.any, target3 = RadarTarget.any;</b>
<b class="nc">&nbsp;        public RadarSort sort = RadarSort.distance;</b>
&nbsp;        public LVar radar, sortOrder, output;
&nbsp;
&nbsp;        //radar instructions are special in that they cache their output and only change it at fixed intervals.
&nbsp;        //this prevents lag from spam of radar instructions
&nbsp;        public Healthc lastTarget;
&nbsp;        public Object lastSourceBuild;
<b class="nc">&nbsp;        public Interval timer = new Interval();</b>
&nbsp;
<b class="nc">&nbsp;        static float bestValue = 0f;</b>
<b class="nc">&nbsp;        static Unit best = null;</b>
&nbsp;
<b class="nc">&nbsp;        public RadarI(RadarTarget target1, RadarTarget target2, RadarTarget target3, RadarSort sort, LVar radar, LVar sortOrder, LVar output){</b>
<b class="nc">&nbsp;            this.target1 = target1;</b>
<b class="nc">&nbsp;            this.target2 = target2;</b>
<b class="nc">&nbsp;            this.target3 = target3;</b>
<b class="nc">&nbsp;            this.sort = sort;</b>
<b class="nc">&nbsp;            this.radar = radar;</b>
<b class="nc">&nbsp;            this.sortOrder = sortOrder;</b>
<b class="nc">&nbsp;            this.output = output;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public RadarI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Object base = radar.obj();</b>
&nbsp;
<b class="nc">&nbsp;            int sortDir = sortOrder.bool() ? 1 : -1;</b>
<b class="nc">&nbsp;            LogicAI ai = null;</b>
&nbsp;
<b class="nc">&nbsp;            if(base instanceof Ranged r &amp;&amp; (exec.privileged || r.team() == exec.team) &amp;&amp;</b>
<b class="nc">&nbsp;                ((base instanceof Building b &amp;&amp; (!b.block.privileged || exec.privileged)) || (ai = UnitControlI.checkLogicAI(exec, base)) != null)){ //must be a building or a controllable unit</b>
<b class="nc">&nbsp;                float range = r.range();</b>
&nbsp;
&nbsp;                Healthc targeted;
&nbsp;
&nbsp;                //timers update on a fixed 30 tick interval
&nbsp;                //units update on a special timer per controller instance
<b class="nc">&nbsp;                if((base instanceof Building &amp;&amp; (timer.get(30f) || lastSourceBuild != base)) || (ai != null &amp;&amp; ai.checkTargetTimer(this))){</b>
&nbsp;                    //if any of the targets involve enemies
<b class="nc">&nbsp;                    boolean enemies = target1 == RadarTarget.enemy || target2 == RadarTarget.enemy || target3 == RadarTarget.enemy;</b>
<b class="nc">&nbsp;                    boolean allies = target1 == RadarTarget.ally || target2 == RadarTarget.ally || target3 == RadarTarget.ally;</b>
&nbsp;
<b class="nc">&nbsp;                    best = null;</b>
<b class="nc">&nbsp;                    bestValue = 0;</b>
&nbsp;
<b class="nc">&nbsp;                    if(enemies){</b>
<b class="nc">&nbsp;                        Seq&lt;TeamData&gt; data = state.teams.present;</b>
<b class="nc">&nbsp;                        for(int i = 0; i &lt; data.size; i++){</b>
<b class="nc">&nbsp;                            if(data.items[i].team != r.team()){</b>
<b class="nc">&nbsp;                                find(r, range, sortDir, data.items[i].team);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }else if(!allies){</b>
<b class="nc">&nbsp;                        Seq&lt;TeamData&gt; data = state.teams.present;</b>
<b class="nc">&nbsp;                        for(int i = 0; i &lt; data.size; i++){</b>
<b class="nc">&nbsp;                            find(r, range, sortDir, data.items[i].team);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }else{</b>
<b class="nc">&nbsp;                        find(r, range, sortDir, r.team());</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if(ai != null){</b>
<b class="nc">&nbsp;                        ai.execCache.put(this, best);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    lastSourceBuild = base;</b>
<b class="nc">&nbsp;                    lastTarget = targeted = best;</b>
<b class="nc">&nbsp;                }else{</b>
<b class="nc">&nbsp;                    if(ai != null){</b>
<b class="nc">&nbsp;                        targeted = (Healthc)ai.execCache.get(this);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        targeted = lastTarget;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                output.setobj(targeted);</b>
<b class="nc">&nbsp;            }else{</b>
<b class="nc">&nbsp;                output.setobj(null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        void find(Ranged b, float range, int sortDir, Team team){
<b class="nc">&nbsp;            Units.nearby(team, b.x(), b.y(), range, u -&gt; {</b>
<b class="nc">&nbsp;                if(!u.within(b, range) || !u.targetable(team) || b == u) return;</b>
&nbsp;
<b class="nc">&nbsp;                boolean valid =</b>
<b class="nc">&nbsp;                    target1.func.get(b.team(), u) &amp;&amp;</b>
<b class="nc">&nbsp;                    target2.func.get(b.team(), u) &amp;&amp;</b>
<b class="nc">&nbsp;                    target3.func.get(b.team(), u);</b>
&nbsp;
<b class="nc">&nbsp;                if(!valid) return;</b>
&nbsp;
<b class="nc">&nbsp;                float val = sort.func.get(b, u) * sortDir;</b>
<b class="nc">&nbsp;                if(val &gt; bestValue || best == null){</b>
<b class="nc">&nbsp;                    bestValue = val;</b>
<b class="nc">&nbsp;                    best = u;</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetI implements LInstruction{
&nbsp;        public LVar from, to;
&nbsp;
<b class="fc">&nbsp;        public SetI(LVar from, LVar to){</b>
<b class="fc">&nbsp;            this.from = from;</b>
<b class="fc">&nbsp;            this.to = to;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        SetI(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(!to.constant){</b>
<b class="nc">&nbsp;                if(from.isobj){</b>
<b class="nc">&nbsp;                    if(to != exec.counter){</b>
<b class="nc">&nbsp;                        to.objval = from.objval;</b>
<b class="nc">&nbsp;                        to.isobj = true;</b>
&nbsp;                    }
&nbsp;                }else{
<b class="nc">&nbsp;                    to.numval = LVar.invalid(from.numval) ? 0 : from.numval;</b>
<b class="nc">&nbsp;                    to.isobj = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class OpI implements LInstruction{
<b class="fc">&nbsp;        public LogicOp op = LogicOp.add;</b>
&nbsp;        public LVar a, b, dest;
&nbsp;
<b class="fc">&nbsp;        public OpI(LogicOp op, LVar a, LVar b, LVar dest){</b>
<b class="fc">&nbsp;            this.op = op;</b>
<b class="fc">&nbsp;            this.a = a;</b>
<b class="fc">&nbsp;            this.b = b;</b>
<b class="fc">&nbsp;            this.dest = dest;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        OpI(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="fc">&nbsp;            if(op == LogicOp.strictEqual){</b>
<b class="nc">&nbsp;                dest.setnum(a.isobj == b.isobj &amp;&amp; ((a.isobj &amp;&amp; Structs.eq(a.objval, b.objval)) || (!a.isobj &amp;&amp; a.numval == b.numval)) ? 1 : 0);</b>
<b class="fc">&nbsp;            }else if(op.unary){</b>
<b class="nc">&nbsp;                dest.setnum(op.function1.get(a.num()));</b>
&nbsp;            }else{
<b class="fc">&nbsp;                if(op.objFunction2 != null &amp;&amp; a.isobj &amp;&amp; b.isobj){</b>
&nbsp;                    //use object function if both are objects
<b class="nc">&nbsp;                    dest.setnum(op.objFunction2.get(a.obj(), b.obj()));</b>
&nbsp;                }else{
&nbsp;                    //otherwise use the numeric function
<b class="fc">&nbsp;                    dest.setnum(op.function2.get(a.num(), b.num()));</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static class EndI implements LInstruction{</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            exec.counter.numval = exec.instructions.length;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static class NoopI implements LInstruction{</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public void run(LExecutor exec){}</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class DrawI implements LInstruction{
&nbsp;        public byte type;
&nbsp;        public LVar x, y, p1, p2, p3, p4;
&nbsp;
<b class="nc">&nbsp;        public DrawI(byte type, LVar x, LVar y, LVar p1, LVar p2, LVar p3, LVar p4){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
<b class="nc">&nbsp;            this.p1 = p1;</b>
<b class="nc">&nbsp;            this.p2 = p2;</b>
<b class="nc">&nbsp;            this.p3 = p3;</b>
<b class="nc">&nbsp;            this.p4 = p4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public DrawI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;            //graphics on headless servers are useless.
<b class="nc">&nbsp;            if(Vars.headless || exec.graphicsBuffer.size &gt;= maxGraphicsBuffer) return;</b>
&nbsp;
&nbsp;            //explicitly unpack colorPack, it&#39;s pre-processed here
<b class="nc">&nbsp;            if(type == LogicDisplay.commandColorPack){</b>
<b class="nc">&nbsp;                double packed = x.num();</b>
&nbsp;
<b class="nc">&nbsp;                int value = (int)(Double.doubleToRawLongBits(packed)),</b>
<b class="nc">&nbsp;                r = ((value &amp; 0xff000000) &gt;&gt;&gt; 24),</b>
<b class="nc">&nbsp;                g = ((value &amp; 0x00ff0000) &gt;&gt;&gt; 16),</b>
<b class="nc">&nbsp;                b = ((value &amp; 0x0000ff00) &gt;&gt;&gt; 8),</b>
<b class="nc">&nbsp;                a = ((value &amp; 0x000000ff));</b>
&nbsp;
<b class="nc">&nbsp;                exec.graphicsBuffer.add(DisplayCmd.get(LogicDisplay.commandColor, pack(r), pack(g), pack(b), pack(a), 0, 0));</b>
<b class="nc">&nbsp;            }else if(type == LogicDisplay.commandPrint){</b>
<b class="nc">&nbsp;                CharSequence str = exec.textBuffer;</b>
&nbsp;
<b class="nc">&nbsp;                if(str.length() &gt; 0){</b>
<b class="nc">&nbsp;                    var data = Fonts.logic.getData();</b>
<b class="nc">&nbsp;                    int advance = (int)data.spaceXadvance, lineHeight = (int)data.lineHeight;</b>
&nbsp;
&nbsp;                    int xOffset, yOffset;
<b class="nc">&nbsp;                    int align = p1.id; //p1 is not a variable, it&#39;s a raw align value. what a massive hack</b>
&nbsp;
<b class="nc">&nbsp;                    int maxWidth = 0, lines = 1, lineWidth = 0;</b>
<b class="nc">&nbsp;                    for(int i = 0; i &lt; str.length(); i++){</b>
<b class="nc">&nbsp;                        char next = str.charAt(i);</b>
<b class="nc">&nbsp;                        if(next == &#39;\n&#39;){</b>
<b class="nc">&nbsp;                            maxWidth = Math.max(maxWidth, lineWidth);</b>
<b class="nc">&nbsp;                            lineWidth = 0;</b>
<b class="nc">&nbsp;                            lines ++;</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            lineWidth ++;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    maxWidth = Math.max(maxWidth, lineWidth);</b>
&nbsp;
&nbsp;                    float
<b class="nc">&nbsp;                    width = maxWidth * advance,</b>
<b class="nc">&nbsp;                    height = lines * lineHeight,</b>
<b class="nc">&nbsp;                    ha = ((Align.isLeft(align) ? -1f : 0f) + 1f + (Align.isRight(align) ? 1f : 0f))/2f,</b>
<b class="nc">&nbsp;                    va = ((Align.isBottom(align) ? -1f : 0f) + 1f + (Align.isTop(align) ? 1f : 0f))/2f;</b>
&nbsp;
<b class="nc">&nbsp;                    xOffset = -(int)(width * ha);</b>
<b class="nc">&nbsp;                    yOffset = -(int)(height * va) + (lines - 1) * lineHeight;</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;                    int curX = x.numi(), curY = y.numi();</b>
<b class="nc">&nbsp;                    for(int i = 0; i &lt; str.length(); i++){</b>
<b class="nc">&nbsp;                        char next = str.charAt(i);</b>
<b class="nc">&nbsp;                        if(next == &#39;\n&#39;){</b>
&nbsp;                            //move Y down when newline is encountered
<b class="nc">&nbsp;                            curY -= lineHeight;</b>
<b class="nc">&nbsp;                            curX = x.numi(); //reset</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if(Fonts.logic.getData().hasGlyph(next)){</b>
<b class="nc">&nbsp;                            exec.graphicsBuffer.add(DisplayCmd.get(LogicDisplay.commandPrint, packSign(curX + xOffset), packSign(curY + yOffset), next, 0, 0, 0));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        curX += advance;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    exec.textBuffer.setLength(0);</b>
&nbsp;                }
<b class="nc">&nbsp;            }else{</b>
<b class="nc">&nbsp;                int num1 = p1.numi(), num4 = p4.numi(), xval = packSign(x.numi()), yval = packSign(y.numi());</b>
&nbsp;
<b class="nc">&nbsp;                if(type == LogicDisplay.commandImage){</b>
<b class="nc">&nbsp;                    if(p1.obj() instanceof UnlockableContent u){</b>
&nbsp;                        //TODO: with mods, this will overflow (ID &gt;= 512), but that&#39;s better than the previous system, at least
<b class="nc">&nbsp;                        num1 = u.id;</b>
<b class="nc">&nbsp;                        num4 = u.getContentType().ordinal();</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        num1 = -1;</b>
<b class="nc">&nbsp;                        num4 = -1;</b>
&nbsp;                    }
&nbsp;                    //num1 = p1.obj() instanceof UnlockableContent u ? u.iconId : 0;
<b class="nc">&nbsp;                }else if(type == LogicDisplay.commandScale){</b>
<b class="nc">&nbsp;                    xval = packSign((int)(x.numf() / LogicDisplay.scaleStep));</b>
<b class="nc">&nbsp;                    yval = packSign((int)(y.numf() / LogicDisplay.scaleStep));</b>
&nbsp;                }
&nbsp;
&nbsp;                //add graphics calls, cap graphics buffer size
<b class="nc">&nbsp;                exec.graphicsBuffer.add(DisplayCmd.get(type, xval, yval, packSign(num1), packSign(p2.numi()), packSign(p3.numi()), packSign(num4)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static int pack(int value){
<b class="nc">&nbsp;            return value &amp; 0b0111111111;</b>
&nbsp;        }
&nbsp;
&nbsp;        static int packSign(int value){
<b class="nc">&nbsp;            return (Math.abs(value) &amp; 0b0111111111) | (value &lt; 0 ? 0b1000000000 : 0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class DrawFlushI implements LInstruction{
&nbsp;        public LVar target;
&nbsp;
<b class="nc">&nbsp;        public DrawFlushI(LVar target){</b>
<b class="nc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public DrawFlushI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;            //graphics on headless servers are useless.
<b class="nc">&nbsp;            if(Vars.headless) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(target.building() instanceof LogicDisplayBuild d &amp;&amp; (d.team == exec.team || exec.privileged)){</b>
<b class="nc">&nbsp;                if(d.commands.size + exec.graphicsBuffer.size &lt; maxDisplayBuffer){</b>
<b class="nc">&nbsp;                    for(int i = 0; i &lt; exec.graphicsBuffer.size; i++){</b>
<b class="nc">&nbsp;                        d.commands.addLast(exec.graphicsBuffer.items[i]);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                exec.graphicsBuffer.clear();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class PrintI implements LInstruction{
&nbsp;        public LVar value;
&nbsp;
<b class="fc">&nbsp;        public PrintI(LVar value){</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PrintI(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;
<b class="nc">&nbsp;            if(exec.textBuffer.length() &gt;= maxTextBuffer) return;</b>
&nbsp;
&nbsp;            //this should avoid any garbage allocation
<b class="nc">&nbsp;            if(value.isobj){</b>
<b class="nc">&nbsp;                String strValue = toString(value.objval);</b>
&nbsp;
<b class="nc">&nbsp;                exec.textBuffer.append(strValue);</b>
<b class="nc">&nbsp;            }else{</b>
&nbsp;                //display integer version when possible
<b class="nc">&nbsp;                if(Math.abs(value.numval - (long)value.numval) &lt; 0.00001){</b>
<b class="nc">&nbsp;                    exec.textBuffer.append((long)value.numval);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    exec.textBuffer.append(value.numval);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static String toString(Object obj){
&nbsp;            return
<b class="nc">&nbsp;                obj == null ? &quot;null&quot; :</b>
<b class="nc">&nbsp;                obj instanceof String s ? s :</b>
<b class="nc">&nbsp;                obj instanceof MappableContent content ? content.name :</b>
<b class="nc">&nbsp;                obj instanceof Content ? &quot;[content]&quot; :</b>
<b class="nc">&nbsp;                obj instanceof Building build ? build.block.name :</b>
<b class="nc">&nbsp;                obj instanceof Unit unit ? unit.type.name :</b>
<b class="nc">&nbsp;                obj instanceof Enum&lt;?&gt; e ? e.name() :</b>
<b class="nc">&nbsp;                obj instanceof Team team ? team.name :</b>
<b class="nc">&nbsp;                &quot;[object]&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class FormatI implements LInstruction{
&nbsp;        public LVar value;
&nbsp;
<b class="nc">&nbsp;        public FormatI(LVar value){</b>
<b class="nc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        FormatI(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;
<b class="nc">&nbsp;            if(exec.textBuffer.length() &gt;= maxTextBuffer) return;</b>
&nbsp;
<b class="nc">&nbsp;            int placeholderIndex = -1;</b>
<b class="nc">&nbsp;            int placeholderNumber = 10;</b>
&nbsp;
<b class="nc">&nbsp;            for(int i = 0; i &lt; exec.textBuffer.length(); i++){</b>
<b class="nc">&nbsp;                if(exec.textBuffer.charAt(i) == &#39;{&#39; &amp;&amp; exec.textBuffer.length() - i &gt; 2){</b>
<b class="nc">&nbsp;                    char numChar = exec.textBuffer.charAt(i + 1);</b>
&nbsp;
<b class="nc">&nbsp;                    if(numChar &gt;= &#39;0&#39; &amp;&amp; numChar &lt;= &#39;9&#39; &amp;&amp; exec.textBuffer.charAt(i + 2) == &#39;}&#39;){</b>
<b class="nc">&nbsp;                        if(numChar - &#39;0&#39; &lt; placeholderNumber){</b>
<b class="nc">&nbsp;                            placeholderNumber = numChar - &#39;0&#39;;</b>
<b class="nc">&nbsp;                            placeholderIndex = i;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(placeholderIndex == -1) return;</b>
&nbsp;
&nbsp;            //this should avoid any garbage allocation
<b class="nc">&nbsp;            if(value.isobj){</b>
<b class="nc">&nbsp;                String strValue = PrintI.toString(value.objval);</b>
&nbsp;
<b class="nc">&nbsp;                exec.textBuffer.replace(placeholderIndex, placeholderIndex + 3, strValue);</b>
<b class="nc">&nbsp;            }else{</b>
&nbsp;                //display integer version when possible
<b class="nc">&nbsp;                if(Math.abs(value.numval - (long)value.numval) &lt; 0.00001){</b>
<b class="nc">&nbsp;                    exec.textBuffer.replace(placeholderIndex, placeholderIndex + 3, (long)value.numval + &quot;&quot;);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    exec.textBuffer.replace(placeholderIndex, placeholderIndex + 3, value.numval + &quot;&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class PrintFlushI implements LInstruction{
&nbsp;        public LVar target;
&nbsp;
<b class="nc">&nbsp;        public PrintFlushI(LVar target){</b>
<b class="nc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PrintFlushI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;
<b class="nc">&nbsp;            if(target.building() instanceof MessageBuild d &amp;&amp; (exec.privileged || (d.team == exec.team &amp;&amp; !d.block.privileged))){</b>
&nbsp;
<b class="nc">&nbsp;                d.message.setLength(0);</b>
<b class="nc">&nbsp;                d.message.append(exec.textBuffer, 0, Math.min(exec.textBuffer.length(), maxTextBuffer));</b>
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            exec.textBuffer.setLength(0);</b>
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class JumpI implements LInstruction{
<b class="fc">&nbsp;        public ConditionOp op = ConditionOp.notEqual;</b>
&nbsp;        public LVar value, compare;
&nbsp;        public int address;
&nbsp;
<b class="fc">&nbsp;        public JumpI(ConditionOp op, LVar value, LVar compare, int address){</b>
<b class="fc">&nbsp;            this.op = op;</b>
<b class="fc">&nbsp;            this.value = value;</b>
<b class="fc">&nbsp;            this.compare = compare;</b>
<b class="fc">&nbsp;            this.address = address;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public JumpI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="fc">&nbsp;            if(address != -1){</b>
<b class="fc">&nbsp;                LVar va = value;</b>
<b class="fc">&nbsp;                LVar vb = compare;</b>
&nbsp;                boolean cmp;
&nbsp;
<b class="fc">&nbsp;                if(op == ConditionOp.strictEqual){</b>
<b class="nc">&nbsp;                    cmp = va.isobj == vb.isobj &amp;&amp; ((va.isobj &amp;&amp; va.objval == vb.objval) || (!va.isobj &amp;&amp; va.numval == vb.numval));</b>
<b class="fc">&nbsp;                }else if(op.objFunction != null &amp;&amp; va.isobj &amp;&amp; vb.isobj){</b>
&nbsp;                    //use object function if both are objects
<b class="nc">&nbsp;                    cmp = op.objFunction.get(value.obj(), compare.obj());</b>
&nbsp;                }else{
<b class="fc">&nbsp;                    cmp = op.function.get(value.num(), compare.num());</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if(cmp){</b>
<b class="fc">&nbsp;                    exec.counter.numval = address;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class WaitI implements LInstruction{
&nbsp;        public LVar value;
&nbsp;
&nbsp;        public float curTime;
&nbsp;
<b class="fc">&nbsp;        public WaitI(LVar value){</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public WaitI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(curTime &gt;= value.num()){</b>
<b class="nc">&nbsp;                curTime = 0f;</b>
&nbsp;            }else{
&nbsp;                //skip back to self.
<b class="nc">&nbsp;                exec.counter.numval --;</b>
<b class="nc">&nbsp;                exec.yield = true;</b>
<b class="nc">&nbsp;                curTime += Time.delta / 60f;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static class StopI implements LInstruction{</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;            //skip back to self.
<b class="nc">&nbsp;            exec.counter.numval --;</b>
<b class="nc">&nbsp;            exec.yield = true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class LookupI implements LInstruction{
&nbsp;        public LVar dest;
&nbsp;        public LVar from;
&nbsp;        public ContentType type;
&nbsp;
<b class="nc">&nbsp;        public LookupI(LVar dest, LVar from, ContentType type){</b>
<b class="nc">&nbsp;            this.dest = dest;</b>
<b class="nc">&nbsp;            this.from = from;</b>
<b class="nc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public LookupI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            dest.setobj(logicVars.lookupContent(type, from.numi()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class PackColorI implements LInstruction{
&nbsp;        public LVar result, r, g, b, a;
&nbsp;
<b class="nc">&nbsp;        public PackColorI(LVar result, LVar r, LVar g, LVar b, LVar a){</b>
<b class="nc">&nbsp;            this.result = result;</b>
<b class="nc">&nbsp;            this.r = r;</b>
<b class="nc">&nbsp;            this.g = g;</b>
<b class="nc">&nbsp;            this.b = b;</b>
<b class="nc">&nbsp;            this.a = a;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PackColorI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            result.setnum(Color.toDoubleBits(Mathf.clamp(r.numf()), Mathf.clamp(g.numf()), Mathf.clamp(b.numf()), Mathf.clamp(a.numf())));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class CutsceneI implements LInstruction{
<b class="fc">&nbsp;        public CutsceneAction action = CutsceneAction.stop;</b>
&nbsp;        public LVar p1, p2, p3, p4;
&nbsp;
<b class="fc">&nbsp;        public CutsceneI(CutsceneAction action, LVar p1, LVar p2, LVar p3, LVar p4){</b>
<b class="fc">&nbsp;            this.action = action;</b>
<b class="fc">&nbsp;            this.p1 = p1;</b>
<b class="fc">&nbsp;            this.p2 = p2;</b>
<b class="fc">&nbsp;            this.p3 = p3;</b>
<b class="fc">&nbsp;            this.p4 = p4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public CutsceneI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(headless) return;</b>
&nbsp;
<b class="pc">&nbsp;            switch(action){</b>
&nbsp;                case pan -&gt; {
<b class="nc">&nbsp;                    control.input.logicCutscene = true;</b>
<b class="nc">&nbsp;                    control.input.logicCamPan.set(World.unconv(p1.numf()), World.unconv(p2.numf()));</b>
<b class="nc">&nbsp;                    control.input.logicCamSpeed = p3.numf();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                case zoom -&gt; {
<b class="nc">&nbsp;                    control.input.logicCutscene = true;</b>
<b class="nc">&nbsp;                    control.input.logicCutsceneZoom = Mathf.clamp(p1.numf());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                case stop -&gt; {
<b class="nc">&nbsp;                    control.input.logicCutscene = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class FetchI implements LInstruction{
<b class="fc">&nbsp;        public FetchType type = FetchType.unit;</b>
&nbsp;        public LVar result, team, extra, index;
&nbsp;
<b class="fc">&nbsp;        public FetchI(FetchType type, LVar result, LVar team, LVar extra, LVar index){</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.result = result;</b>
<b class="fc">&nbsp;            this.team = team;</b>
<b class="fc">&nbsp;            this.extra = extra;</b>
<b class="fc">&nbsp;            this.index = index;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public FetchI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="fc">&nbsp;            int i = index.numi();</b>
<b class="fc">&nbsp;            Team t = team.team();</b>
<b class="fc">&nbsp;            if(t == null) return;</b>
<b class="fc">&nbsp;            TeamData data = t.data();</b>
&nbsp;
<b class="fc">&nbsp;            switch(type){</b>
&nbsp;                case unit -&gt; {
<b class="nc">&nbsp;                    UnitType type = extra.obj() instanceof UnitType u ? u : null;</b>
<b class="nc">&nbsp;                    if(type == null){</b>
<b class="nc">&nbsp;                        result.setobj(i &lt; 0 || i &gt;= data.units.size ? null : data.units.get(i));</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        var units = data.unitCache(type);</b>
<b class="nc">&nbsp;                        result.setobj(units == null || i &lt; 0 || i &gt;= units.size ? null : units.get(i));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                case player -&gt; result.setobj(i &lt; 0 || i &gt;= data.players.size ? null :</b>
<b class="nc">&nbsp;                    data.players.get(i).unit() instanceof BlockUnitc block ? block.tile() : data.players.get(i).unit());</b>
<b class="nc">&nbsp;                case core -&gt; result.setobj(i &lt; 0 || i &gt;= data.cores.size ? null : data.cores.get(i));</b>
&nbsp;                case build -&gt; {
<b class="fc">&nbsp;                    Block block = extra.obj() instanceof Block b ? b : null;</b>
<b class="fc">&nbsp;                    if(block == null){</b>
<b class="nc">&nbsp;                        result.setobj(i &lt; 0 || i &gt;= data.buildings.size ? null : data.buildings.get(i));</b>
&nbsp;                    }else{
<b class="fc">&nbsp;                        var builds = data.getBuildings(block);</b>
<b class="fc">&nbsp;                        result.setobj(i &lt; 0 || i &gt;= builds.size ? null : builds.get(i));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;                case unitCount -&gt; {
<b class="nc">&nbsp;                    UnitType type = extra.obj() instanceof UnitType u ? u : null;</b>
<b class="nc">&nbsp;                    if(type == null){</b>
<b class="nc">&nbsp;                        result.setnum(data.units.size);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        result.setnum(data.unitCache(type) == null ? 0 : data.unitCache(type).size);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                case coreCount -&gt; result.setnum(data.cores.size);</b>
<b class="nc">&nbsp;                case playerCount -&gt; result.setnum(data.players.size);</b>
&nbsp;                case buildCount -&gt; {
<b class="fc">&nbsp;                    Block block = extra.obj() instanceof Block b ? b : null;</b>
<b class="fc">&nbsp;                    if(block == null){</b>
<b class="nc">&nbsp;                        result.setnum(data.buildings.size);</b>
&nbsp;                    }else{
<b class="fc">&nbsp;                        result.setnum(data.getBuildings(block).size);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //endregion
&nbsp;    //region privileged / world instructions
&nbsp;
&nbsp;    public static class GetBlockI implements LInstruction{
&nbsp;        public LVar x, y;
&nbsp;        public LVar dest;
<b class="fc">&nbsp;        public TileLayer layer = TileLayer.block;</b>
&nbsp;
<b class="fc">&nbsp;        public GetBlockI(LVar x, LVar y, LVar dest, TileLayer layer){</b>
<b class="fc">&nbsp;            this.x = x;</b>
<b class="fc">&nbsp;            this.y = y;</b>
<b class="fc">&nbsp;            this.dest = dest;</b>
<b class="fc">&nbsp;            this.layer = layer;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public GetBlockI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Tile tile = world.tile(Mathf.round(x.numf()), Mathf.round(y.numf()));</b>
<b class="nc">&nbsp;            if(tile == null){</b>
<b class="nc">&nbsp;                dest.setobj(null);</b>
&nbsp;            }else{
<b class="pc">&nbsp;                dest.setobj(switch(layer){</b>
<b class="nc">&nbsp;                    case floor -&gt; tile.floor();</b>
<b class="nc">&nbsp;                    case ore -&gt; tile.overlay();</b>
<b class="nc">&nbsp;                    case block -&gt; tile.block();</b>
<b class="nc">&nbsp;                    case building -&gt; tile.build;</b>
&nbsp;                });
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetBlockI implements LInstruction{
&nbsp;        public LVar x, y;
&nbsp;        public LVar block;
&nbsp;        public LVar team, rotation;
<b class="nc">&nbsp;        public TileLayer layer = TileLayer.block;</b>
&nbsp;
<b class="nc">&nbsp;        public SetBlockI(LVar x, LVar y, LVar block, LVar team, LVar rotation, TileLayer layer){</b>
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
<b class="nc">&nbsp;            this.block = block;</b>
<b class="nc">&nbsp;            this.team = team;</b>
<b class="nc">&nbsp;            this.rotation = rotation;</b>
<b class="nc">&nbsp;            this.layer = layer;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetBlockI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(net.client()) return;</b>
&nbsp;
<b class="nc">&nbsp;            Tile tile = world.tile(x.numi(), y.numi());</b>
<b class="nc">&nbsp;            if(tile != null &amp;&amp; block.obj() instanceof Block b){</b>
&nbsp;                //TODO this can be quite laggy...
<b class="nc">&nbsp;                switch(layer){</b>
&nbsp;                    case ore -&gt; {
<b class="nc">&nbsp;                        if((b instanceof OverlayFloor || b == Blocks.air) &amp;&amp; tile.overlay() != b) tile.setOverlayNet(b);</b>
&nbsp;                    }
&nbsp;                    case floor -&gt; {
<b class="nc">&nbsp;                        if(b instanceof Floor f &amp;&amp; tile.floor() != f &amp;&amp; !f.isOverlay() &amp;&amp; !f.isAir()){</b>
<b class="nc">&nbsp;                            tile.setFloorNet(f);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    case block -&gt; {
<b class="nc">&nbsp;                        if(!b.isFloor() || b == Blocks.air){</b>
<b class="nc">&nbsp;                            Team t = team.team();</b>
<b class="nc">&nbsp;                            if(t == null) t = Team.derelict;</b>
&nbsp;
<b class="nc">&nbsp;                            if(tile.block() != b || tile.team() != t){</b>
<b class="nc">&nbsp;                                tile.setNet(b, t, Mathf.clamp(rotation.numi(), 0, 3));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                    //building case not allowed
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SpawnUnitI implements LInstruction{
&nbsp;        public LVar type, x, y, rotation, team, result;
&nbsp;
<b class="fc">&nbsp;        public SpawnUnitI(LVar type, LVar x, LVar y, LVar rotation, LVar team, LVar result){</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.x = x;</b>
<b class="fc">&nbsp;            this.y = y;</b>
<b class="fc">&nbsp;            this.rotation = rotation;</b>
<b class="fc">&nbsp;            this.team = team;</b>
<b class="fc">&nbsp;            this.result = result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SpawnUnitI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(net.client()) return;</b>
&nbsp;
<b class="nc">&nbsp;            Team t = team.team();</b>
&nbsp;
<b class="nc">&nbsp;            if(type.obj() instanceof UnitType type &amp;&amp; !type.internal &amp;&amp; !type.hidden &amp;&amp; t != null &amp;&amp; Units.canCreate(t, type)){</b>
&nbsp;                //random offset to prevent stacking
<b class="nc">&nbsp;                var unit = type.spawn(t, World.unconv(x.numf()) + Mathf.range(0.01f), World.unconv(y.numf()) + Mathf.range(0.01f));</b>
<b class="nc">&nbsp;                spawner.spawnEffect(unit, rotation.numf());</b>
<b class="nc">&nbsp;                result.setobj(unit);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SenseWeatherI implements LInstruction{
&nbsp;        public LVar type, to;
&nbsp;
<b class="nc">&nbsp;        public SenseWeatherI(LVar type, LVar to){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.to = to;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            to.setbool(type.obj() instanceof Weather weather &amp;&amp; weather.isActive());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetWeatherI implements LInstruction{
&nbsp;        public LVar type, state;
&nbsp;
<b class="nc">&nbsp;        public SetWeatherI(LVar type, LVar state){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.state = state;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(type.obj() instanceof Weather weather){</b>
<b class="nc">&nbsp;                if(state.bool()){</b>
<b class="nc">&nbsp;                    if(!weather.isActive()){ //Create is not already active</b>
<b class="nc">&nbsp;                        Tmp.v1.setToRandomDirection();</b>
<b class="nc">&nbsp;                        Call.createWeather(weather, 1f, WeatherState.fadeTime, Tmp.v1.x, Tmp.v1.y);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        weather.instance().life(WeatherState.fadeTime);</b>
&nbsp;                    }
&nbsp;                }else{
<b class="nc">&nbsp;                    if(weather.isActive() &amp;&amp; weather.instance().life &gt; WeatherState.fadeTime){</b>
<b class="nc">&nbsp;                        weather.instance().life(WeatherState.fadeTime);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ApplyEffectI implements LInstruction{
&nbsp;        public boolean clear;
&nbsp;        public String effect;
&nbsp;        public LVar unit, duration;
&nbsp;
<b class="nc">&nbsp;        public ApplyEffectI(boolean clear, String effect, LVar unit, LVar duration){</b>
<b class="nc">&nbsp;            this.clear = clear;</b>
<b class="nc">&nbsp;            this.effect = effect;</b>
<b class="nc">&nbsp;            this.unit = unit;</b>
<b class="nc">&nbsp;            this.duration = duration;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ApplyEffectI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(net.client()) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(unit.obj() instanceof Unit unit &amp;&amp; content.statusEffect(effect) != null){</b>
<b class="nc">&nbsp;                if(clear){</b>
<b class="nc">&nbsp;                    unit.unapply(content.statusEffect(effect));</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    unit.apply(content.statusEffect(effect), duration.numf() * 60f);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetRuleI implements LInstruction{
<b class="fc">&nbsp;        public LogicRule rule = LogicRule.waveSpacing;</b>
&nbsp;        public LVar value, p1, p2, p3, p4;
&nbsp;
<b class="fc">&nbsp;        public SetRuleI(LogicRule rule, LVar value, LVar p1, LVar p2, LVar p3, LVar p4){</b>
<b class="fc">&nbsp;            this.rule = rule;</b>
<b class="fc">&nbsp;            this.value = value;</b>
<b class="fc">&nbsp;            this.p1 = p1;</b>
<b class="fc">&nbsp;            this.p2 = p2;</b>
<b class="fc">&nbsp;            this.p3 = p3;</b>
<b class="fc">&nbsp;            this.p4 = p4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetRuleI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            switch(rule){</b>
<b class="nc">&nbsp;                case waveTimer -&gt; state.rules.waveTimer = value.bool();</b>
<b class="nc">&nbsp;                case wave -&gt; state.wave = Math.max(value.numi(), 1);</b>
<b class="nc">&nbsp;                case currentWaveTime -&gt; state.wavetime = Math.max(value.numf() * 60f, 0f);</b>
<b class="nc">&nbsp;                case waves -&gt; state.rules.waves = value.bool();</b>
<b class="nc">&nbsp;                case waveSending -&gt; state.rules.waveSending = value.bool();</b>
<b class="nc">&nbsp;                case attackMode -&gt; state.rules.attackMode = value.bool();</b>
<b class="nc">&nbsp;                case waveSpacing -&gt; state.rules.waveSpacing = value.numf() * 60f;</b>
<b class="nc">&nbsp;                case enemyCoreBuildRadius -&gt; state.rules.enemyCoreBuildRadius = value.numf() * 8f;</b>
<b class="nc">&nbsp;                case dropZoneRadius -&gt; state.rules.dropZoneRadius = value.numf() * 8f;</b>
<b class="nc">&nbsp;                case unitCap -&gt; state.rules.unitCap = Math.max(value.numi(), 0);</b>
<b class="nc">&nbsp;                case lighting -&gt; state.rules.lighting = value.bool();</b>
&nbsp;                case mapArea -&gt; {
<b class="nc">&nbsp;                    int x = p1.numi(), y = p2.numi(), w = p3.numi(), h = p4.numi();</b>
<b class="nc">&nbsp;                    if(!checkMapArea(x, y, w, h, false)){</b>
<b class="nc">&nbsp;                        Call.setMapArea(x, y, w, h);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                case ambientLight -&gt; state.rules.ambientLight.fromDouble(value.num());</b>
<b class="nc">&nbsp;                case solarMultiplier -&gt; state.rules.solarMultiplier = Math.max(value.numf(), 0f);</b>
<b class="nc">&nbsp;                case dragMultiplier -&gt; state.rules.dragMultiplier = Math.max(value.numf(), 0f);</b>
&nbsp;                case ban -&gt; {
<b class="nc">&nbsp;                    Object cont = value.obj();</b>
<b class="nc">&nbsp;                    if(cont instanceof Block b){</b>
&nbsp;                        // Rebuild PlacementFragment if anything has changed
<b class="nc">&nbsp;                        if(state.rules.bannedBlocks.add(b) &amp;&amp; !headless) ui.hudfrag.blockfrag.rebuild();</b>
<b class="nc">&nbsp;                    }else if(cont instanceof UnitType u){</b>
<b class="nc">&nbsp;                        state.rules.bannedUnits.add(u);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                case unban -&gt; {
<b class="nc">&nbsp;                    Object cont = value.obj();</b>
<b class="nc">&nbsp;                    if(cont instanceof Block b){</b>
<b class="nc">&nbsp;                        if(state.rules.bannedBlocks.remove(b) &amp;&amp; !headless) ui.hudfrag.blockfrag.rebuild();</b>
<b class="nc">&nbsp;                    }else if(cont instanceof UnitType u){</b>
<b class="nc">&nbsp;                        state.rules.bannedUnits.remove(u);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                case unitHealth, unitBuildSpeed, unitCost, unitDamage, blockHealth, blockDamage, buildSpeed, rtsMinSquad, rtsMinWeight -&gt; {
<b class="nc">&nbsp;                    Team team = p1.team();</b>
<b class="nc">&nbsp;                    if(team != null){</b>
<b class="nc">&nbsp;                        float num = value.numf();</b>
<b class="pc">&nbsp;                        switch(rule){</b>
<b class="nc">&nbsp;                            case buildSpeed -&gt; team.rules().buildSpeedMultiplier = Mathf.clamp(num, 0.001f, 50f);</b>
<b class="nc">&nbsp;                            case unitHealth -&gt; team.rules().unitHealthMultiplier = Math.max(num, 0.001f);</b>
<b class="nc">&nbsp;                            case unitBuildSpeed -&gt; team.rules().unitBuildSpeedMultiplier = Mathf.clamp(num, 0f, 50f);</b>
<b class="nc">&nbsp;                            case unitCost -&gt; team.rules().unitCostMultiplier = Math.max(num, 0f);</b>
<b class="nc">&nbsp;                            case unitDamage -&gt; team.rules().unitDamageMultiplier = Math.max(num, 0f);</b>
<b class="nc">&nbsp;                            case blockHealth -&gt; team.rules().blockHealthMultiplier = Math.max(num, 0.001f);</b>
<b class="nc">&nbsp;                            case blockDamage -&gt; team.rules().blockDamageMultiplier = Math.max(num, 0f);</b>
<b class="nc">&nbsp;                            case rtsMinWeight -&gt; team.rules().rtsMinWeight = num;</b>
<b class="nc">&nbsp;                            case rtsMinSquad -&gt; team.rules().rtsMinSquad = (int)num;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @return whether the map area is already set to this value. */
&nbsp;    static boolean checkMapArea(int x, int y, int w, int h, boolean set){
<b class="nc">&nbsp;        x = Math.max(x, 0);</b>
<b class="nc">&nbsp;        y = Math.max(y, 0);</b>
<b class="nc">&nbsp;        w = Math.min(world.width(), w);</b>
<b class="nc">&nbsp;        h = Math.min(world.height(), h);</b>
<b class="nc">&nbsp;        boolean full = x == 0 &amp;&amp; y == 0 &amp;&amp; w == world.width() &amp;&amp; h == world.height();</b>
&nbsp;
<b class="nc">&nbsp;        if(state.rules.limitMapArea){</b>
<b class="nc">&nbsp;            if(state.rules.limitX == x &amp;&amp; state.rules.limitY == y &amp;&amp; state.rules.limitWidth == w &amp;&amp; state.rules.limitHeight == h){</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            }else if(full){</b>
&nbsp;                //disable the rule, covers the whole map
<b class="nc">&nbsp;                if(set){</b>
<b class="nc">&nbsp;                    state.rules.limitMapArea = false;</b>
<b class="nc">&nbsp;                    if(!headless){</b>
<b class="nc">&nbsp;                        renderer.updateAllDarkness();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    world.checkMapArea();</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }else if(full){ //was already disabled, no need to change anything</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if(set){</b>
<b class="nc">&nbsp;            state.rules.limitMapArea = true;</b>
<b class="nc">&nbsp;            state.rules.limitX = x;</b>
<b class="nc">&nbsp;            state.rules.limitY = y;</b>
<b class="nc">&nbsp;            state.rules.limitWidth = w;</b>
<b class="nc">&nbsp;            state.rules.limitHeight = h;</b>
<b class="nc">&nbsp;            world.checkMapArea();</b>
&nbsp;
<b class="nc">&nbsp;            if(!headless){</b>
<b class="nc">&nbsp;                renderer.updateAllDarkness();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server)
&nbsp;    public static void setMapArea(int x, int y, int w, int h){
<b class="nc">&nbsp;        checkMapArea(x, y, w, h, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class FlushMessageI implements LInstruction{
<b class="fc">&nbsp;        public MessageType type = MessageType.announce;</b>
&nbsp;        public LVar duration, outSuccess;
&nbsp;
<b class="fc">&nbsp;        public FlushMessageI(MessageType type, LVar duration, LVar outSuccess){</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.duration = duration;</b>
<b class="fc">&nbsp;            this.outSuccess = outSuccess;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public FlushMessageI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;            //set default to success
<b class="nc">&nbsp;            outSuccess.setnum(1);</b>
<b class="nc">&nbsp;            if(headless &amp;&amp; type != MessageType.mission){</b>
<b class="nc">&nbsp;                exec.textBuffer.setLength(0);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(</b>
<b class="nc">&nbsp;                type == MessageType.announce &amp;&amp; ui.hasAnnouncement() ||</b>
<b class="nc">&nbsp;                type == MessageType.notify &amp;&amp; ui.hudfrag.hasToast() ||</b>
<b class="nc">&nbsp;                type == MessageType.toast &amp;&amp; ui.hasAnnouncement()</b>
&nbsp;            ){
&nbsp;                //backwards compatibility; if it is @wait, block execution
<b class="nc">&nbsp;                if(outSuccess == logicVars.waitVar()){</b>
<b class="nc">&nbsp;                    exec.counter.numval--;</b>
<b class="nc">&nbsp;                    exec.yield = true;</b>
&nbsp;                }else{
&nbsp;                    //set outSuccess=false to let user retry.
<b class="nc">&nbsp;                    outSuccess.setnum(0);</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String text = exec.textBuffer.toString();</b>
<b class="nc">&nbsp;            if(text.startsWith(&quot;@&quot;)){</b>
<b class="nc">&nbsp;                String substr = text.substring(1);</b>
<b class="nc">&nbsp;                if(Core.bundle.has(substr)){</b>
<b class="nc">&nbsp;                    text = Core.bundle.get(substr);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="pc">&nbsp;            switch(type){</b>
<b class="nc">&nbsp;                case notify -&gt; ui.hudfrag.showToast(Icon.info, text);</b>
<b class="nc">&nbsp;                case announce -&gt; ui.announce(text, duration.numf());</b>
<b class="nc">&nbsp;                case toast -&gt; ui.showInfoToast(text, duration.numf());</b>
&nbsp;                //TODO desync?
<b class="nc">&nbsp;                case mission -&gt; state.rules.mission = text;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            exec.textBuffer.setLength(0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class EffectI implements LInstruction{
&nbsp;        public EffectEntry type;
&nbsp;        public LVar x, y, rotation, color, data;
&nbsp;
<b class="fc">&nbsp;        public EffectI(EffectEntry type, LVar x, LVar y, LVar rotation, LVar color, LVar data){</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.x = x;</b>
<b class="fc">&nbsp;            this.y = y;</b>
<b class="fc">&nbsp;            this.rotation = rotation;</b>
<b class="fc">&nbsp;            this.color = color;</b>
<b class="fc">&nbsp;            this.data = data;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public EffectI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(type != null){</b>
<b class="nc">&nbsp;                double col = color.num();</b>
&nbsp;                //limit size so people don&#39;t create lag with ridiculous numbers (some explosions scale with size)
<b class="nc">&nbsp;                float rot = type.rotate ? rotation.numf() :</b>
<b class="nc">&nbsp;                    Math.min(rotation.numf(), 1000f);</b>
&nbsp;
<b class="nc">&nbsp;                type.effect.at(World.unconv(x.numf()), World.unconv(y.numf()), rot, Tmp.c1.fromDouble(col), data.obj());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ExplosionI implements LInstruction{
&nbsp;        public LVar team, x, y, radius, damage, air, ground, pierce, effect;
&nbsp;
<b class="fc">&nbsp;        public ExplosionI(LVar team, LVar x, LVar y, LVar radius, LVar damage, LVar air, LVar ground, LVar pierce, LVar effect){</b>
<b class="fc">&nbsp;            this.team = team;</b>
<b class="fc">&nbsp;            this.x = x;</b>
<b class="fc">&nbsp;            this.y = y;</b>
<b class="fc">&nbsp;            this.radius = radius;</b>
<b class="fc">&nbsp;            this.damage = damage;</b>
<b class="fc">&nbsp;            this.air = air;</b>
<b class="fc">&nbsp;            this.ground = ground;</b>
<b class="fc">&nbsp;            this.pierce = pierce;</b>
<b class="fc">&nbsp;            this.effect = effect;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ExplosionI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(net.client()) return;</b>
&nbsp;
<b class="nc">&nbsp;            Team t = team.team();</b>
&nbsp;            //note that there is a radius cap
<b class="nc">&nbsp;            Call.logicExplosion(t, World.unconv(x.numf()), World.unconv(y.numf()), World.unconv(Math.min(radius.numf(), 100)), damage.numf(), air.bool(), ground.bool(), pierce.bool(), effect.bool());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, unreliable = true)
&nbsp;    public static void logicExplosion(Team team, float x, float y, float radius, float damage, boolean air, boolean ground, boolean pierce, boolean effect){
<b class="nc">&nbsp;        if(damage &lt; 0f) return;</b>
&nbsp;
<b class="nc">&nbsp;        Damage.damage(team, x, y, radius, damage, pierce, air, ground);</b>
<b class="nc">&nbsp;        if(effect){</b>
<b class="nc">&nbsp;            if(pierce){</b>
<b class="nc">&nbsp;                Fx.spawnShockwave.at(x, y, World.conv(radius));</b>
&nbsp;            }else{
<b class="nc">&nbsp;                Fx.dynamicExplosion.at(x, y, World.conv(radius) / 8f);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetRateI implements LInstruction{
&nbsp;        public LVar amount;
&nbsp;
<b class="nc">&nbsp;        public SetRateI(LVar amount){</b>
<b class="nc">&nbsp;            this.amount = amount;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetRateI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            exec.build.ipt = Mathf.clamp(amount.numi(), 1, ((LogicBlock)exec.build.block).maxInstructionsPerTick);</b>
<b class="nc">&nbsp;            if(exec.ipt != null){</b>
<b class="nc">&nbsp;                exec.ipt.numval = exec.build.ipt;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(unreliable = true)
&nbsp;    public static void syncVariable(Building building, int variable, Object value){
<b class="nc">&nbsp;        if(building instanceof LogicBuild build){</b>
<b class="nc">&nbsp;            LVar v = build.executor.optionalVar(variable);</b>
<b class="nc">&nbsp;            if(v != null &amp;&amp; !v.constant){</b>
<b class="nc">&nbsp;                if(value instanceof Number n){</b>
<b class="nc">&nbsp;                    v.isobj = false;</b>
<b class="nc">&nbsp;                    v.numval = n.doubleValue();</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    v.isobj = true;</b>
<b class="nc">&nbsp;                    v.objval = value;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SyncI implements LInstruction{
&nbsp;        //20 syncs per second
<b class="nc">&nbsp;        public static long syncInterval = 1000 / 20;</b>
&nbsp;
&nbsp;        public LVar variable;
&nbsp;
<b class="nc">&nbsp;        public SyncI(LVar variable){</b>
<b class="nc">&nbsp;            this.variable = variable;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SyncI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(!variable.constant &amp;&amp; Time.timeSinceMillis(variable.syncTime) &gt; syncInterval){</b>
<b class="nc">&nbsp;                variable.syncTime = Time.millis();</b>
<b class="nc">&nbsp;                Call.syncVariable(exec.build, variable.id, variable.isobj ? variable.objval : variable.numval);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ClientDataI implements LInstruction{
&nbsp;        public LVar channel, value, reliable;
&nbsp;
<b class="nc">&nbsp;        public ClientDataI(LVar channel, LVar value, LVar reliable){</b>
<b class="nc">&nbsp;            this.channel = channel;</b>
<b class="nc">&nbsp;            this.value = value;</b>
<b class="nc">&nbsp;            this.reliable = reliable;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ClientDataI() {</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec) {
<b class="nc">&nbsp;            if(channel.obj() instanceof String c){</b>
<b class="nc">&nbsp;                Object v = value.isobj ? value.objval : value.numval;</b>
<b class="nc">&nbsp;                if(reliable.bool()){</b>
<b class="nc">&nbsp;                    Call.clientLogicDataReliable(c, v);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    Call.clientLogicDataUnreliable(c, v);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class GetFlagI implements LInstruction{
&nbsp;        public LVar result, flag;
&nbsp;
<b class="fc">&nbsp;        public GetFlagI(LVar result, LVar flag){</b>
<b class="fc">&nbsp;            this.result = result;</b>
<b class="fc">&nbsp;            this.flag = flag;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public GetFlagI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="fc">&nbsp;            if(flag.obj() instanceof String str){</b>
<b class="fc">&nbsp;                result.setbool(state.rules.objectiveFlags.contains(str));</b>
&nbsp;            }else{
<b class="nc">&nbsp;                result.setobj(null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server)
&nbsp;    public static void setFlag(String flag, boolean add){
<b class="nc">&nbsp;        if(add){</b>
<b class="nc">&nbsp;            state.rules.objectiveFlags.add(flag);</b>
&nbsp;        }else{
<b class="nc">&nbsp;            state.rules.objectiveFlags.remove(flag);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetFlagI implements LInstruction{
&nbsp;        public LVar flag, value;
&nbsp;
<b class="fc">&nbsp;        public SetFlagI(LVar flag, LVar value){</b>
<b class="fc">&nbsp;            this.flag = flag;</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetFlagI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
&nbsp;            //don&#39;t invoke unless the flag state actually changes
<b class="nc">&nbsp;            if(flag.obj() instanceof String str &amp;&amp; state.rules.objectiveFlags.contains(str) != value.bool()){</b>
<b class="nc">&nbsp;                Call.setFlag(str, value.bool());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SpawnWaveI implements LInstruction{
&nbsp;        public LVar natural;
&nbsp;        public LVar x, y;
&nbsp;
<b class="nc">&nbsp;        public SpawnWaveI(){</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public SpawnWaveI(LVar natural, LVar x, LVar y){</b>
<b class="fc">&nbsp;            this.natural = natural;</b>
<b class="fc">&nbsp;            this.x = x;</b>
<b class="fc">&nbsp;            this.y = y;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(net.client()) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(natural.bool()){</b>
<b class="nc">&nbsp;                logic.skipWave();</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            float
<b class="nc">&nbsp;                spawnX = World.unconv(x.numf()),</b>
<b class="nc">&nbsp;                spawnY = World.unconv(y.numf());</b>
<b class="nc">&nbsp;            int packed = Point2.pack(x.numi(), y.numi());</b>
&nbsp;
<b class="nc">&nbsp;            for(SpawnGroup group : state.rules.spawns){</b>
<b class="nc">&nbsp;                if(group.type == null || (group.spawn != -1 &amp;&amp; group.spawn != packed)) continue;</b>
&nbsp;
<b class="nc">&nbsp;                int spawned = group.getSpawned(state.wave - 1);</b>
<b class="nc">&nbsp;                float spread = tilesize * 2;</b>
&nbsp;
<b class="nc">&nbsp;                for(int i = 0; i &lt; spawned; i++){</b>
<b class="nc">&nbsp;                    Tmp.v1.rnd(spread);</b>
&nbsp;
<b class="nc">&nbsp;                    Unit unit = group.createUnit(state.rules.waveTeam, state.wave - 1);</b>
<b class="nc">&nbsp;                    unit.set(spawnX + Tmp.v1.x, spawnY + Tmp.v1.y);</b>
<b class="nc">&nbsp;                    Vars.spawner.spawnEffect(unit);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetPropI implements LInstruction{
&nbsp;        public LVar type, of, value;
&nbsp;
<b class="nc">&nbsp;        public SetPropI(LVar type, LVar of, LVar value){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.of = of;</b>
<b class="nc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetPropI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(of.obj() instanceof Settable sp){</b>
<b class="nc">&nbsp;                Object key = type.obj();</b>
<b class="nc">&nbsp;                if(key instanceof LAccess property){</b>
<b class="nc">&nbsp;                    if(value.isobj){</b>
<b class="nc">&nbsp;                        sp.setProp(property, value.objval);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        sp.setProp(property, value.numval);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }else if(key instanceof UnlockableContent content){</b>
<b class="nc">&nbsp;                    sp.setProp(content, value.num());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class PlaySoundI implements LInstruction{
&nbsp;        public boolean positional;
&nbsp;        public LVar id, volume, pitch, pan, x, y, limit;
&nbsp;
<b class="nc">&nbsp;        public PlaySoundI(){</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PlaySoundI(boolean positional, LVar id, LVar volume, LVar pitch, LVar pan, LVar x, LVar y, LVar limit){</b>
<b class="nc">&nbsp;            this.positional = positional;</b>
<b class="nc">&nbsp;            this.id = id;</b>
<b class="nc">&nbsp;            this.volume = volume;</b>
<b class="nc">&nbsp;            this.pitch = pitch;</b>
<b class="nc">&nbsp;            this.pan = pan;</b>
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
<b class="nc">&nbsp;            this.limit = limit;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            Sound sound = Sounds.getSound(id.numi());</b>
<b class="nc">&nbsp;            if(sound == null || sound == Sounds.swish) sound = Sounds.none; //no.</b>
&nbsp;            
<b class="nc">&nbsp;            if(positional){</b>
<b class="nc">&nbsp;                sound.at(World.unconv(x.numf()), World.unconv(y.numf()), pitch.numf(), Math.min(volume.numf(), 2f), limit.bool());</b>
&nbsp;            }else{
<b class="nc">&nbsp;                sound.play(Math.min(volume.numf() * (Core.settings.getInt(&quot;sfxvol&quot;) / 100f), 2f), pitch.numf(), pan.numf(), false, limit.bool());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SetMarkerI implements LInstruction{
<b class="nc">&nbsp;        public LMarkerControl type = LMarkerControl.pos;</b>
&nbsp;        public LVar id, p1, p2, p3;
&nbsp;
<b class="nc">&nbsp;        public SetMarkerI(LMarkerControl type, LVar id, LVar p1, LVar p2, LVar p3){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.id = id;</b>
<b class="nc">&nbsp;            this.p1 = p1;</b>
<b class="nc">&nbsp;            this.p2 = p2;</b>
<b class="nc">&nbsp;            this.p3 = p3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SetMarkerI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(type == LMarkerControl.remove){</b>
<b class="nc">&nbsp;                state.markers.remove(id.numi());</b>
&nbsp;            }else{
<b class="nc">&nbsp;                var marker = state.markers.get(id.numi());</b>
<b class="nc">&nbsp;                if(marker == null) return;</b>
&nbsp;
<b class="nc">&nbsp;                if(type == LMarkerControl.flushText){</b>
<b class="nc">&nbsp;                    marker.setText(exec.textBuffer.toString(), p1.bool());</b>
<b class="nc">&nbsp;                    exec.textBuffer.setLength(0);</b>
<b class="nc">&nbsp;                }else if(type == LMarkerControl.texture){</b>
<b class="nc">&nbsp;                    if(p1.bool()){</b>
<b class="nc">&nbsp;                        marker.setTexture(exec.textBuffer.toString());</b>
<b class="nc">&nbsp;                        exec.textBuffer.setLength(0);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        marker.setTexture(PrintI.toString(p2.obj()));</b>
&nbsp;                    }
&nbsp;                }else{
<b class="nc">&nbsp;                    marker.control(type, p1.numOrNan(), p2.numOrNan(), p3.numOrNan());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class MakeMarkerI implements LInstruction{
&nbsp;        //TODO arbitrary number
&nbsp;        public static final int maxMarkers = 20000;
&nbsp;
<b class="nc">&nbsp;        public String type = &quot;shape&quot;;</b>
&nbsp;        public LVar id, x, y, replace;
&nbsp;
<b class="nc">&nbsp;        public MakeMarkerI(String type, LVar id, LVar x, LVar y, LVar replace){</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.id = id;</b>
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
<b class="nc">&nbsp;            this.replace = replace;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public MakeMarkerI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            var cons = MapObjectives.markerNameToType.get(type);</b>
&nbsp;
<b class="nc">&nbsp;            if(cons != null &amp;&amp; state.markers.size() &lt; maxMarkers){</b>
<b class="nc">&nbsp;                int mid = id.numi();</b>
<b class="nc">&nbsp;                if(replace.bool() || !state.markers.has(mid)){</b>
<b class="nc">&nbsp;                    var marker = cons.get();</b>
<b class="nc">&nbsp;                    marker.control(LMarkerControl.pos, x.num(), y.num(), 0);</b>
<b class="nc">&nbsp;                    state.markers.add(mid, marker);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, variants = Variant.both, unreliable = true)
&nbsp;    public static void createMarker(int id, ObjectiveMarker marker){
<b class="nc">&nbsp;        state.markers.add(id, marker);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, variants = Variant.both, unreliable = true)
&nbsp;    public static void removeMarker(int id){
<b class="nc">&nbsp;        state.markers.remove(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, variants = Variant.both, unreliable = true)
&nbsp;    public static void updateMarker(int id, LMarkerControl control, double p1, double p2, double p3){
<b class="nc">&nbsp;        var marker = state.markers.get(id);</b>
<b class="nc">&nbsp;        if(marker != null){</b>
<b class="nc">&nbsp;            marker.control(control, p1, p2, p3);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, variants = Variant.both, unreliable = true)
&nbsp;    public static void updateMarkerText(int id, LMarkerControl type, boolean fetch, String text){
<b class="nc">&nbsp;        var marker = state.markers.get(id);</b>
<b class="nc">&nbsp;        if(marker != null){</b>
<b class="nc">&nbsp;            if(type == LMarkerControl.flushText){</b>
<b class="nc">&nbsp;                marker.setText(text, fetch);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server, variants = Variant.both, unreliable = true)
&nbsp;    public static void updateMarkerTexture(int id, String textureName){
<b class="nc">&nbsp;        var marker = state.markers.get(id);</b>
<b class="nc">&nbsp;        if(marker != null){</b>
<b class="nc">&nbsp;            marker.setTexture(textureName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class LocalePrintI implements LInstruction{
&nbsp;        public LVar name;
&nbsp;
<b class="nc">&nbsp;        public LocalePrintI(LVar name){</b>
<b class="nc">&nbsp;            this.name = name;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public LocalePrintI(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run(LExecutor exec){
<b class="nc">&nbsp;            if(exec.textBuffer.length() &gt;= maxTextBuffer) return;</b>
&nbsp;
&nbsp;            //this should avoid any garbage allocation
<b class="nc">&nbsp;            if(name.isobj){</b>
<b class="nc">&nbsp;                String name = PrintI.toString(this.name.objval);</b>
&nbsp;
&nbsp;                String strValue;
&nbsp;
<b class="nc">&nbsp;                if(mobile){</b>
<b class="nc">&nbsp;                    strValue = state.mapLocales.containsProperty(name + &quot;.mobile&quot;) ?</b>
<b class="nc">&nbsp;                    state.mapLocales.getProperty(name + &quot;.mobile&quot;) :</b>
<b class="nc">&nbsp;                    state.mapLocales.getProperty(name);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    strValue = state.mapLocales.getProperty(name);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                exec.textBuffer.append(strValue);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //endregion
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 15:58</div>
</div>
</body>
</html>
