


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > EntityProcess</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">mindustry.annotations.entity</a>
</div>

<h1>Coverage Summary for Class: EntityProcess (mindustry.annotations.entity)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EntityProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/509)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EntityProcess$EntityDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EntityProcess$GroupDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/528)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package mindustry.annotations.entity;
&nbsp;
&nbsp;import arc.files.*;
&nbsp;import arc.func.*;
&nbsp;import arc.struct.*;
&nbsp;import arc.util.*;
&nbsp;import arc.util.io.*;
&nbsp;import arc.util.pooling.Pool.*;
&nbsp;import arc.util.pooling.*;
&nbsp;import com.squareup.javapoet.*;
&nbsp;import com.squareup.javapoet.TypeSpec.*;
&nbsp;import com.sun.source.tree.*;
&nbsp;import mindustry.annotations.Annotations.*;
&nbsp;import mindustry.annotations.*;
&nbsp;import mindustry.annotations.util.*;
&nbsp;import mindustry.annotations.util.TypeIOResolver.*;
&nbsp;
&nbsp;import javax.annotation.processing.*;
&nbsp;import javax.lang.model.element.*;
&nbsp;import javax.lang.model.type.*;
&nbsp;import java.lang.annotation.*;
&nbsp;
&nbsp;@SupportedAnnotationTypes({
&nbsp;&quot;mindustry.annotations.Annotations.EntityDef&quot;,
&nbsp;&quot;mindustry.annotations.Annotations.GroupDef&quot;,
&nbsp;&quot;mindustry.annotations.Annotations.EntityInterface&quot;,
&nbsp;&quot;mindustry.annotations.Annotations.BaseComponent&quot;,
&nbsp;&quot;mindustry.annotations.Annotations.TypeIOHandler&quot;
&nbsp;})
<b class="nc">&nbsp;public class EntityProcess extends BaseProcessor{</b>
<b class="nc">&nbsp;    Seq&lt;EntityDefinition&gt; definitions = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;    Seq&lt;GroupDefinition&gt; groupDefs = new Seq&lt;&gt;();</b>
&nbsp;    Seq&lt;Stype&gt; baseComponents;
<b class="nc">&nbsp;    ObjectMap&lt;String, Stype&gt; componentNames = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectMap&lt;Stype, Seq&lt;Stype&gt;&gt; componentDependencies = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectMap&lt;Selement, Seq&lt;Stype&gt;&gt; defComponents = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectMap&lt;String, String&gt; varInitializers = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectMap&lt;String, String&gt; methodBlocks = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectMap&lt;Stype, ObjectSet&lt;Stype&gt;&gt; baseClassDeps = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectSet&lt;String&gt; imports = new ObjectSet&lt;&gt;();</b>
<b class="nc">&nbsp;    Seq&lt;Selement&gt; allGroups = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;    Seq&lt;Selement&gt; allDefs = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;    Seq&lt;Stype&gt; allInterfaces = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;    Seq&lt;TypeSpec.Builder&gt; baseClasses = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;    ObjectSet&lt;TypeSpec.Builder&gt; baseClassIndexers = new ObjectSet&lt;&gt;();</b>
&nbsp;    ClassSerializer serializer;
&nbsp;
&nbsp;    {
<b class="nc">&nbsp;        rounds = 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(RoundEnvironment env) throws Exception{
<b class="nc">&nbsp;        allGroups.addAll(elements(GroupDef.class));</b>
<b class="nc">&nbsp;        allDefs.addAll(elements(EntityDef.class));</b>
<b class="nc">&nbsp;        allInterfaces.addAll(types(EntityInterface.class));</b>
&nbsp;
&nbsp;        //round 1: generate component interfaces
<b class="nc">&nbsp;        if(round == 1){</b>
<b class="nc">&nbsp;            serializer = TypeIOResolver.resolve(this);</b>
<b class="nc">&nbsp;            baseComponents = types(BaseComponent.class);</b>
<b class="nc">&nbsp;            Seq&lt;Stype&gt; allComponents = types(Component.class);</b>
&nbsp;
&nbsp;            //store code
<b class="nc">&nbsp;            for(Stype component : allComponents){</b>
<b class="nc">&nbsp;                for(Svar f : component.fields()){</b>
<b class="nc">&nbsp;                    VariableTree tree = f.tree();</b>
&nbsp;
&nbsp;                    //add initializer if it exists
<b class="nc">&nbsp;                    if(tree.getInitializer() != null){</b>
<b class="nc">&nbsp;                        String init = tree.getInitializer().toString();</b>
<b class="nc">&nbsp;                        varInitializers.put(f.descString(), init);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                for(Smethod elem : component.methods()){</b>
<b class="nc">&nbsp;                    if(elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE)) continue;</b>
&nbsp;                    //get all statements in the method, store them
<b class="nc">&nbsp;                    methodBlocks.put(elem.descString(), elem.tree().getBody().toString()</b>
<b class="nc">&nbsp;                        .replaceAll(&quot;this\\.&lt;(.*)&gt;self\\(\\)&quot;, &quot;this&quot;) //fix parameterized self() calls</b>
<b class="nc">&nbsp;                        .replaceAll(&quot;self\\(\\)&quot;, &quot;this&quot;) //fix self() calls</b>
<b class="nc">&nbsp;                        .replaceAll(&quot; yield &quot;, &quot;&quot;) //fix enchanced switch</b>
<b class="nc">&nbsp;                        .replaceAll(&quot;\\/\\*missing\\*\\/&quot;, &quot;var&quot;) //fix vars</b>
&nbsp;                    );
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //store components
<b class="nc">&nbsp;            for(Stype type : allComponents){</b>
<b class="nc">&nbsp;                componentNames.put(type.name(), type);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //add component imports
<b class="nc">&nbsp;            for(Stype comp : allComponents){</b>
<b class="nc">&nbsp;                imports.addAll(getImports(comp.e));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //create component interfaces
<b class="nc">&nbsp;            for(Stype component : allComponents){</b>
<b class="nc">&nbsp;                TypeSpec.Builder inter = TypeSpec.interfaceBuilder(interfaceName(component))</b>
<b class="nc">&nbsp;                .addModifiers(Modifier.PUBLIC).addAnnotation(EntityInterface.class);</b>
&nbsp;
<b class="nc">&nbsp;                inter.addJavadoc(&quot;Interface for {@link $L}&quot;, component.fullName());</b>
&nbsp;
<b class="nc">&nbsp;                skipDeprecated(inter);</b>
&nbsp;
&nbsp;                //implement extra interfaces these components may have, e.g. position
<b class="nc">&nbsp;                for(Stype extraInterface : component.interfaces().select(i -&gt; !isCompInterface(i))){</b>
&nbsp;                    //javapoet completely chokes on this if I add `addSuperInterface` or create the type name with TypeName.get
<b class="nc">&nbsp;                    inter.superinterfaces.add(tname(extraInterface.fullName()));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                //implement super interfaces
<b class="nc">&nbsp;                Seq&lt;Stype&gt; depends = getDependencies(component);</b>
<b class="nc">&nbsp;                for(Stype type : depends){</b>
<b class="nc">&nbsp;                    inter.addSuperinterface(ClassName.get(packageName, interfaceName(type)));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                ObjectSet&lt;String&gt; signatures = new ObjectSet&lt;&gt;();</b>
&nbsp;
&nbsp;                //add utility methods to interface
<b class="nc">&nbsp;                for(Smethod method : component.methods()){</b>
&nbsp;                    //skip private methods, those are for internal use.
<b class="nc">&nbsp;                    if(method.isAny(Modifier.PRIVATE, Modifier.STATIC)) continue;</b>
&nbsp;
&nbsp;                    //keep track of signatures used to prevent dupes
<b class="nc">&nbsp;                    signatures.add(method.e.toString());</b>
&nbsp;
<b class="nc">&nbsp;                    inter.addMethod(MethodSpec.methodBuilder(method.name())</b>
<b class="nc">&nbsp;                    .addJavadoc(method.doc() == null ? &quot;&quot; : method.doc())</b>
<b class="nc">&nbsp;                    .addExceptions(method.thrownt())</b>
<b class="nc">&nbsp;                    .addTypeVariables(method.typeVariables().map(TypeVariableName::get))</b>
<b class="nc">&nbsp;                    .returns(method.ret().toString().equals(&quot;void&quot;) ? TypeName.VOID : method.retn())</b>
<b class="nc">&nbsp;                    .addParameters(method.params().map(v -&gt; ParameterSpec.builder(v.tname(), v.name())</b>
<b class="nc">&nbsp;                    .build())).addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT).build());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                //generate interface getters and setters for all &quot;standard&quot; fields
<b class="nc">&nbsp;                for(Svar field : component.fields().select(e -&gt; !e.is(Modifier.STATIC) &amp;&amp; !e.is(Modifier.PRIVATE) &amp;&amp; !e.has(Import.class))){</b>
<b class="nc">&nbsp;                    String cname = field.name();</b>
&nbsp;
&nbsp;                    //getter
<b class="nc">&nbsp;                    if(!signatures.contains(cname + &quot;()&quot;)){</b>
<b class="nc">&nbsp;                        inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT, Modifier.PUBLIC)</b>
<b class="nc">&nbsp;                        .addAnnotations(Seq.with(field.annotations()).select(a -&gt; a.toString().contains(&quot;Null&quot;) || a.toString().contains(&quot;Deprecated&quot;)).map(AnnotationSpec::get))</b>
<b class="nc">&nbsp;                        .addJavadoc(field.doc() == null ? &quot;&quot; : field.doc())</b>
<b class="nc">&nbsp;                        .returns(field.tname()).build());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //setter
<b class="nc">&nbsp;                    if(!field.is(Modifier.FINAL) &amp;&amp; !signatures.contains(cname + &quot;(&quot; + field.mirror().toString() + &quot;)&quot;) &amp;&amp;</b>
<b class="nc">&nbsp;                    !field.annotations().contains(f -&gt; f.toString().equals(&quot;@mindustry.annotations.Annotations.ReadOnly&quot;))){</b>
<b class="nc">&nbsp;                        inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT, Modifier.PUBLIC)</b>
<b class="nc">&nbsp;                        .addJavadoc(field.doc() == null ? &quot;&quot; : field.doc())</b>
<b class="nc">&nbsp;                        .addParameter(ParameterSpec.builder(field.tname(), field.name())</b>
<b class="nc">&nbsp;                        .addAnnotations(Seq.with(field.annotations())</b>
<b class="nc">&nbsp;                        .select(a -&gt; a.toString().contains(&quot;Null&quot;) || a.toString().contains(&quot;Deprecated&quot;)).map(AnnotationSpec::get)).build()).build());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                write(inter);</b>
&nbsp;
&nbsp;                //generate base class if necessary
&nbsp;                //SPECIAL CASE: components with EntityDefs don&#39;t get a base class! the generated class becomes the base class itself
<b class="nc">&nbsp;                if(component.annotation(Component.class).base()){</b>
&nbsp;
<b class="nc">&nbsp;                    Seq&lt;Stype&gt; deps = depends.copy().add(component);</b>
<b class="nc">&nbsp;                    baseClassDeps.get(component, ObjectSet::new).addAll(deps);</b>
&nbsp;
&nbsp;                    //do not generate base classes when the component will generate one itself
<b class="nc">&nbsp;                    if(!component.has(EntityDef.class)){</b>
<b class="nc">&nbsp;                        TypeSpec.Builder base = TypeSpec.classBuilder(baseName(component)).addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);</b>
&nbsp;
&nbsp;                        //go through all the fields.
<b class="nc">&nbsp;                        for(Stype type : deps){</b>
&nbsp;                            //add public fields
<b class="nc">&nbsp;                            for(Svar field : type.fields().select(e -&gt; !e.is(Modifier.STATIC) &amp;&amp; !e.is(Modifier.PRIVATE) &amp;&amp; !e.has(Import.class) &amp;&amp; !e.has(ReadOnly.class))){</b>
<b class="nc">&nbsp;                                FieldSpec.Builder builder = FieldSpec.builder(field.tname(),field.name(), Modifier.PUBLIC);</b>
&nbsp;
&nbsp;                                //keep transience
<b class="nc">&nbsp;                                if(field.is(Modifier.TRANSIENT)) builder.addModifiers(Modifier.TRANSIENT);</b>
&nbsp;                                //keep all annotations
<b class="nc">&nbsp;                                builder.addAnnotations(field.annotations().map(AnnotationSpec::get));</b>
&nbsp;
&nbsp;                                //add initializer if it exists
<b class="nc">&nbsp;                                if(varInitializers.containsKey(field.descString())){</b>
<b class="nc">&nbsp;                                    builder.initializer(varInitializers.get(field.descString()));</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                base.addField(builder.build());</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        //add interfaces
<b class="nc">&nbsp;                        for(Stype type : deps){</b>
<b class="nc">&nbsp;                            base.addSuperinterface(tname(packageName, interfaceName(type)));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        //add to queue to be written later
<b class="nc">&nbsp;                        baseClasses.add(base);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //LOGGING
&nbsp;
<b class="nc">&nbsp;                Log.debug(&quot;&amp;gGenerating interface for &quot; + component.name());</b>
&nbsp;
<b class="nc">&nbsp;                for(TypeName tn : inter.superinterfaces){</b>
<b class="nc">&nbsp;                    Log.debug(&quot;&amp;g&gt; &amp;lbimplements @&quot;, simpleName(tn.toString()));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                //log methods generated
<b class="nc">&nbsp;                for(MethodSpec spec : inter.methodSpecs){</b>
<b class="nc">&nbsp;                    Log.debug(&quot;&amp;g&gt; &gt; &amp;c@ @(@)&quot;, simpleName(spec.returnType.toString()), spec.name, Seq.with(spec.parameters).toString(&quot;, &quot;, p -&gt; simpleName(p.type.toString()) + &quot; &quot; + p.name));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                Log.debug(&quot;&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;        }else if(round == 2){ //round 2: get component classes and generate interfaces for them</b>
&nbsp;
&nbsp;            //parse groups
&nbsp;            //this needs to be done before the entity interfaces are generated, as the entity classes need to know which groups to add themselves to
<b class="nc">&nbsp;            for(Selement&lt;?&gt; group : allGroups){</b>
<b class="nc">&nbsp;                GroupDef an = group.annotation(GroupDef.class);</b>
<b class="nc">&nbsp;                Seq&lt;Stype&gt; types = types(an, GroupDef::value).map(stype -&gt; {</b>
<b class="nc">&nbsp;                    Stype result = interfaceToComp(stype);</b>
<b class="nc">&nbsp;                    if(result == null) throw new IllegalArgumentException(&quot;Interface &quot; + stype + &quot; does not have an associated component!&quot;);</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                });
&nbsp;
&nbsp;                //representative component type
<b class="nc">&nbsp;                Stype repr = types.first();</b>
<b class="nc">&nbsp;                String groupType = repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);</b>
&nbsp;
<b class="nc">&nbsp;                String name = group.name().startsWith(&quot;g&quot;) ? group.name().substring(1) : group.name();</b>
&nbsp;
<b class="nc">&nbsp;                boolean collides = an.collide();</b>
<b class="nc">&nbsp;                groupDefs.add(new GroupDefinition(name,</b>
<b class="nc">&nbsp;                    ClassName.bestGuess(packageName + &quot;.&quot; + groupType), types, an.spatial(), an.mapping(), collides));</b>
&nbsp;
<b class="nc">&nbsp;                TypeSpec.Builder accessor = TypeSpec.interfaceBuilder(&quot;IndexableEntity__&quot; + name);</b>
<b class="nc">&nbsp;                accessor.addMethod(MethodSpec.methodBuilder(&quot;setIndex__&quot; + name).addModifiers(Modifier.ABSTRACT, Modifier.PUBLIC).addParameter(int.class, &quot;index&quot;).returns(void.class).build());</b>
<b class="nc">&nbsp;                write(accessor);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            ObjectMap&lt;String, Selement&gt; usedNames = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;            ObjectMap&lt;Selement, ObjectSet&lt;String&gt;&gt; extraNames = new ObjectMap&lt;&gt;();</b>
&nbsp;
&nbsp;            //look at each definition
<b class="nc">&nbsp;            for(Selement&lt;?&gt; type : allDefs){</b>
<b class="nc">&nbsp;                EntityDef ann = type.annotation(EntityDef.class);</b>
&nbsp;
&nbsp;                //all component classes (not interfaces)
<b class="nc">&nbsp;                Seq&lt;Stype&gt; components = allComponents(type);</b>
<b class="nc">&nbsp;                Seq&lt;GroupDefinition&gt; groups = groupDefs.select(g -&gt; (!g.components.isEmpty() &amp;&amp; !g.components.contains(s -&gt; !components.contains(s))) || g.manualInclusions.contains(type));</b>
<b class="nc">&nbsp;                ObjectMap&lt;String, Seq&lt;Smethod&gt;&gt; methods = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;                ObjectMap&lt;FieldSpec, Svar&gt; specVariables = new ObjectMap&lt;&gt;();</b>
<b class="nc">&nbsp;                ObjectSet&lt;String&gt; usedFields = new ObjectSet&lt;&gt;();</b>
&nbsp;
&nbsp;                //make sure there&#39;s less than 2 base classes
<b class="nc">&nbsp;                Seq&lt;Stype&gt; baseClasses = components.select(s -&gt; s.annotation(Component.class).base());</b>
<b class="nc">&nbsp;                if(baseClasses.size &gt; 2){</b>
<b class="nc">&nbsp;                    err(&quot;No entity may have more than 2 base classes. Base classes: &quot; + baseClasses, type);</b>
&nbsp;                }
&nbsp;
&nbsp;                //get base class type name for extension
<b class="nc">&nbsp;                Stype baseClassType = baseClasses.any() ? baseClasses.first() : null;</b>
<b class="nc">&nbsp;                @Nullable TypeName baseClass = baseClasses.any() ? tname(packageName + &quot;.&quot; + baseName(baseClassType)) : null;</b>
<b class="nc">&nbsp;                @Nullable TypeSpec.Builder baseClassBuilder = baseClassType == null ? null : this.baseClasses.find(b -&gt; Reflect.&lt;String&gt;get(b, &quot;name&quot;).equals(baseName(baseClassType)));</b>
<b class="nc">&nbsp;                boolean addIndexToBase = baseClassBuilder != null &amp;&amp; baseClassIndexers.add(baseClassBuilder);</b>
&nbsp;                //whether the main class is the base itself
<b class="nc">&nbsp;                boolean typeIsBase = baseClassType != null &amp;&amp; type.has(Component.class) &amp;&amp; type.annotation(Component.class).base();</b>
&nbsp;
<b class="nc">&nbsp;                if(type.isType() &amp;&amp; (!type.name().endsWith(&quot;Def&quot;) &amp;&amp; !type.name().endsWith(&quot;Comp&quot;))){</b>
<b class="nc">&nbsp;                    err(&quot;All entity def names must end with &#39;Def&#39;/&#39;Comp&#39;&quot;, type.e);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                String name = type.isType() ?</b>
<b class="nc">&nbsp;                    type.name().replace(&quot;Def&quot;, &quot;&quot;).replace(&quot;Comp&quot;, &quot;&quot;) :</b>
<b class="nc">&nbsp;                    createName(type);</b>
&nbsp;
&nbsp;                //check for type name conflicts
<b class="nc">&nbsp;                if(!typeIsBase &amp;&amp; baseClass != null &amp;&amp; name.equals(baseName(baseClassType))){</b>
<b class="nc">&nbsp;                    name += &quot;Entity&quot;;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                boolean legacy = ann.legacy();</b>
&nbsp;
<b class="nc">&nbsp;                if(legacy){</b>
<b class="nc">&nbsp;                    baseClass = tname(packageName + &quot;.&quot; + name);</b>
<b class="nc">&nbsp;                    name += &quot;Legacy&quot; + Strings.capitalize(type.name());</b>
&nbsp;                }
&nbsp;
&nbsp;                //skip double classes
<b class="nc">&nbsp;                if(usedNames.containsKey(name)){</b>
<b class="nc">&nbsp;                    extraNames.get(usedNames.get(name), ObjectSet::new).add(type.name());</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                usedNames.put(name, type);</b>
<b class="nc">&nbsp;                extraNames.get(type, ObjectSet::new).add(name);</b>
<b class="nc">&nbsp;                if(!type.isType()){</b>
<b class="nc">&nbsp;                    extraNames.get(type, ObjectSet::new).add(type.name());</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                TypeSpec.Builder builder = TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);</b>
&nbsp;
&nbsp;                //add serialize() boolean
<b class="nc">&nbsp;                builder.addMethod(MethodSpec.methodBuilder(&quot;serialize&quot;).addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(&quot;return &quot; + ann.serialize()).build());</b>
&nbsp;
&nbsp;                //all SyncField fields
<b class="nc">&nbsp;                Seq&lt;Svar&gt; syncedFields = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;                Seq&lt;Svar&gt; allFields = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;                Seq&lt;FieldSpec&gt; allFieldSpecs = new Seq&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                boolean isSync = components.contains(s -&gt; s.name().contains(&quot;Sync&quot;));</b>
&nbsp;
&nbsp;                //add all components
<b class="nc">&nbsp;                for(Stype comp : components){</b>
&nbsp;                    //whether this component&#39;s fields are defined in the base class
<b class="nc">&nbsp;                    boolean isShadowed = baseClass != null &amp;&amp; !typeIsBase &amp;&amp; baseClassDeps.get(baseClassType).contains(comp);</b>
&nbsp;
&nbsp;                    //write fields to the class; ignoring transient/imported ones
<b class="nc">&nbsp;                    Seq&lt;Svar&gt; fields = comp.fields().select(f -&gt; !f.has(Import.class));</b>
<b class="nc">&nbsp;                    for(Svar f : fields){</b>
<b class="nc">&nbsp;                        if(!usedFields.add(f.name())){</b>
<b class="nc">&nbsp;                            err(&quot;Field &#39;&quot; + f.name() + &quot;&#39; of component &#39;&quot; + comp.name() + &quot;&#39; redefines a field in entity &#39;&quot; + type.name() + &quot;&#39;&quot;);</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        FieldSpec.Builder fbuilder = FieldSpec.builder(f.tname(), f.name());</b>
&nbsp;                        //keep statics/finals
<b class="nc">&nbsp;                        if(f.is(Modifier.STATIC)){</b>
<b class="nc">&nbsp;                            fbuilder.addModifiers(Modifier.STATIC);</b>
<b class="nc">&nbsp;                            if(f.is(Modifier.FINAL)) fbuilder.addModifiers(Modifier.FINAL);</b>
&nbsp;                        }
&nbsp;                        //add transient modifier for serialization
<b class="nc">&nbsp;                        if(f.is(Modifier.TRANSIENT)){</b>
<b class="nc">&nbsp;                            fbuilder.addModifiers(Modifier.TRANSIENT);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //add initializer if it exists
<b class="nc">&nbsp;                        if(varInitializers.containsKey(f.descString())){</b>
<b class="nc">&nbsp;                            fbuilder.initializer(varInitializers.get(f.descString()));</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        fbuilder.addModifiers(f.has(ReadOnly.class) || f.is(Modifier.PRIVATE) ? Modifier.PROTECTED : Modifier.PUBLIC);</b>
<b class="nc">&nbsp;                        fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));</b>
<b class="nc">&nbsp;                        FieldSpec spec = fbuilder.build();</b>
&nbsp;
&nbsp;                        //whether this field would be added to the superclass
<b class="nc">&nbsp;                        boolean isVisible = !f.is(Modifier.STATIC) &amp;&amp; !f.is(Modifier.PRIVATE) &amp;&amp; !f.has(ReadOnly.class);</b>
&nbsp;
&nbsp;                        //add the field only if it isn&#39;t visible or it wasn&#39;t implemented by the base class
&nbsp;                        //legacy classes have no extra fields
<b class="nc">&nbsp;                        if((!isShadowed || !isVisible) &amp;&amp; !legacy){</b>
<b class="nc">&nbsp;                            builder.addField(spec);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        specVariables.put(spec, f);</b>
&nbsp;
<b class="nc">&nbsp;                        allFieldSpecs.add(spec);</b>
<b class="nc">&nbsp;                        allFields.add(f);</b>
&nbsp;
&nbsp;                        //add extra sync fields
<b class="nc">&nbsp;                        if(f.has(SyncField.class) &amp;&amp; isSync &amp;&amp; !legacy){</b>
<b class="nc">&nbsp;                            if(!f.tname().toString().equals(&quot;float&quot;)) err(&quot;All SyncFields must be of type float&quot;, f);</b>
&nbsp;
<b class="nc">&nbsp;                            syncedFields.add(f);</b>
&nbsp;
&nbsp;                            //a synced field has 3 values:
&nbsp;                            //- target state
&nbsp;                            //- last state
&nbsp;                            //- current state (the field itself, will be written to)
&nbsp;
&nbsp;                            //target
<b class="nc">&nbsp;                            builder.addField(FieldSpec.builder(float.class, f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT, Modifier.PRIVATE).build());</b>
&nbsp;
&nbsp;                            //last
<b class="nc">&nbsp;                            builder.addField(FieldSpec.builder(float.class, f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT, Modifier.PRIVATE).build());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    //get all methods from components
<b class="nc">&nbsp;                    for(Smethod elem : comp.methods()){</b>
<b class="nc">&nbsp;                        methods.get(elem.toString(), Seq::new).add(elem);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                syncedFields.sortComparing(Selement::name);</b>
&nbsp;
<b class="nc">&nbsp;                if(!methods.containsKey(&quot;toString()&quot;)){</b>
&nbsp;                    //override toString method
<b class="nc">&nbsp;                    builder.addMethod(MethodSpec.methodBuilder(&quot;toString&quot;)</b>
<b class="nc">&nbsp;                    .addAnnotation(Override.class)</b>
<b class="nc">&nbsp;                    .returns(String.class)</b>
<b class="nc">&nbsp;                    .addModifiers(Modifier.PUBLIC)</b>
<b class="nc">&nbsp;                    .addStatement(&quot;return $S + $L&quot;, name + &quot;#&quot;, &quot;id&quot;).build());</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                EntityIO io = new EntityIO(type.name(), builder, allFieldSpecs, serializer, rootDirectory.child(&quot;annotations/src/main/resources/revisions&quot;).child(type.name()));</b>
&nbsp;                //entities with no sync comp and no serialization gen no code
<b class="nc">&nbsp;                boolean hasIO = ann.genio() &amp;&amp; (components.contains(s -&gt; s.name().contains(&quot;Sync&quot;)) || ann.serialize());</b>
&nbsp;
<b class="nc">&nbsp;                TypeSpec.Builder indexBuilder = baseClassBuilder == null ? builder : baseClassBuilder;</b>
&nbsp;
<b class="nc">&nbsp;                if(baseClassBuilder == null || addIndexToBase){</b>
&nbsp;                    //implement indexable interfaces.
<b class="nc">&nbsp;                    for(GroupDefinition def : groups){</b>
<b class="nc">&nbsp;                        indexBuilder.addSuperinterface(tname(packageName + &quot;.IndexableEntity__&quot; + def.name));</b>
<b class="nc">&nbsp;                        indexBuilder.addMethod(MethodSpec.methodBuilder(&quot;setIndex__&quot; + def.name).addParameter(int.class, &quot;index&quot;).addModifiers(Modifier.PUBLIC).addAnnotation(Override.class)</b>
<b class="nc">&nbsp;                        .addCode(&quot;index__$L = index;&quot;, def.name).build());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                //add all methods from components
<b class="nc">&nbsp;                for(ObjectMap.Entry&lt;String, Seq&lt;Smethod&gt;&gt; entry : methods){</b>
<b class="nc">&nbsp;                    if(entry.value.contains(m -&gt; m.has(Replace.class))){</b>
&nbsp;                        //check replacements
<b class="nc">&nbsp;                        if(entry.value.count(m -&gt; m.has(Replace.class)) &gt; 1){</b>
<b class="nc">&nbsp;                            err(&quot;Type &quot; + type + &quot; has multiple components replacing method &quot; + entry.key + &quot;.&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Smethod base = entry.value.find(m -&gt; m.has(Replace.class));</b>
<b class="nc">&nbsp;                        entry.value.clear();</b>
<b class="nc">&nbsp;                        entry.value.add(base);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //check multi return
<b class="nc">&nbsp;                    if(entry.value.count(m -&gt; !m.isAny(Modifier.NATIVE, Modifier.ABSTRACT) &amp;&amp; !m.isVoid()) &gt; 1){</b>
<b class="nc">&nbsp;                        err(&quot;Type &quot; + type + &quot; has multiple components implementing non-void method &quot; + entry.key + &quot;.&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    entry.value.sort(Structs.comps(Structs.comparingFloat(m -&gt; m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0), Structs.comparing(s -&gt; s.up().getSimpleName().toString())));</b>
&nbsp;
&nbsp;                    //representative method
<b class="nc">&nbsp;                    Smethod first = entry.value.first();</b>
&nbsp;
&nbsp;                    //skip internal impl
<b class="nc">&nbsp;                    if(first.has(InternalImpl.class)){</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //build method using same params/returns
<b class="nc">&nbsp;                    MethodSpec.Builder mbuilder = MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);</b>
&nbsp;                    //if(isFinal || entry.value.contains(s -&gt; s.has(Final.class))) mbuilder.addModifiers(Modifier.FINAL);
<b class="nc">&nbsp;                    if(entry.value.contains(s -&gt; s.has(CallSuper.class))) mbuilder.addAnnotation(CallSuper.class); //add callSuper here if necessary</b>
<b class="nc">&nbsp;                    if(first.is(Modifier.STATIC)) mbuilder.addModifiers(Modifier.STATIC);</b>
<b class="nc">&nbsp;                    mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));</b>
<b class="nc">&nbsp;                    mbuilder.returns(first.retn());</b>
<b class="nc">&nbsp;                    mbuilder.addExceptions(first.thrownt());</b>
&nbsp;
<b class="nc">&nbsp;                    for(Svar var : first.params()){</b>
<b class="nc">&nbsp;                        mbuilder.addParameter(var.tname(), var.name());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    //only write the block if it&#39;s a void method with several entries
<b class="nc">&nbsp;                    boolean writeBlock = first.ret().toString().equals(&quot;void&quot;) &amp;&amp; entry.value.size &gt; 1;</b>
&nbsp;
<b class="nc">&nbsp;                    if((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) &amp;&amp; entry.value.size == 1 &amp;&amp; !entry.value.first().has(InternalImpl.class)){</b>
<b class="nc">&nbsp;                        err(entry.value.first().up().getSimpleName() + &quot;#&quot; + entry.value.first() + &quot; is an abstract method and must be implemented in some component&quot;, type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //SPECIAL CASE: inject group add/remove code
<b class="nc">&nbsp;                    if(first.name().equals(&quot;add&quot;) || first.name().equals(&quot;remove&quot;)){</b>
<b class="nc">&nbsp;                        mbuilder.addStatement(&quot;if(added == $L) return&quot;, first.name().equals(&quot;add&quot;));</b>
&nbsp;
<b class="nc">&nbsp;                        for(GroupDefinition def : groups){</b>
<b class="nc">&nbsp;                            if(first.name().equals(&quot;add&quot;)){</b>
&nbsp;                                //remove/add from each group, assume imported
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;index__$L = Groups.$L.addIndex(this)&quot;, def.name, def.name);</b>
&nbsp;                            }else{
&nbsp;                                //remove/add from each group, assume imported
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;Groups.$L.removeIndex(this, index__$L);&quot;, def.name, def.name);</b>
&nbsp;
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;index__$L = -1&quot;, def.name);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    boolean specialIO = false;</b>
&nbsp;
<b class="nc">&nbsp;                    if(hasIO){</b>
&nbsp;                        //SPECIAL CASE: I/O code
&nbsp;                        //note that serialization is generated even for non-serializing entities for manual usage
<b class="nc">&nbsp;                        if((first.name().equals(&quot;read&quot;) || first.name().equals(&quot;write&quot;))){</b>
<b class="nc">&nbsp;                            io.write(mbuilder, first.name().equals(&quot;write&quot;));</b>
<b class="nc">&nbsp;                            specialIO = true;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //SPECIAL CASE: sync I/O code
<b class="nc">&nbsp;                        if((first.name().equals(&quot;readSync&quot;) || first.name().equals(&quot;writeSync&quot;))){</b>
<b class="nc">&nbsp;                            io.writeSync(mbuilder, first.name().equals(&quot;writeSync&quot;), allFields);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //SPECIAL CASE: sync I/O code for writing to/from a manual buffer
<b class="nc">&nbsp;                        if((first.name().equals(&quot;readSyncManual&quot;) || first.name().equals(&quot;writeSyncManual&quot;))){</b>
<b class="nc">&nbsp;                            io.writeSyncManual(mbuilder, first.name().equals(&quot;writeSyncManual&quot;), syncedFields);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //SPECIAL CASE: interpolate method implementation
<b class="nc">&nbsp;                        if(first.name().equals(&quot;interpolate&quot;)){</b>
<b class="nc">&nbsp;                            io.writeInterpolate(mbuilder, syncedFields);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //SPECIAL CASE: method to snap to target position after being read for the first time
<b class="nc">&nbsp;                        if(first.name().equals(&quot;snapSync&quot;)){</b>
<b class="nc">&nbsp;                            mbuilder.addStatement(&quot;updateSpacing = 16&quot;);</b>
<b class="nc">&nbsp;                            mbuilder.addStatement(&quot;lastUpdated = $T.millis()&quot;, Time.class);</b>
<b class="nc">&nbsp;                            for(Svar field : syncedFields){</b>
&nbsp;                                //reset last+current state to target position
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;$L = $L&quot;, field.name() + EntityIO.lastSuf, field.name() + EntityIO.targetSuf);</b>
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;$L = $L&quot;, field.name(), field.name() + EntityIO.targetSuf);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //SPECIAL CASE: method to snap to current position so interpolation doesn&#39;t go wild
<b class="nc">&nbsp;                        if(first.name().equals(&quot;snapInterpolation&quot;)){</b>
<b class="nc">&nbsp;                            mbuilder.addStatement(&quot;updateSpacing = 16&quot;);</b>
<b class="nc">&nbsp;                            mbuilder.addStatement(&quot;lastUpdated = $T.millis()&quot;, Time.class);</b>
<b class="nc">&nbsp;                            for(Svar field : syncedFields){</b>
&nbsp;                                //reset last+current state to target position
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;$L = $L&quot;, field.name() + EntityIO.lastSuf, field.name());</b>
<b class="nc">&nbsp;                                mbuilder.addStatement(&quot;$L = $L&quot;, field.name() + EntityIO.targetSuf, field.name());</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    for(Smethod elem : entry.value){</b>
<b class="nc">&nbsp;                        String descStr = elem.descString();</b>
&nbsp;
<b class="nc">&nbsp;                        if(elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr)) continue;</b>
&nbsp;
&nbsp;                        //get all statements in the method, copy them over
<b class="nc">&nbsp;                        String str = methodBlocks.get(descStr);</b>
&nbsp;                        //name for code blocks in the methods
<b class="nc">&nbsp;                        String blockName = elem.up().getSimpleName().toString().toLowerCase().replace(&quot;comp&quot;, &quot;&quot;);</b>
&nbsp;
&nbsp;                        //skip empty blocks
<b class="nc">&nbsp;                        if(str.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;).isEmpty()){</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //wrap scope to prevent variable leakage
<b class="nc">&nbsp;                        if(writeBlock){</b>
&nbsp;                            //replace return; with block break
<b class="nc">&nbsp;                            str = str.replace(&quot;return;&quot;, &quot;break &quot; + blockName + &quot;;&quot;);</b>
<b class="nc">&nbsp;                            mbuilder.addCode(blockName + &quot;: {\n&quot;);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //trim block
<b class="nc">&nbsp;                        str = str.substring(2, str.length() - 1);</b>
&nbsp;
&nbsp;                        //make sure to remove braces here
<b class="nc">&nbsp;                        mbuilder.addCode(str);</b>
&nbsp;
&nbsp;                        //end scope
<b class="nc">&nbsp;                        if(writeBlock) mbuilder.addCode(&quot;}\n&quot;);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    //add free code to remove methods - always at the end
&nbsp;                    //this only gets called next frame.
<b class="nc">&nbsp;                    if(first.name().equals(&quot;remove&quot;) &amp;&amp; ann.pooled()){</b>
<b class="nc">&nbsp;                        mbuilder.addStatement(&quot;mindustry.gen.Groups.queueFree(($T)this)&quot;, Poolable.class);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if(!legacy || specialIO){</b>
<b class="nc">&nbsp;                        builder.addMethod(mbuilder.build());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                //add pool reset method and implement Poolable
<b class="nc">&nbsp;                if(ann.pooled()){</b>
<b class="nc">&nbsp;                    builder.addSuperinterface(Poolable.class);</b>
&nbsp;                    //implement reset()
<b class="nc">&nbsp;                    MethodSpec.Builder resetBuilder = MethodSpec.methodBuilder(&quot;reset&quot;).addModifiers(Modifier.PUBLIC);</b>
<b class="nc">&nbsp;                    allFieldSpecs.sortComparing(s -&gt; s.name);</b>
<b class="nc">&nbsp;                    for(FieldSpec spec : allFieldSpecs){</b>
<b class="nc">&nbsp;                        @Nullable Svar variable = specVariables.get(spec);</b>
<b class="nc">&nbsp;                        if(variable != null &amp;&amp; variable.isAny(Modifier.STATIC, Modifier.FINAL)) continue;</b>
<b class="nc">&nbsp;                        String desc = variable.descString();</b>
&nbsp;
<b class="nc">&nbsp;                        if(spec.type.isPrimitive()){</b>
&nbsp;                            //set to primitive default
<b class="nc">&nbsp;                            resetBuilder.addStatement(&quot;$L = $L&quot;, spec.name, variable != null &amp;&amp; varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));</b>
&nbsp;                        }else{
&nbsp;                            //set to default null
<b class="nc">&nbsp;                            if(!varInitializers.containsKey(desc)){</b>
<b class="nc">&nbsp;                                resetBuilder.addStatement(&quot;$L = null&quot;, spec.name);</b>
&nbsp;                            } //else... TODO reset if poolable
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    builder.addMethod(resetBuilder.build());</b>
&nbsp;                }
&nbsp;
&nbsp;                //make constructor private
<b class="nc">&nbsp;                builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());</b>
&nbsp;
&nbsp;                //add create() method
<b class="nc">&nbsp;                builder.addMethod(MethodSpec.methodBuilder(&quot;create&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC)</b>
<b class="nc">&nbsp;                .returns(tname(packageName + &quot;.&quot; + name))</b>
<b class="nc">&nbsp;                .addStatement(ann.pooled() ? &quot;return Pools.obtain($L.class, &quot; +name +&quot;::new)&quot; : &quot;return new $L()&quot;, name).build());</b>
&nbsp;
<b class="nc">&nbsp;                skipDeprecated(builder);</b>
&nbsp;
<b class="nc">&nbsp;                if(!legacy){</b>
<b class="nc">&nbsp;                    TypeSpec.Builder fieldBuilder = baseClassBuilder != null ? baseClassBuilder : builder;</b>
<b class="nc">&nbsp;                    if(addIndexToBase || baseClassBuilder == null){</b>
&nbsp;                        //add group index int variables
<b class="nc">&nbsp;                        for(GroupDefinition def : groups){</b>
<b class="nc">&nbsp;                            fieldBuilder.addField(FieldSpec.builder(int.class, &quot;index__&quot; + def.name, Modifier.PROTECTED, Modifier.TRANSIENT).initializer(&quot;-1&quot;).build());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                definitions.add(new EntityDefinition(packageName + &quot;.&quot; + name, builder, type, typeIsBase ? null : baseClass, components, groups, allFieldSpecs, legacy));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //generate groups
<b class="nc">&nbsp;            TypeSpec.Builder groupsBuilder = TypeSpec.classBuilder(&quot;Groups&quot;).addModifiers(Modifier.PUBLIC);</b>
<b class="nc">&nbsp;            MethodSpec.Builder groupInit = MethodSpec.methodBuilder(&quot;init&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC);</b>
<b class="nc">&nbsp;            for(GroupDefinition group : groupDefs){</b>
&nbsp;                //class names for interface/group
<b class="nc">&nbsp;                ClassName itype =  group.baseType;</b>
<b class="nc">&nbsp;                ClassName groupc = ClassName.bestGuess(&quot;mindustry.entities.EntityGroup&quot;);</b>
&nbsp;
&nbsp;                //add field...
<b class="nc">&nbsp;                groupsBuilder.addField(ParameterizedTypeName.get(</b>
<b class="nc">&nbsp;                    ClassName.bestGuess(&quot;mindustry.entities.EntityGroup&quot;), itype), group.name, Modifier.PUBLIC, Modifier.STATIC);</b>
&nbsp;
<b class="nc">&nbsp;                groupInit.addStatement(&quot;$L = new $T&lt;&gt;($L.class, $L, $L, (e, pos) -&gt; { if(e instanceof $L.IndexableEntity__$L ix) ix.setIndex__$L(pos); })&quot;, group.name, groupc, itype, group.spatial, group.mapping, packageName, group.name, group.name);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //write the groups
<b class="nc">&nbsp;            groupsBuilder.addMethod(groupInit.build());</b>
&nbsp;
<b class="nc">&nbsp;            groupsBuilder.addField(boolean.class, &quot;isClearing&quot;, Modifier.PUBLIC, Modifier.STATIC);</b>
&nbsp;
<b class="nc">&nbsp;            MethodSpec.Builder groupClear = MethodSpec.methodBuilder(&quot;clear&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC);</b>
<b class="nc">&nbsp;            groupClear.addStatement(&quot;isClearing = true&quot;);</b>
<b class="nc">&nbsp;            for(GroupDefinition group : groupDefs){</b>
<b class="nc">&nbsp;                groupClear.addStatement(&quot;$L.clear()&quot;, group.name);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            groupClear.addStatement(&quot;isClearing = false&quot;);</b>
&nbsp;
&nbsp;            //write clear
<b class="nc">&nbsp;            groupsBuilder.addMethod(groupClear.build());</b>
&nbsp;
&nbsp;            //add method for pool storage
<b class="nc">&nbsp;            groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class, Poolable.class), &quot;freeQueue&quot;, Modifier.PRIVATE, Modifier.STATIC).initializer(&quot;new Seq&lt;&gt;()&quot;).build());</b>
&nbsp;
&nbsp;            //method for freeing things
<b class="nc">&nbsp;            MethodSpec.Builder groupFreeQueue = MethodSpec.methodBuilder(&quot;queueFree&quot;)</b>
<b class="nc">&nbsp;                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</b>
<b class="nc">&nbsp;                .addParameter(Poolable.class, &quot;obj&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;freeQueue.add(obj)&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            groupsBuilder.addMethod(groupFreeQueue.build());</b>
&nbsp;
&nbsp;            //add method for resizing all necessary groups
<b class="nc">&nbsp;            MethodSpec.Builder groupResize = MethodSpec.methodBuilder(&quot;resize&quot;)</b>
<b class="nc">&nbsp;                .addParameter(TypeName.FLOAT, &quot;x&quot;).addParameter(TypeName.FLOAT, &quot;y&quot;).addParameter(TypeName.FLOAT, &quot;w&quot;).addParameter(TypeName.FLOAT, &quot;h&quot;)</b>
<b class="nc">&nbsp;                .addModifiers(Modifier.PUBLIC, Modifier.STATIC);</b>
&nbsp;
<b class="nc">&nbsp;            MethodSpec.Builder groupUpdate = MethodSpec.methodBuilder(&quot;update&quot;)</b>
<b class="nc">&nbsp;                .addModifiers(Modifier.PUBLIC, Modifier.STATIC);</b>
&nbsp;
&nbsp;            //free everything pooled at the start of each updaet
<b class="nc">&nbsp;            groupUpdate</b>
<b class="nc">&nbsp;                .addStatement(&quot;for($T p : freeQueue) $T.free(p)&quot;, Poolable.class, Pools.class)</b>
<b class="nc">&nbsp;                .addStatement(&quot;freeQueue.clear()&quot;);</b>
&nbsp;
&nbsp;            //method resize
<b class="nc">&nbsp;            for(GroupDefinition group : groupDefs){</b>
<b class="nc">&nbsp;                if(group.spatial){</b>
<b class="nc">&nbsp;                    groupResize.addStatement(&quot;$L.resize(x, y, w, h)&quot;, group.name);</b>
<b class="nc">&nbsp;                    groupUpdate.addStatement(&quot;$L.updatePhysics()&quot;, group.name);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            groupUpdate.addStatement(&quot;all.update()&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            for(GroupDefinition group : groupDefs){</b>
<b class="nc">&nbsp;                if(group.collides){</b>
<b class="nc">&nbsp;                    groupUpdate.addStatement(&quot;$L.collide()&quot;, group.name);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            groupsBuilder.addMethod(groupResize.build());</b>
<b class="nc">&nbsp;            groupsBuilder.addMethod(groupUpdate.build());</b>
&nbsp;
<b class="nc">&nbsp;            write(groupsBuilder);</b>
&nbsp;
&nbsp;            //load map of sync IDs
<b class="nc">&nbsp;            StringMap map = new StringMap();</b>
<b class="nc">&nbsp;            Fi idProps = rootDirectory.child(&quot;annotations/src/main/resources/classids.properties&quot;);</b>
<b class="nc">&nbsp;            if(!idProps.exists()) idProps.writeString(&quot;&quot;);</b>
<b class="nc">&nbsp;            PropertiesUtils.load(map, idProps.reader());</b>
&nbsp;            //next ID to be used in generation
<b class="nc">&nbsp;            Integer max = map.values().toSeq().map(Integer::parseInt).max(i -&gt; i);</b>
<b class="nc">&nbsp;            int maxID = max == null ? 0 : max + 1;</b>
&nbsp;
&nbsp;            //assign IDs
<b class="nc">&nbsp;            definitions.sort(Structs.comparing(t -&gt; t.naming.toString()));</b>
<b class="nc">&nbsp;            for(EntityDefinition def : definitions){</b>
<b class="nc">&nbsp;                String name = def.naming.fullName();</b>
<b class="nc">&nbsp;                if(map.containsKey(name)){</b>
<b class="nc">&nbsp;                    def.classID = map.getInt(name);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    def.classID = maxID++;</b>
<b class="nc">&nbsp;                    map.put(name, def.classID + &quot;&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            OrderedMap&lt;String, String&gt; res = new OrderedMap&lt;&gt;();</b>
<b class="nc">&nbsp;            res.putAll(map);</b>
<b class="nc">&nbsp;            res.orderedKeys().sort();</b>
&nbsp;
&nbsp;            //write assigned IDs
<b class="nc">&nbsp;            PropertiesUtils.store(res, idProps.writer(false), &quot;Maps entity names to IDs. Autogenerated.&quot;);</b>
&nbsp;
&nbsp;            //build mapping class for sync IDs
<b class="nc">&nbsp;            TypeSpec.Builder idBuilder = TypeSpec.classBuilder(&quot;EntityMapping&quot;).addModifiers(Modifier.PUBLIC)</b>
<b class="nc">&nbsp;            .addField(FieldSpec.builder(TypeName.get(Prov[].class), &quot;idMap&quot;, Modifier.PUBLIC, Modifier.STATIC).initializer(&quot;new Prov[256]&quot;).build())</b>
&nbsp;
<b class="nc">&nbsp;            .addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),</b>
<b class="nc">&nbsp;                tname(String.class), tname(Prov.class)),</b>
<b class="nc">&nbsp;                &quot;nameMap&quot;, Modifier.PUBLIC, Modifier.STATIC).initializer(&quot;new ObjectMap&lt;&gt;()&quot;).build())</b>
&nbsp;
<b class="nc">&nbsp;            .addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(IntMap.class), tname(String.class)),</b>
<b class="nc">&nbsp;                &quot;customIdMap&quot;, Modifier.PUBLIC, Modifier.STATIC).initializer(&quot;new IntMap&lt;&gt;()&quot;).build())</b>
&nbsp;
<b class="nc">&nbsp;            .addMethod(MethodSpec.methodBuilder(&quot;register&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC)</b>
<b class="nc">&nbsp;                .returns(TypeName.get(int.class))</b>
<b class="nc">&nbsp;                .addParameter(String.class, &quot;name&quot;).addParameter(Prov.class, &quot;constructor&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;int next = arc.util.Structs.indexOf(idMap, v -&gt; v == null)&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;idMap[next] = constructor&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;nameMap.put(name, constructor)&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;customIdMap.put(next, name)&quot;)</b>
<b class="nc">&nbsp;                .addStatement(&quot;return next&quot;)</b>
<b class="nc">&nbsp;                .addJavadoc(&quot;Use this method for obtaining a classId for custom modded unit types. Only call this once for each type. Modded types should return this id in their overridden classId method.&quot;)</b>
<b class="nc">&nbsp;                .build())</b>
&nbsp;
<b class="nc">&nbsp;            .addMethod(MethodSpec.methodBuilder(&quot;map&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC)</b>
<b class="nc">&nbsp;                .returns(TypeName.get(Prov.class)).addParameter(int.class, &quot;id&quot;).addStatement(&quot;return idMap[id]&quot;).build())</b>
&nbsp;
<b class="nc">&nbsp;            .addMethod(MethodSpec.methodBuilder(&quot;map&quot;).addModifiers(Modifier.PUBLIC, Modifier.STATIC)</b>
<b class="nc">&nbsp;                .returns(TypeName.get(Prov.class)).addParameter(String.class, &quot;name&quot;).addStatement(&quot;return nameMap.get(name)&quot;).build());</b>
&nbsp;
<b class="nc">&nbsp;            CodeBlock.Builder idStore = CodeBlock.builder();</b>
&nbsp;
&nbsp;            //store the mappings
<b class="nc">&nbsp;            for(EntityDefinition def : definitions){</b>
&nbsp;                //store mapping
<b class="nc">&nbsp;                idStore.addStatement(&quot;idMap[$L] = $L::new&quot;, def.classID, def.name);</b>
<b class="nc">&nbsp;                extraNames.get(def.naming).each(extra -&gt; {</b>
<b class="nc">&nbsp;                    idStore.addStatement(&quot;nameMap.put($S, $L::new)&quot;, extra, def.name);</b>
<b class="nc">&nbsp;                    if(!Strings.camelToKebab(extra).equals(extra)){</b>
<b class="nc">&nbsp;                        idStore.addStatement(&quot;nameMap.put($S, $L::new)&quot;, Strings.camelToKebab(extra), def.name);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;                //return mapping
<b class="nc">&nbsp;                def.builder.addMethod(MethodSpec.methodBuilder(&quot;classId&quot;).addAnnotation(Override.class)</b>
<b class="nc">&nbsp;                    .returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(&quot;return &quot; + def.classID).build());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;            idBuilder.addStaticBlock(idStore.build());</b>
&nbsp;
<b class="nc">&nbsp;            write(idBuilder);</b>
<b class="nc">&nbsp;        }else{</b>
&nbsp;            //round 3: generate actual classes and implement interfaces
&nbsp;
&nbsp;            //implement each definition
<b class="nc">&nbsp;            for(EntityDefinition def : definitions){</b>
&nbsp;
<b class="nc">&nbsp;                ObjectSet&lt;String&gt; methodNames = def.components.flatMap(type -&gt; type.methods().map(Smethod::simpleString)).&lt;String&gt;as().asSet();</b>
&nbsp;
&nbsp;                //add base class extension if it exists
<b class="nc">&nbsp;                if(def.extend != null){</b>
<b class="nc">&nbsp;                    def.builder.superclass(def.extend);</b>
&nbsp;                }
&nbsp;
&nbsp;                //get interface for each component
<b class="nc">&nbsp;                for(Stype comp : def.components){</b>
&nbsp;
&nbsp;                    //implement the interface
<b class="nc">&nbsp;                    Stype inter = allInterfaces.find(i -&gt; i.name().equals(interfaceName(comp)));</b>
<b class="nc">&nbsp;                    if(inter == null){</b>
<b class="nc">&nbsp;                        err(&quot;Failed to generate interface for&quot;, comp);</b>
&nbsp;                        return;
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    def.builder.addSuperinterface(inter.tname());</b>
&nbsp;
<b class="nc">&nbsp;                    if(def.legacy) continue;</b>
&nbsp;
<b class="nc">&nbsp;                    @Nullable TypeSpec.Builder superclass = null;</b>
&nbsp;
<b class="nc">&nbsp;                    if(def.extend != null){</b>
<b class="nc">&nbsp;                        superclass = baseClasses.find(b -&gt; (packageName + &quot;.&quot; + Reflect.get(b, &quot;name&quot;)).equals(def.extend.toString()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //generate getter/setter for each method
<b class="nc">&nbsp;                    for(Smethod method : inter.methods()){</b>
<b class="nc">&nbsp;                        String var = method.name();</b>
<b class="nc">&nbsp;                        FieldSpec field = Seq.with(def.fieldSpecs).find(f -&gt; f.name.equals(var));</b>
&nbsp;                        //make sure it&#39;s a real variable AND that the component doesn&#39;t already implement it somewhere with custom logic
<b class="nc">&nbsp;                        if(field == null || methodNames.contains(method.simpleString())) continue;</b>
&nbsp;
<b class="nc">&nbsp;                        MethodSpec result = null;</b>
&nbsp;
&nbsp;                        //getter
<b class="nc">&nbsp;                        if(!method.isVoid()){</b>
<b class="nc">&nbsp;                            result = MethodSpec.overriding(method.e).addStatement(&quot;return &quot; + var).build();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //setter
<b class="nc">&nbsp;                        if(method.isVoid() &amp;&amp; !Seq.with(field.annotations).contains(f -&gt; f.type.toString().equals(&quot;@mindustry.annotations.Annotations.ReadOnly&quot;))){</b>
<b class="nc">&nbsp;                            result = MethodSpec.overriding(method.e).addStatement(&quot;this.&quot; + var + &quot; = &quot; + var).build();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        //add getter/setter to parent class, if possible. when this happens, skip adding getters setters *here* because they are defined in the superclass.
<b class="nc">&nbsp;                        if(result != null &amp;&amp; superclass != null){</b>
<b class="nc">&nbsp;                            FieldSpec superField = Seq.with(superclass.fieldSpecs).find(f -&gt; f.name.equals(var));</b>
&nbsp;
&nbsp;                            //found the right field, try to check for the method already existing now
<b class="nc">&nbsp;                            if(superField != null){</b>
<b class="nc">&nbsp;                                MethodSpec fr = result;</b>
<b class="nc">&nbsp;                                MethodSpec targetMethod = Seq.with(superclass.methodSpecs).find(m -&gt; m.name.equals(var) &amp;&amp; m.returnType.equals(fr.returnType));</b>
&nbsp;                                //if the method isn&#39;t added yet, add it. in any case, skip.
<b class="nc">&nbsp;                                if(targetMethod == null){</b>
<b class="nc">&nbsp;                                    superclass.addMethod(result);</b>
&nbsp;                                }
&nbsp;                                continue;
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if(result != null){</b>
<b class="nc">&nbsp;                            def.builder.addMethod(result);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                write(def.builder, imports.toSeq());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //write base classes last
<b class="nc">&nbsp;            for(TypeSpec.Builder b : baseClasses){</b>
<b class="nc">&nbsp;                write(b, imports.toSeq());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    Seq&lt;String&gt; getImports(Element elem){
<b class="nc">&nbsp;        return Seq.with(trees.getPath(elem).getCompilationUnit().getImports()).map(Object::toString);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return interface for a component type */
&nbsp;    String interfaceName(Stype comp){
<b class="nc">&nbsp;        String suffix = &quot;Comp&quot;;</b>
<b class="nc">&nbsp;        if(!comp.name().endsWith(suffix)) err(&quot;All components must have names that end with &#39;Comp&#39;&quot;, comp.e);</b>
&nbsp;
&nbsp;        //example: BlockComp -&gt; IBlock
<b class="nc">&nbsp;        return comp.name().substring(0, comp.name().length() - suffix.length()) + &quot;c&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return base class name for a component type */
&nbsp;    String baseName(Stype comp){
<b class="nc">&nbsp;        String suffix = &quot;Comp&quot;;</b>
<b class="nc">&nbsp;        if(!comp.name().endsWith(suffix)) err(&quot;All components must have names that end with &#39;Comp&#39;&quot;, comp.e);</b>
&nbsp;
<b class="nc">&nbsp;        return comp.name().substring(0, comp.name().length() - suffix.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable Stype interfaceToComp(Stype type){
&nbsp;        //example: IBlock -&gt; BlockComp
<b class="nc">&nbsp;        String name = type.name().substring(0, type.name().length() - 1) + &quot;Comp&quot;;</b>
<b class="nc">&nbsp;        return componentNames.get(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return all components that a entity def has */
&nbsp;    Seq&lt;Stype&gt; allComponents(Selement&lt;?&gt; type){
<b class="nc">&nbsp;        if(!defComponents.containsKey(type)){</b>
&nbsp;            //get base defs
<b class="nc">&nbsp;            Seq&lt;Stype&gt; interfaces = types(type.annotation(EntityDef.class), EntityDef::value);</b>
<b class="nc">&nbsp;            Seq&lt;Stype&gt; components = new Seq&lt;&gt;();</b>
<b class="nc">&nbsp;            for(Stype i : interfaces){</b>
<b class="nc">&nbsp;                Stype comp = interfaceToComp(i);</b>
<b class="nc">&nbsp;                if(comp != null){</b>
<b class="nc">&nbsp;                   components.add(comp);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Type &#39;&quot; + i + &quot;&#39; is not a component interface!&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            ObjectSet&lt;Stype&gt; out = new ObjectSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for(Stype comp : components){</b>
&nbsp;                //get dependencies for each def, add them
<b class="nc">&nbsp;                out.add(comp);</b>
<b class="nc">&nbsp;                out.addAll(getDependencies(comp));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            defComponents.put(type, out.toSeq());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return defComponents.get(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    Seq&lt;Stype&gt; getDependencies(Stype component){
<b class="nc">&nbsp;        if(!componentDependencies.containsKey(component)){</b>
<b class="nc">&nbsp;            ObjectSet&lt;Stype&gt; out = new ObjectSet&lt;&gt;();</b>
&nbsp;            //add base component interfaces
<b class="nc">&nbsp;            out.addAll(component.interfaces().select(this::isCompInterface).map(this::interfaceToComp));</b>
&nbsp;            //remove self interface
<b class="nc">&nbsp;            out.remove(component);</b>
&nbsp;
&nbsp;            //out now contains the base dependencies; finish constructing the tree
<b class="nc">&nbsp;            ObjectSet&lt;Stype&gt; result = new ObjectSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for(Stype type : out){</b>
<b class="nc">&nbsp;                result.add(type);</b>
<b class="nc">&nbsp;                result.addAll(getDependencies(type));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if(component.annotation(BaseComponent.class) == null){</b>
<b class="nc">&nbsp;                result.addAll(baseComponents);</b>
&nbsp;            }
&nbsp;
&nbsp;            //remove it again just in case
<b class="nc">&nbsp;            out.remove(component);</b>
<b class="nc">&nbsp;            componentDependencies.put(component, result.toSeq());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return componentDependencies.get(component);</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean isCompInterface(Stype type){
<b class="nc">&nbsp;        return interfaceToComp(type) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    String createName(Selement&lt;?&gt; elem){
<b class="nc">&nbsp;        Seq&lt;Stype&gt; comps = types(elem.annotation(EntityDef.class), EntityDef::value).map(this::interfaceToComp);</b>
<b class="nc">&nbsp;        comps.sortComparing(Selement::name);</b>
<b class="nc">&nbsp;        return comps.toString(&quot;&quot;, s -&gt; s.name().replace(&quot;Comp&quot;, &quot;&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    &lt;T extends Annotation&gt; Seq&lt;Stype&gt; types(T t, Cons&lt;T&gt; consumer){
&nbsp;        try{
<b class="nc">&nbsp;            consumer.get(t);</b>
<b class="nc">&nbsp;        }catch(MirroredTypesException e){</b>
<b class="nc">&nbsp;            return Seq.with(e.getTypeMirrors()).map(Stype::of);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Missing types.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    void skipDeprecated(TypeSpec.Builder builder){
&nbsp;        //deprecations are irrelevant in generated code
<b class="nc">&nbsp;        builder.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember(&quot;value&quot;, &quot;\&quot;deprecation\&quot;&quot;).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    class GroupDefinition{
&nbsp;        final String name;
&nbsp;        final ClassName baseType;
&nbsp;        final Seq&lt;Stype&gt; components;
&nbsp;        final boolean spatial, mapping, collides;
<b class="nc">&nbsp;        final ObjectSet&lt;Selement&gt; manualInclusions = new ObjectSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        public GroupDefinition(String name, ClassName bestType, Seq&lt;Stype&gt; components, boolean spatial, boolean mapping, boolean collides){</b>
<b class="nc">&nbsp;            this.baseType = bestType;</b>
<b class="nc">&nbsp;            this.components = components;</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.spatial = spatial;</b>
<b class="nc">&nbsp;            this.mapping = mapping;</b>
<b class="nc">&nbsp;            this.collides = collides;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString(){
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    class EntityDefinition{
&nbsp;        final Seq&lt;GroupDefinition&gt; groups;
&nbsp;        final Seq&lt;Stype&gt; components;
&nbsp;        final Seq&lt;FieldSpec&gt; fieldSpecs;
&nbsp;        final TypeSpec.Builder builder;
&nbsp;        final Selement naming;
&nbsp;        final String name;
&nbsp;        final @Nullable TypeName extend;
&nbsp;        final boolean legacy;
&nbsp;        int classID;
&nbsp;
<b class="nc">&nbsp;        public EntityDefinition(String name, Builder builder, Selement naming, TypeName extend, Seq&lt;Stype&gt; components, Seq&lt;GroupDefinition&gt; groups, Seq&lt;FieldSpec&gt; fieldSpec, boolean legacy){</b>
<b class="nc">&nbsp;            this.builder = builder;</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.naming = naming;</b>
<b class="nc">&nbsp;            this.groups = groups;</b>
<b class="nc">&nbsp;            this.components = components;</b>
<b class="nc">&nbsp;            this.extend = extend;</b>
<b class="nc">&nbsp;            this.fieldSpecs = fieldSpec;</b>
<b class="nc">&nbsp;            this.legacy = legacy;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString(){
<b class="nc">&nbsp;            return &quot;Definition{&quot; +</b>
&nbsp;            &quot;groups=&quot; + groups +
&nbsp;            &quot;components=&quot; + components +
&nbsp;            &quot;, base=&quot; + naming +
&nbsp;            &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 14:03</div>
</div>
</body>
</html>
