


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MapObjectives</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">mindustry.game</a>
</div>

<h1>Coverage Summary for Class: MapObjectives (mindustry.game)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapObjectives</td>
<td class="coverageStat">
  <span class="percent">
    36.8%
  </span>
  <span class="absValue">
    (7/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.7%
  </span>
  <span class="absValue">
    (30/52)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MapObjectives$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$BuildCountObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$CommandModeObjective</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$CoreItemObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$DestroyBlockObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (4/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$DestroyBlocksObjective</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (4/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$DestroyCoreObjective</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$DestroyUnitsObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$FlagObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (2/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Immutable</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ItemObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$LabelFlag</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$LineMarker</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.1%
  </span>
  <span class="absValue">
    (6/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$MapObjective</td>
<td class="coverageStat">
  <span class="percent">
    6.7%
  </span>
  <span class="absValue">
    (1/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (7/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Multiline</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ObjectiveMarker</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.5%
  </span>
  <span class="absValue">
    (5/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$PointMarker</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12%
  </span>
  <span class="absValue">
    (3/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$PosMarker</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ProduceObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$QuadMarker</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.6%
  </span>
  <span class="absValue">
    (7/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Researchable</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ResearchObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Second</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ShapeMarker</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (5/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$ShapeTextMarker</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.1%
  </span>
  <span class="absValue">
    (7/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Synthetic</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$TextMarker</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (4/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$TextureMarker</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (4/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$TilePos</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$TimerObjective</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.1%
  </span>
  <span class="absValue">
    (2/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$UnitCountObjective</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Unordered</td>
  </tr>
  <tr>
    <td class="name">MapObjectives$Vertices</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    33.8%
  </span>
  <span class="absValue">
    (47/139)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.7%
  </span>
  <span class="absValue">
    (112/516)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package mindustry.game;
&nbsp;
&nbsp;import arc.*;
&nbsp;import arc.func.*;
&nbsp;import arc.graphics.*;
&nbsp;import arc.graphics.g2d.*;
&nbsp;import arc.math.*;
&nbsp;import arc.math.geom.*;
&nbsp;import arc.scene.ui.layout.*;
&nbsp;import arc.struct.*;
&nbsp;import arc.util.*;
&nbsp;import mindustry.*;
&nbsp;import mindustry.content.*;
&nbsp;import mindustry.ctype.*;
&nbsp;import mindustry.game.MapObjectives.*;
&nbsp;import mindustry.gen.*;
&nbsp;import mindustry.graphics.*;
&nbsp;import mindustry.io.*;
&nbsp;import mindustry.logic.*;
&nbsp;import mindustry.type.*;
&nbsp;import mindustry.world.*;
&nbsp;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static java.lang.annotation.ElementType.*;
&nbsp;import static java.lang.annotation.RetentionPolicy.*;
&nbsp;import static mindustry.Vars.*;
&nbsp;
&nbsp;/** Handles and executes in-map objectives. */
<b class="nc">&nbsp;public class MapObjectives implements Iterable&lt;MapObjective&gt;, Eachable&lt;MapObjective&gt;{</b>
<b class="fc">&nbsp;    public static final Seq&lt;Prov&lt;? extends MapObjective&gt;&gt; allObjectiveTypes = new Seq&lt;&gt;();</b>
<b class="fc">&nbsp;    public static final Seq&lt;Prov&lt;? extends ObjectiveMarker&gt;&gt; allMarkerTypes = new Seq&lt;&gt;();</b>
<b class="fc">&nbsp;    public static final ObjectMap&lt;String, Prov&lt;? extends ObjectiveMarker&gt;&gt; markerNameToType = new ObjectMap&lt;&gt;();</b>
<b class="fc">&nbsp;    public static final Seq&lt;String&gt; allMarkerTypeNames = new Seq&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * All objectives the executor contains. Do not modify directly, ever!
&nbsp;     * @see #eachRunning(Cons)
&nbsp;     */
<b class="fc">&nbsp;    public Seq&lt;MapObjective&gt; all = new Seq&lt;&gt;(4);</b>
&nbsp;
&nbsp;    static{
<b class="fc">&nbsp;        registerObjective(</b>
&nbsp;            ResearchObjective::new,
&nbsp;            ProduceObjective::new,
&nbsp;            ItemObjective::new,
&nbsp;            CoreItemObjective::new,
&nbsp;            BuildCountObjective::new,
&nbsp;            UnitCountObjective::new,
&nbsp;            DestroyUnitsObjective::new,
&nbsp;            TimerObjective::new,
&nbsp;            DestroyBlockObjective::new,
&nbsp;            DestroyBlocksObjective::new,
&nbsp;            DestroyCoreObjective::new,
&nbsp;            CommandModeObjective::new,
&nbsp;            FlagObjective::new
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        registerMarker(</b>
&nbsp;            ShapeTextMarker::new,
&nbsp;            PointMarker::new,
&nbsp;            ShapeMarker::new,
&nbsp;            TextMarker::new,
&nbsp;            LineMarker::new,
&nbsp;            TextureMarker::new,
&nbsp;            QuadMarker::new
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        registerLegacyMarker(&quot;Minimap&quot;, PointMarker::new);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SafeVarargs
&nbsp;    public static void registerObjective(Prov&lt;? extends MapObjective&gt;... providers){
<b class="fc">&nbsp;        for(var prov : providers){</b>
<b class="fc">&nbsp;            allObjectiveTypes.add(prov);</b>
&nbsp;
<b class="fc">&nbsp;            Class&lt;? extends MapObjective&gt; type = prov.get().getClass();</b>
<b class="fc">&nbsp;            String name = type.getSimpleName().replace(&quot;Objective&quot;, &quot;&quot;);</b>
<b class="fc">&nbsp;            JsonIO.classTag(Strings.camelize(name), type);</b>
<b class="fc">&nbsp;            JsonIO.classTag(name, type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SafeVarargs
&nbsp;    public static void registerMarker(Prov&lt;? extends ObjectiveMarker&gt;... providers){
<b class="fc">&nbsp;        for(var prov : providers){</b>
<b class="fc">&nbsp;            allMarkerTypes.add(prov);</b>
&nbsp;
<b class="fc">&nbsp;            Class&lt;? extends ObjectiveMarker&gt; type = prov.get().getClass();</b>
<b class="fc">&nbsp;            String name = type.getSimpleName().replace(&quot;Marker&quot;, &quot;&quot;);</b>
<b class="fc">&nbsp;            allMarkerTypeNames.add(Strings.camelize(name));</b>
<b class="fc">&nbsp;            markerNameToType.put(name, prov);</b>
<b class="fc">&nbsp;            markerNameToType.put(Strings.camelize(name), prov);</b>
<b class="fc">&nbsp;            JsonIO.classTag(Strings.camelize(name), type);</b>
<b class="fc">&nbsp;            JsonIO.classTag(name, type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void registerLegacyMarker(String name, Prov&lt;? extends ObjectiveMarker&gt; prov) {
<b class="fc">&nbsp;        Class&lt;?&gt; type = prov.get().getClass();</b>
&nbsp;
<b class="fc">&nbsp;        markerNameToType.put(name, prov);</b>
<b class="fc">&nbsp;        markerNameToType.put(Strings.camelize(name), prov);</b>
<b class="fc">&nbsp;        JsonIO.classTag(Strings.camelize(name), type);</b>
<b class="fc">&nbsp;        JsonIO.classTag(name, type);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public MapObjectives(Seq&lt;MapObjective&gt; all){</b>
<b class="nc">&nbsp;        this.all.addAll(all);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public MapObjectives(){</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Adds all given objectives to the executor as root objectives. */
&nbsp;    public void add(MapObjective... objectives){
<b class="nc">&nbsp;        for(var objective : objectives) flatten(objective);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Recursively adds the objective and its children. */
&nbsp;    private void flatten(MapObjective objective){
<b class="nc">&nbsp;        for(var child : objective.children) flatten(child);</b>
&nbsp;
<b class="nc">&nbsp;        objective.children.clear();</b>
<b class="nc">&nbsp;        all.add(objective);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Updates all objectives this executor contains. */
&nbsp;    public void update(){
<b class="nc">&nbsp;        eachRunning(obj -&gt; {</b>
&nbsp;            //objectives cannot get completed on the client, but they do try to update for timers and such
<b class="nc">&nbsp;            if(obj.update() &amp;&amp; !net.client()){</b>
<b class="nc">&nbsp;                Call.completeObjective(all.indexOf(obj));</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public @Nullable MapObjective get(int index){
<b class="nc">&nbsp;        return index &lt; 0 || index &gt;= all.size ? null : all.get(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return Whether there are any qualified objectives at all. */
&nbsp;    public boolean any(){
<b class="nc">&nbsp;        return all.count(MapObjective::qualified) &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clear(){
<b class="nc">&nbsp;        all.clear();</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Iterates over all qualified in-map objectives. */
&nbsp;    public void eachRunning(Cons&lt;MapObjective&gt; cons){
<b class="nc">&nbsp;        all.each(MapObjective::qualified, cons);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Iterates over all qualified in-map objectives, with a filter. */
&nbsp;    public &lt;T extends MapObjective&gt; void eachRunning(Boolf&lt;? super MapObjective&gt; pred, Cons&lt;T&gt; cons){
<b class="nc">&nbsp;        all.each(obj -&gt; obj.qualified() &amp;&amp; pred.get(obj), cons);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Iterator&lt;MapObjective&gt; iterator(){
<b class="fc">&nbsp;        return all.iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void each(Cons&lt;? super MapObjective&gt; cons){
<b class="nc">&nbsp;        all.each(cons);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Base abstract class for any in-map objective. */
<b class="fc">&nbsp;    public static abstract class MapObjective{</b>
&nbsp;        public boolean hidden;
&nbsp;        public @Nullable @Multiline String details;
<b class="fc">&nbsp;        public @Unordered String[] flagsAdded = {};</b>
<b class="fc">&nbsp;        public @Unordered String[] flagsRemoved = {};</b>
<b class="fc">&nbsp;        public ObjectiveMarker[] markers = {};</b>
&nbsp;
&nbsp;        /** The parents of this objective. All parents must be done in order for this to be updated. */
<b class="fc">&nbsp;        public transient Seq&lt;MapObjective&gt; parents = new Seq&lt;&gt;(2);</b>
&nbsp;        /** Temporary container to store references since this class is static. Will immediately be flattened. */
<b class="fc">&nbsp;        private transient final Seq&lt;MapObjective&gt; children = new Seq&lt;&gt;(2);</b>
&nbsp;
&nbsp;        /** For the objectives UI dialog. Do not modify directly! */
<b class="fc">&nbsp;        public transient int editorX = -1, editorY = -1;</b>
&nbsp;
&nbsp;        /** Whether this objective has been done yet. This is internally set. */
&nbsp;        private boolean completed;
&nbsp;        /** Internal value. Do not modify! */
&nbsp;        private transient boolean depFinished;
&nbsp;
&nbsp;        /** @return True if this objective is done and should be removed from the executor. */
&nbsp;        public abstract boolean update();
&nbsp;
&nbsp;        /** Reset internal state, if any. */
<b class="nc">&nbsp;        public void reset(){}</b>
&nbsp;
&nbsp;        /** Called once after {@link #update()} returns true, before this objective is removed. */
&nbsp;        public void done(){
<b class="nc">&nbsp;            state.rules.objectiveFlags.removeAll(flagsRemoved);</b>
<b class="nc">&nbsp;            state.rules.objectiveFlags.addAll(flagsAdded);</b>
<b class="nc">&nbsp;            completed = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return True if all {@link #parents} are completed, rendering this objective able to execute. */
&nbsp;        public final boolean dependencyFinished(){
<b class="nc">&nbsp;            if(depFinished) return true;</b>
&nbsp;
<b class="nc">&nbsp;            for(var parent : parents){</b>
<b class="nc">&nbsp;                if(!parent.isCompleted()) return false;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return depFinished = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return True if this objective is done (practically, has been removed from the executor). */
&nbsp;        public final boolean isCompleted(){
<b class="nc">&nbsp;            return completed;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return Whether this objective should run at all. */
&nbsp;        public boolean qualified(){
<b class="nc">&nbsp;            return !completed &amp;&amp; dependencyFinished();</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the given child&#39;s parents added with this, for chaining operations. */
&nbsp;        public MapObjective child(MapObjective child){
<b class="nc">&nbsp;            child.parents.add(this);</b>
<b class="nc">&nbsp;            children.add(child);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the given parent added to this objective&#39;s parents, for chaining operations. */
&nbsp;        public MapObjective parent(MapObjective parent){
<b class="nc">&nbsp;            parents.add(parent);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the details message assigned to, for chaining operations. */
&nbsp;        public MapObjective details(String details){
<b class="nc">&nbsp;            this.details = details;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the added-flags assigned to, for chaining operations. */
&nbsp;        public MapObjective flagsAdded(String... flagsAdded){
<b class="nc">&nbsp;            this.flagsAdded = flagsAdded;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the removed-flags assigned to, for chaining operations. */
&nbsp;        public MapObjective flagsRemoved(String... flagsRemoved){
<b class="nc">&nbsp;            this.flagsRemoved = flagsRemoved;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return This objective, with the markers assigned to, for chaining operations. */
&nbsp;        public MapObjective markers(ObjectiveMarker... markers){
<b class="nc">&nbsp;            this.markers = markers;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return Basic mission display text. If null, falls back to standard text. */
&nbsp;        public @Nullable String text(){
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return Details that appear upon click. */
&nbsp;        public @Nullable String details(){
<b class="nc">&nbsp;            return details;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return The localized type-name of this objective, defaulting to the class simple name without the &quot;Objective&quot; prefix. */
&nbsp;        public String typeName(){
<b class="nc">&nbsp;            String className = getClass().getSimpleName().replace(&quot;Objective&quot;, &quot;&quot;);</b>
<b class="nc">&nbsp;            return Core.bundle == null ? className : Core.bundle.get(&quot;objective.&quot; + className.toLowerCase() + &quot;.name&quot;, className);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Research a specific piece of content in the tech tree. */
&nbsp;    public static class ResearchObjective extends MapObjective{
<b class="fc">&nbsp;        public @Researchable UnlockableContent content = Items.copper;</b>
&nbsp;
<b class="nc">&nbsp;        public ResearchObjective(UnlockableContent content){</b>
<b class="nc">&nbsp;            this.content = content;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public ResearchObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return content.unlocked();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.research&quot;, content.emoji(), content.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Produce a specific piece of content in the tech tree (essentially research with different text). */
&nbsp;    public static class ProduceObjective extends MapObjective{
<b class="fc">&nbsp;        public @Researchable UnlockableContent content = Items.copper;</b>
&nbsp;
<b class="nc">&nbsp;        public ProduceObjective(UnlockableContent content){</b>
<b class="nc">&nbsp;            this.content = content;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public ProduceObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return content.unlocked();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.produce&quot;, content.emoji(), content.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Have a certain amount of item in your core. */
&nbsp;    public static class ItemObjective extends MapObjective{
<b class="fc">&nbsp;        public Item item = Items.copper;</b>
<b class="fc">&nbsp;        public int amount = 1;</b>
&nbsp;
<b class="nc">&nbsp;        public ItemObjective(Item item, int amount){</b>
<b class="nc">&nbsp;            this.item = item;</b>
<b class="nc">&nbsp;            this.amount = amount;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public ItemObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.rules.defaultTeam.items().has(item, amount);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.item&quot;, state.rules.defaultTeam.items().get(item), amount, item.emoji(), item.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Get a certain item in your core (through a block, not manually.) */
&nbsp;    public static class CoreItemObjective extends MapObjective{
<b class="fc">&nbsp;        public Item item = Items.copper;</b>
<b class="fc">&nbsp;        public int amount = 2;</b>
&nbsp;
<b class="nc">&nbsp;        public CoreItemObjective(Item item, int amount){</b>
<b class="nc">&nbsp;            this.item = item;</b>
<b class="nc">&nbsp;            this.amount = amount;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public CoreItemObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.stats.coreItemCount.get(item) &gt;= amount;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.coreitem&quot;, state.stats.coreItemCount.get(item), amount, item.emoji(), item.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Build a certain amount of a block. */
&nbsp;    public static class BuildCountObjective extends MapObjective{
<b class="fc">&nbsp;        public @Synthetic Block block = Blocks.conveyor;</b>
<b class="fc">&nbsp;        public int count = 1;</b>
&nbsp;
<b class="nc">&nbsp;        public BuildCountObjective(Block block, int count){</b>
<b class="nc">&nbsp;            this.block = block;</b>
<b class="nc">&nbsp;            this.count = count;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public BuildCountObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.stats.placedBlockCount.get(block, 0) &gt;= count;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.build&quot;, count - state.stats.placedBlockCount.get(block, 0), block.emoji(), block.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Produce a certain amount of a unit. */
&nbsp;    public static class UnitCountObjective extends MapObjective{
<b class="fc">&nbsp;        public UnitType unit = UnitTypes.dagger;</b>
<b class="fc">&nbsp;        public int count = 1;</b>
&nbsp;
<b class="nc">&nbsp;        public UnitCountObjective(UnitType unit, int count){</b>
<b class="nc">&nbsp;            this.unit = unit;</b>
<b class="nc">&nbsp;            this.count = count;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public UnitCountObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.rules.defaultTeam.data().countType(unit) &gt;= count;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.buildunit&quot;, count - state.rules.defaultTeam.data().countType(unit), unit.emoji(), unit.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Produce a certain amount of units. */
&nbsp;    public static class DestroyUnitsObjective extends MapObjective{
<b class="fc">&nbsp;        public int count = 1;</b>
&nbsp;
<b class="nc">&nbsp;        public DestroyUnitsObjective(int count){</b>
<b class="nc">&nbsp;            this.count = count;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public DestroyUnitsObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.stats.enemyUnitsDestroyed &gt;= count;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.destroyunits&quot;, count - state.stats.enemyUnitsDestroyed);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class TimerObjective extends MapObjective{
&nbsp;        public @Multiline String text;
<b class="fc">&nbsp;        public @Second float duration = 60f * 30f;</b>
&nbsp;
&nbsp;        protected float countup;
&nbsp;
<b class="nc">&nbsp;        public TimerObjective(String text, float duration){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.duration = duration;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public TimerObjective(){</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return (countup += Time.delta) &gt;= duration * state.rules.objectiveTimerMultiplier;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void reset(){
<b class="nc">&nbsp;            countup = 0f;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            if(text != null){</b>
<b class="nc">&nbsp;                int i = (int)((duration * state.rules.objectiveTimerMultiplier - countup) / 60f);</b>
<b class="nc">&nbsp;                StringBuilder timeString = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;                int m = i / 60;</b>
<b class="nc">&nbsp;                int s = i % 60;</b>
<b class="nc">&nbsp;                if(m &gt; 0){</b>
<b class="nc">&nbsp;                    timeString.append(m);</b>
<b class="nc">&nbsp;                    timeString.append(&quot;:&quot;);</b>
<b class="nc">&nbsp;                    if(s &lt; 10){</b>
<b class="nc">&nbsp;                        timeString.append(&quot;0&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                timeString.append(s);</b>
&nbsp;
<b class="nc">&nbsp;                if(text.startsWith(&quot;@&quot;)){</b>
<b class="nc">&nbsp;                    if(state.mapLocales.containsProperty(text.substring(1))){</b>
&nbsp;                        try{
<b class="nc">&nbsp;                            return state.mapLocales.getFormatted(text.substring(1), timeString.toString());</b>
<b class="nc">&nbsp;                        }catch(IllegalArgumentException e){</b>
&nbsp;                            //illegal text.
<b class="nc">&nbsp;                            text = &quot;&quot;;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return Core.bundle.format(text.substring(1), timeString.toString());</b>
&nbsp;                }else{
&nbsp;                    try{
<b class="nc">&nbsp;                        return Core.bundle.formatString(text, timeString.toString());</b>
<b class="nc">&nbsp;                    }catch(IllegalArgumentException e){</b>
&nbsp;                        //illegal text.
<b class="nc">&nbsp;                        text = &quot;&quot;;</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class DestroyBlockObjective extends MapObjective{
<b class="fc">&nbsp;        public Point2 pos = new Point2();</b>
<b class="fc">&nbsp;        public Team team = Team.crux;</b>
<b class="fc">&nbsp;        public @Synthetic Block block = Blocks.router;</b>
&nbsp;
<b class="nc">&nbsp;        public DestroyBlockObjective(Block block, int x, int y, Team team){</b>
<b class="nc">&nbsp;            this.block = block;</b>
<b class="nc">&nbsp;            this.team = team;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public DestroyBlockObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            var build = world.build(pos.x, pos.y);</b>
<b class="nc">&nbsp;            return build == null || build.team != team || build.block != block;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.destroyblock&quot;, block.emoji(), block.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class DestroyBlocksObjective extends MapObjective{
<b class="fc">&nbsp;        public @Unordered Point2[] positions = {};</b>
<b class="fc">&nbsp;        public Team team = Team.crux;</b>
<b class="fc">&nbsp;        public @Synthetic Block block = Blocks.router;</b>
&nbsp;
<b class="nc">&nbsp;        public DestroyBlocksObjective(Block block, Team team, Point2... positions){</b>
<b class="nc">&nbsp;            this.block = block;</b>
<b class="nc">&nbsp;            this.team = team;</b>
<b class="nc">&nbsp;            this.positions = positions;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public DestroyBlocksObjective(){}</b>
&nbsp;
&nbsp;        public int progress(){
<b class="nc">&nbsp;            int count = 0;</b>
<b class="nc">&nbsp;            for(var pos : positions){</b>
<b class="nc">&nbsp;                var build = world.build(pos.x, pos.y);</b>
<b class="nc">&nbsp;                if(build == null || build.team != team || build.block != block){</b>
<b class="nc">&nbsp;                    count ++;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return count;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return progress() &gt;= positions.length;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.format(&quot;objective.destroyblocks&quot;, progress(), positions.length, block.emoji(), block.localizedName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Command any unit to do anything. Always compete in headless mode. */
<b class="fc">&nbsp;    public static class CommandModeObjective extends MapObjective{</b>
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return headless || control.input.selectedUnits.contains(u -&gt; u.isCommandable() &amp;&amp; u.command().hasCommand());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.get(&quot;objective.command&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Wait until a logic flag is set. */
&nbsp;    public static class FlagObjective extends MapObjective{
<b class="fc">&nbsp;        public String flag = &quot;flag&quot;;</b>
&nbsp;        public @Multiline String text;
&nbsp;
<b class="nc">&nbsp;        public FlagObjective(String flag, String text){</b>
<b class="nc">&nbsp;            this.flag = flag;</b>
<b class="nc">&nbsp;            this.text = text;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public FlagObjective(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.rules.objectiveFlags.contains(flag);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            if(text == null) return null;</b>
&nbsp;
<b class="nc">&nbsp;            if(text.startsWith(&quot;@&quot;)){</b>
<b class="nc">&nbsp;                if(state.mapLocales.containsProperty(text.substring(1))) return state.mapLocales.getProperty(text.substring(1));</b>
<b class="nc">&nbsp;                return Core.bundle.get(text.substring(1));</b>
&nbsp;            }else{
<b class="nc">&nbsp;                return text;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Destroy all enemy core(s). */
<b class="fc">&nbsp;    public static class DestroyCoreObjective extends MapObjective{</b>
&nbsp;        @Override
&nbsp;        public boolean update(){
<b class="nc">&nbsp;            return state.rules.waveTeam.cores().size == 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String text(){
<b class="nc">&nbsp;            return Core.bundle.get(&quot;objective.destroycore&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Marker used for drawing various content to indicate something along with an objective. Mostly used as UI overlay.  */
<b class="fc">&nbsp;    public static abstract class ObjectiveMarker{</b>
&nbsp;        /** Internal use only! Do not access. */
&nbsp;        public transient int arrayIndex;
&nbsp;
&nbsp;        /** Whether to display marker in the world. */
<b class="fc">&nbsp;        public boolean world = true;</b>
&nbsp;        /** Whether to display marker on minimap. */
<b class="fc">&nbsp;        public boolean minimap = false;</b>
&nbsp;        /** Whether to scale marker corresponding to player&#39;s zoom level. */
<b class="fc">&nbsp;        public boolean autoscale = false;</b>
&nbsp;        /** On which z-sorting layer is marker drawn. */
<b class="fc">&nbsp;        protected float drawLayer = Layer.overlayUI;</b>
&nbsp;
<b class="nc">&nbsp;        public void draw(float scaleFactor){}</b>
&nbsp;
&nbsp;        /** Control marker with world processor code. Ignores NaN (null) values. */
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            if(Double.isNaN(p1)) return;</b>
&nbsp;
<b class="nc">&nbsp;            switch(type){</b>
<b class="nc">&nbsp;                case world -&gt; world = !Mathf.equal((float)p1, 0f);</b>
<b class="nc">&nbsp;                case minimap -&gt; minimap = !Mathf.equal((float)p1, 0f);</b>
<b class="nc">&nbsp;                case autoscale -&gt; autoscale = !Mathf.equal((float)p1, 0f);</b>
<b class="nc">&nbsp;                case drawLayer -&gt; drawLayer = (float)p1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public void setText(String text, boolean fetch){}</b>
&nbsp;
<b class="nc">&nbsp;        public void setTexture(String textureName){}</b>
&nbsp;
&nbsp;        /** @return The localized type-name of this objective, defaulting to the class simple name without the &quot;Marker&quot; prefix. */
&nbsp;        public String typeName(){
<b class="nc">&nbsp;            String className = getClass().getSimpleName().replace(&quot;Marker&quot;, &quot;&quot;);</b>
<b class="nc">&nbsp;            return Core.bundle == null ? className : Core.bundle.get(&quot;marker.&quot; + className.toLowerCase() + &quot;.name&quot;, className);</b>
&nbsp;        }
&nbsp;
&nbsp;        public static String fetchText(String text){
<b class="nc">&nbsp;            if(text == null) return &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;            if(text.startsWith(&quot;@&quot;)){</b>
<b class="nc">&nbsp;                String key = text.substring(1);</b>
&nbsp;
<b class="nc">&nbsp;                if(mobile){</b>
<b class="nc">&nbsp;                    return state.mapLocales.containsProperty(key + &quot;.mobile&quot;) ?</b>
<b class="nc">&nbsp;                    state.mapLocales.getProperty(key + &quot;.mobile&quot;) :</b>
<b class="nc">&nbsp;                    Core.bundle.get(key + &quot;.mobile&quot;, Core.bundle.get(key));</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    return state.mapLocales.containsProperty(key) ?</b>
<b class="nc">&nbsp;                    state.mapLocales.getProperty(key) :</b>
<b class="nc">&nbsp;                    Core.bundle.get(key);</b>
&nbsp;                }
&nbsp;            }else{
<b class="nc">&nbsp;                return text;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** A marker that has a position in the world in world coordinates. */
<b class="fc">&nbsp;    public static abstract class PosMarker extends ObjectiveMarker{</b>
&nbsp;        /** Position of marker, in world coordinates */
<b class="fc">&nbsp;        public @TilePos Vec2 pos = new Vec2();</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                if(type == LMarkerControl.pos){</b>
<b class="nc">&nbsp;                    pos.x = (float)p1 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                if(type == LMarkerControl.pos){</b>
<b class="nc">&nbsp;                    pos.y = (float)p2 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays text above a shape. */
&nbsp;    public static class ShapeTextMarker extends PosMarker{
<b class="fc">&nbsp;        public @Multiline String text = &quot;frog&quot;;</b>
<b class="fc">&nbsp;        public float fontSize = 1f, textHeight = 7f;</b>
<b class="fc">&nbsp;        public @LabelFlag byte flags = WorldLabel.flagBackground | WorldLabel.flagOutline;</b>
&nbsp;
<b class="fc">&nbsp;        public float radius = 6f, rotation = 0f;</b>
<b class="fc">&nbsp;        public int sides = 4;</b>
<b class="fc">&nbsp;        public Color color = Color.valueOf(&quot;ffd37f&quot;);</b>
&nbsp;
&nbsp;        // Cached localized text.
&nbsp;        private transient String fetchedText;
&nbsp;
<b class="nc">&nbsp;        public ShapeTextMarker(String text, float x, float y){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ShapeTextMarker(String text, float x, float y, float radius){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.radius = radius;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ShapeTextMarker(String text, float x, float y, float radius, float rotation){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.radius = radius;</b>
<b class="nc">&nbsp;            this.rotation = rotation;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ShapeTextMarker(String text, float x, float y, float radius, float rotation, float textHeight){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.radius = radius;</b>
<b class="nc">&nbsp;            this.rotation = rotation;</b>
<b class="nc">&nbsp;            this.textHeight = textHeight;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public ShapeTextMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
&nbsp;            //in case some idiot decides to make 9999999 sides and freeze the game
<b class="nc">&nbsp;            int sides = Math.min(this.sides, 300);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            Lines.stroke(3f * scaleFactor, Pal.gray);</b>
<b class="nc">&nbsp;            Lines.poly(pos.x, pos.y, sides, (radius + 1f) * scaleFactor, rotation);</b>
<b class="nc">&nbsp;            Lines.stroke(scaleFactor, color);</b>
<b class="nc">&nbsp;            Lines.poly(pos.x, pos.y, sides, (radius + 1f) * scaleFactor, rotation);</b>
<b class="nc">&nbsp;            Draw.reset();</b>
&nbsp;
<b class="nc">&nbsp;            if(fetchedText == null){</b>
<b class="nc">&nbsp;                fetchedText = fetchText(text);</b>
&nbsp;            }
&nbsp;
&nbsp;            // font size cannot be 0
<b class="nc">&nbsp;            if(Mathf.equal(fontSize, 0f)) return;</b>
&nbsp;
<b class="nc">&nbsp;            WorldLabel.drawAt(fetchedText, pos.x, pos.y + radius * scaleFactor + textHeight * scaleFactor, drawLayer, flags, fontSize * scaleFactor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case fontSize -&gt; fontSize = (float)p1;</b>
<b class="nc">&nbsp;                    case textHeight -&gt; textHeight = (float)p1;</b>
&nbsp;                    case labelFlags -&gt; {
<b class="nc">&nbsp;                        if(!Mathf.equal((float)p1, 0f)){</b>
<b class="nc">&nbsp;                            flags |= WorldLabel.flagBackground;</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            flags &amp;= ~WorldLabel.flagBackground;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    case radius -&gt; radius = (float)p1;</b>
<b class="nc">&nbsp;                    case rotation -&gt; rotation = (float)p1;</b>
<b class="nc">&nbsp;                    case color -&gt; color.fromDouble(p1);</b>
<b class="nc">&nbsp;                    case shape -&gt; sides = (int)p1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
&nbsp;                    case labelFlags -&gt; {
<b class="nc">&nbsp;                        if(!Mathf.equal((float)p2, 0f)){</b>
<b class="nc">&nbsp;                            flags |= WorldLabel.flagOutline;</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            flags &amp;= ~WorldLabel.flagOutline;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setText(String text, boolean fetch){
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            if(fetch){</b>
<b class="nc">&nbsp;                fetchedText = fetchText(this.text);</b>
&nbsp;            }else{
<b class="nc">&nbsp;                fetchedText = this.text;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays a circle in the world. */
&nbsp;    public static class PointMarker extends PosMarker{
<b class="fc">&nbsp;        public float radius = 5f, stroke = 11f;</b>
<b class="fc">&nbsp;        public Color color = Color.valueOf(&quot;f25555&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        public PointMarker(int x, int y){</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PointMarker(int x, int y, Color color){</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.color = color;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PointMarker(int x, int y, float radius, float stroke, Color color){</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.stroke = stroke;</b>
<b class="nc">&nbsp;            this.radius = radius;</b>
<b class="nc">&nbsp;            this.color = color;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public PointMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
<b class="nc">&nbsp;            float rad = radius * tilesize * scaleFactor;</b>
<b class="nc">&nbsp;            float fin = Interp.pow2Out.apply((Time.globalTime / 100f) % 1f);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            Lines.stroke(Scl.scl((1f - fin) * stroke + 0.1f), color);</b>
<b class="nc">&nbsp;            Lines.circle(pos.x, pos.y, rad * fin);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.reset();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case radius -&gt; radius = (float)p1;</b>
<b class="nc">&nbsp;                    case stroke -&gt; stroke = (float)p1;</b>
<b class="nc">&nbsp;                    case color -&gt; color.fromDouble(p1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays a shape with an outline and color. */
&nbsp;    public static class ShapeMarker extends PosMarker{
<b class="fc">&nbsp;        public float radius = 8f, rotation = 0f, stroke = 1f, startAngle = 0f, endAngle = 360f;</b>
<b class="fc">&nbsp;        public boolean fill = false, outline = true;</b>
<b class="fc">&nbsp;        public int sides = 4;</b>
<b class="fc">&nbsp;        public Color color = Color.valueOf(&quot;ffd37f&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        public ShapeMarker(float x, float y){</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public ShapeMarker(float x, float y, float radius, float rotation){</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.radius = radius;</b>
<b class="nc">&nbsp;            this.rotation = rotation;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public ShapeMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
&nbsp;            //in case some idiot decides to make 9999999 sides and freeze the game
<b class="nc">&nbsp;            int sides = Math.min(this.sides, 200);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            if(!fill){</b>
<b class="nc">&nbsp;                if(outline){</b>
<b class="nc">&nbsp;                    Lines.stroke((stroke + 2f) * scaleFactor, Pal.gray);</b>
<b class="nc">&nbsp;                    Lines.poly(pos.x, pos.y, sides, (radius + 1f) * scaleFactor, rotation + startAngle, rotation + endAngle);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Lines.stroke(stroke * scaleFactor, color);</b>
<b class="nc">&nbsp;                Lines.poly(pos.x, pos.y, sides, (radius + 1f) * scaleFactor, rotation + startAngle, rotation + endAngle);</b>
&nbsp;            }else{
<b class="nc">&nbsp;                Draw.color(color);</b>
<b class="nc">&nbsp;                if (startAngle &lt; endAngle){</b>
<b class="nc">&nbsp;                    Fill.arc(pos.x, pos.y, radius * scaleFactor, (endAngle - startAngle) / 360f, rotation + startAngle, sides);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    Fill.arc(pos.x, pos.y, radius * scaleFactor, (startAngle - endAngle) / 360f, rotation + endAngle, sides);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Draw.reset();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case radius -&gt; radius = (float)p1;</b>
<b class="nc">&nbsp;                    case stroke -&gt; stroke = (float)p1;</b>
<b class="nc">&nbsp;                    case rotation -&gt; rotation = (float)p1;</b>
<b class="nc">&nbsp;                    case color -&gt; color.fromDouble(p1);</b>
<b class="nc">&nbsp;                    case shape -&gt; sides = (int)p1;</b>
<b class="nc">&nbsp;                    case arc -&gt; startAngle = (float)p1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case shape -&gt; fill = !Mathf.equal((float)p2, 0f);</b>
<b class="nc">&nbsp;                    case arc -&gt; endAngle = (float)p2;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p3)){</b>
<b class="nc">&nbsp;                if(type == LMarkerControl.shape){</b>
<b class="nc">&nbsp;                    outline = !Mathf.equal((float)p3, 0f);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays text at a location. */
&nbsp;    public static class TextMarker extends PosMarker{
<b class="fc">&nbsp;        public @Multiline String text = &quot;uwu&quot;;</b>
<b class="fc">&nbsp;        public float fontSize = 1f;</b>
<b class="fc">&nbsp;        public @LabelFlag byte flags = WorldLabel.flagBackground | WorldLabel.flagOutline;</b>
&nbsp;        // Cached localized text.
&nbsp;        private transient String fetchedText;
&nbsp;
<b class="nc">&nbsp;        public TextMarker(String text, float x, float y, float fontSize, byte flags){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.fontSize = fontSize;</b>
<b class="nc">&nbsp;            this.flags = flags;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TextMarker(String text, float x, float y){</b>
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public TextMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
&nbsp;            // font size cannot be 0
<b class="nc">&nbsp;            if(Mathf.equal(fontSize, 0f)) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(fetchedText == null){</b>
<b class="nc">&nbsp;                fetchedText = fetchText(text);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            WorldLabel.drawAt(fetchedText, pos.x, pos.y, drawLayer, flags, fontSize * scaleFactor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case fontSize -&gt; fontSize = (float)p1;</b>
&nbsp;                    case labelFlags -&gt; {
<b class="nc">&nbsp;                        if(!Mathf.equal((float)p1, 0f)){</b>
<b class="nc">&nbsp;                            flags |= WorldLabel.flagBackground;</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            flags &amp;= ~WorldLabel.flagBackground;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
&nbsp;                    case labelFlags -&gt; {
<b class="nc">&nbsp;                        if(!Mathf.equal((float)p2, 0f)){</b>
<b class="nc">&nbsp;                            flags |= WorldLabel.flagOutline;</b>
&nbsp;                        }else{
<b class="nc">&nbsp;                            flags &amp;= ~WorldLabel.flagOutline;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setText(String text, boolean fetch){
<b class="nc">&nbsp;            this.text = text;</b>
<b class="nc">&nbsp;            if(fetch){</b>
<b class="nc">&nbsp;                fetchedText = fetchText(this.text);</b>
&nbsp;            }else{
<b class="nc">&nbsp;                fetchedText = this.text;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays a line from pos1 to pos2. */
&nbsp;    public static class LineMarker extends PosMarker{
<b class="fc">&nbsp;        public @TilePos Vec2 endPos = new Vec2();</b>
<b class="fc">&nbsp;        public float stroke = 1f;</b>
<b class="fc">&nbsp;        public boolean outline = true;</b>
<b class="fc">&nbsp;        public Color color1 = Color.valueOf(&quot;ffd37f&quot;);</b>
<b class="fc">&nbsp;        public Color color2 = Color.valueOf(&quot;ffd37f&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        public LineMarker(float x1, float y1, float x2, float y2, float stroke){</b>
<b class="nc">&nbsp;            this.stroke = stroke;</b>
<b class="nc">&nbsp;            this.pos.set(x1, y1);</b>
<b class="nc">&nbsp;            this.endPos.set(x2, y2);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public LineMarker(float x1, float y1, float x2, float y2){</b>
<b class="nc">&nbsp;            this.pos.set(x1, y1);</b>
<b class="nc">&nbsp;            this.endPos.set(x2, y2);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public LineMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            if(outline){</b>
<b class="nc">&nbsp;                Lines.stroke((stroke + 2f) * scaleFactor, Pal.gray);</b>
<b class="nc">&nbsp;                Lines.line(pos.x, pos.y, endPos.x, endPos.y);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Lines.stroke(stroke * scaleFactor, Color.white);</b>
<b class="nc">&nbsp;            Lines.line(pos.x, pos.y, color1, endPos.x, endPos.y, color2);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case endPos -&gt; endPos.x = (float)p1 * tilesize;</b>
<b class="nc">&nbsp;                    case stroke -&gt; stroke = (float)p1;</b>
<b class="nc">&nbsp;                    case color -&gt; color1.set(color2.fromDouble(p1));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case endPos -&gt; endPos.y = (float)p2 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1) &amp;&amp; !Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch (type){</b>
<b class="nc">&nbsp;                    case posi -&gt; ((int)p1 == 0 ? pos : (int)p1 == 1 ? endPos : Tmp.v1).x = (float)p2 * tilesize;</b>
<b class="nc">&nbsp;                    case colori -&gt; ((int)p1 == 0 ? color1 : (int)p1 == 1 ? color2 : Tmp.c1).fromDouble(p2);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1) &amp;&amp; !Double.isNaN(p3)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case posi -&gt; ((int)p1 == 0 ? pos : (int)p1 == 1 ? endPos : Tmp.v1).y = (float)p3 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Displays a texture with specified name. */
&nbsp;    public static class TextureMarker extends PosMarker{
<b class="fc">&nbsp;        public float rotation = 0f, width = 0f, height = 0f; // Zero width/height scales marker to original texture&#39;s size</b>
<b class="fc">&nbsp;        public String textureName = &quot;&quot;;</b>
<b class="fc">&nbsp;        public Color color = Color.white.cpy();</b>
&nbsp;
&nbsp;        private transient TextureRegion fetchedRegion;
&nbsp;
<b class="nc">&nbsp;        public TextureMarker(String textureName, float x, float y, float width, float height){</b>
<b class="nc">&nbsp;            this.textureName = textureName;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
<b class="nc">&nbsp;            this.width = width;</b>
<b class="nc">&nbsp;            this.height = height;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TextureMarker(String textureName, float x, float y){</b>
<b class="nc">&nbsp;            this.textureName = textureName;</b>
<b class="nc">&nbsp;            this.pos.set(x, y);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public TextureMarker(){}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case rotation -&gt; rotation = (float)p1;</b>
<b class="nc">&nbsp;                    case textureSize -&gt; width = (float)p1 * tilesize;</b>
<b class="nc">&nbsp;                    case color -&gt; color.fromDouble(p1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case textureSize -&gt; height = (float)p2 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
<b class="nc">&nbsp;            if(textureName.isEmpty()) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(fetchedRegion == null) setTexture(textureName);</b>
&nbsp;
&nbsp;            // Zero width/height scales marker to original texture&#39;s size
<b class="nc">&nbsp;            if(Mathf.equal(width, 0f)) width = fetchedRegion.width * fetchedRegion.scl() * Draw.xscl;</b>
<b class="nc">&nbsp;            if(Mathf.equal(height, 0f)) height = fetchedRegion.height * fetchedRegion.scl() * Draw.yscl;</b>
&nbsp;
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            Draw.color(color);</b>
<b class="nc">&nbsp;            Draw.rect(fetchedRegion, pos.x, pos.y, width * scaleFactor, height * scaleFactor, rotation);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setTexture(String textureName){
<b class="nc">&nbsp;            this.textureName = textureName;</b>
&nbsp;
<b class="nc">&nbsp;            if(headless) return;</b>
<b class="nc">&nbsp;            if(fetchedRegion == null) fetchedRegion = new TextureRegion();</b>
<b class="nc">&nbsp;            lookupRegion(textureName, fetchedRegion);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static class QuadMarker extends ObjectiveMarker{
<b class="fc">&nbsp;        public String textureName = &quot;white&quot;;</b>
<b class="fc">&nbsp;        public @Vertices float[] vertices = new float[24];</b>
<b class="fc">&nbsp;        private boolean mapRegion = true;</b>
&nbsp;
&nbsp;        private transient TextureRegion fetchedRegion;
&nbsp;
<b class="fc">&nbsp;        public QuadMarker() {</b>
<b class="fc">&nbsp;            for(int i = 0; i &lt; 4; i++){</b>
<b class="fc">&nbsp;                vertices[i * 6 + 2] = Color.white.toFloatBits();</b>
<b class="fc">&nbsp;                vertices[i * 6 + 5] = Color.clearFloatBits;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(float scaleFactor){
<b class="nc">&nbsp;            if(fetchedRegion == null) setTexture(textureName);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.z(drawLayer);</b>
<b class="nc">&nbsp;            Draw.vert(fetchedRegion.texture, vertices, 0, vertices.length);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void control(LMarkerControl type, double p1, double p2, double p3){
<b class="nc">&nbsp;            super.control(type, p1, p2, p3);</b>
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1)){</b>
<b class="nc">&nbsp;                switch(type){</b>
&nbsp;                    case color -&gt; {
<b class="nc">&nbsp;                        float col = Tmp.c1.fromDouble(p1).toFloatBits();</b>
<b class="nc">&nbsp;                        for(int i = 0; i &lt; 4; i++) vertices[i * 6 + 2] = col;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    case pos -&gt; vertices[0] = (float)p1 * tilesize;</b>
<b class="nc">&nbsp;                    case posi -&gt; setPos((int)p1, p2, p3);</b>
<b class="nc">&nbsp;                    case uvi -&gt; setUv((int)p1, p2, p3);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case pos -&gt; vertices[1] = (float)p1 * tilesize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!Double.isNaN(p1) &amp;&amp; !Double.isNaN(p2)){</b>
<b class="nc">&nbsp;                switch(type){</b>
<b class="nc">&nbsp;                    case colori -&gt; setColor((int)p1, p2);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setTexture(String textureName){
<b class="nc">&nbsp;            this.textureName = textureName;</b>
&nbsp;
<b class="nc">&nbsp;            boolean firstUpdate = fetchedRegion == null;</b>
&nbsp;
<b class="nc">&nbsp;            if(fetchedRegion == null) fetchedRegion = new TextureRegion();</b>
<b class="nc">&nbsp;            Tmp.tr1.set(fetchedRegion);</b>
&nbsp;
<b class="nc">&nbsp;            lookupRegion(textureName, fetchedRegion);</b>
&nbsp;
<b class="nc">&nbsp;            if(firstUpdate){</b>
<b class="nc">&nbsp;                if(mapRegion){</b>
<b class="nc">&nbsp;                    mapRegion = false;</b>
&nbsp;
&nbsp;                    // possibly from the editor, we need to clamp the values
<b class="nc">&nbsp;                    for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;                        vertices[i * 6 + 3] = Mathf.map(Mathf.clamp(vertices[i * 6 + 3]), fetchedRegion.u, fetchedRegion.u2);</b>
<b class="nc">&nbsp;                        vertices[i * 6 + 4] = Mathf.map(1 - Mathf.clamp(vertices[i * 6 + 4]), fetchedRegion.v, fetchedRegion.v2);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }else{
<b class="nc">&nbsp;                for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;                    vertices[i * 6 + 3] = Mathf.map(vertices[i * 6 + 3], Tmp.tr1.u, Tmp.tr1.u2, fetchedRegion.u, fetchedRegion.u2);</b>
<b class="nc">&nbsp;                    vertices[i * 6 + 4] = Mathf.map(vertices[i * 6 + 4], Tmp.tr1.v, Tmp.tr1.v2, fetchedRegion.v, fetchedRegion.v2);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void setPos(int i, double x, double y){
<b class="nc">&nbsp;            if(i &gt;= 0 &amp;&amp; i &lt; 4){</b>
<b class="nc">&nbsp;                if(!Double.isNaN(x)) vertices[i * 6] = (float)x * tilesize;</b>
<b class="nc">&nbsp;                if(!Double.isNaN(y)) vertices[i * 6 + 1] = (float)y * tilesize;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void setColor(int i, double c){
<b class="nc">&nbsp;            if(i &gt;= 0 &amp;&amp; i &lt; 4){</b>
<b class="nc">&nbsp;                vertices[i * 6 + 2] = Tmp.c1.fromDouble(c).toFloatBits();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void setUv(int i, double u, double v){
<b class="nc">&nbsp;            if(i &gt;= 0 &amp;&amp; i &lt; 4){</b>
<b class="nc">&nbsp;                if(fetchedRegion == null) setTexture(textureName);</b>
&nbsp;
<b class="nc">&nbsp;                if(!Double.isNaN(u)) vertices[i * 6 + 3] = Mathf.map(Mathf.clamp((float)u), fetchedRegion.u, fetchedRegion.u2);</b>
<b class="nc">&nbsp;                if(!Double.isNaN(v)) vertices[i * 6 + 4] = Mathf.map(1 - Mathf.clamp((float)v), fetchedRegion.v, fetchedRegion.v2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static void lookupRegion(String name, TextureRegion out){
<b class="nc">&nbsp;        TextureRegion region = Core.atlas.find(name);</b>
<b class="nc">&nbsp;        if(region.found()){</b>
<b class="nc">&nbsp;            out.set(region);</b>
&nbsp;        }else{
<b class="nc">&nbsp;            if(Core.assets.isLoaded(name, Texture.class)){</b>
<b class="nc">&nbsp;                out.set(Core.assets.get(name, Texture.class));</b>
&nbsp;            }else{
<b class="nc">&nbsp;                out.set(Core.atlas.find(&quot;error&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** For arrays or {@link Seq}s; does not create element rearrangement buttons. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Unordered{}
&nbsp;
&nbsp;    /** For arrays or {@link Seq}s; does not add the new and delete buttons */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Immutable{}
&nbsp;
&nbsp;    /** For {@code float[]}; treats it as an array of vertices. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Vertices{}
&nbsp;
&nbsp;    /** For {@code byte}; treats it as a world label flag. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface LabelFlag{}
&nbsp;
&nbsp;    /** For {@link UnlockableContent}; filters all un-researchable content. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Researchable{}
&nbsp;
&nbsp;    /** For {@link Block}; filters all un-buildable blocks. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Synthetic{}
&nbsp;
&nbsp;    /** For {@link String}; indicates that a text area should be used. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Multiline{}
&nbsp;
&nbsp;    /** For {@code float}; multiplies the UI input by 60. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface Second{}
&nbsp;
&nbsp;    /** For {@code float} or similar data structures, such as {@link Vec2}; multiplies the UI input by {@link Vars#tilesize}. */
&nbsp;    @Target(FIELD)
&nbsp;    @Retention(RUNTIME)
&nbsp;    public @interface TilePos{}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 14:03</div>
</div>
</body>
</html>
