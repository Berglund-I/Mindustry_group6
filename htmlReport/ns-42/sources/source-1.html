


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CoreBlock</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">mindustry.world.blocks.storage</a>
</div>

<h1>Coverage Summary for Class: CoreBlock (mindustry.world.blocks.storage)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CoreBlock</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (4/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20.9%
  </span>
  <span class="absValue">
    (31/148)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CoreBlock$CoreBuild</td>
<td class="coverageStat">
  <span class="percent">
    17.4%
  </span>
  <span class="absValue">
    (8/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.2%
  </span>
  <span class="absValue">
    (39/227)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (12/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.7%
  </span>
  <span class="absValue">
    (70/375)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package mindustry.world.blocks.storage;
&nbsp;
&nbsp;import arc.*;
&nbsp;import arc.audio.*;
&nbsp;import arc.func.*;
&nbsp;import arc.graphics.*;
&nbsp;import arc.graphics.g2d.*;
&nbsp;import arc.math.*;
&nbsp;import arc.math.geom.*;
&nbsp;import arc.scene.actions.*;
&nbsp;import arc.scene.event.*;
&nbsp;import arc.scene.ui.*;
&nbsp;import arc.scene.ui.layout.*;
&nbsp;import arc.struct.*;
&nbsp;import arc.util.*;
&nbsp;import mindustry.*;
&nbsp;import mindustry.annotations.Annotations.*;
&nbsp;import mindustry.content.*;
&nbsp;import mindustry.core.*;
&nbsp;import mindustry.ctype.*;
&nbsp;import mindustry.entities.*;
&nbsp;import mindustry.game.EventType.*;
&nbsp;import mindustry.game.*;
&nbsp;import mindustry.gen.*;
&nbsp;import mindustry.graphics.*;
&nbsp;import mindustry.logic.*;
&nbsp;import mindustry.type.*;
&nbsp;import mindustry.ui.*;
&nbsp;import mindustry.world.*;
&nbsp;import mindustry.world.meta.*;
&nbsp;import mindustry.world.modules.*;
&nbsp;
&nbsp;import static mindustry.Vars.*;
&nbsp;
&nbsp;public class CoreBlock extends StorageBlock{
&nbsp;    protected static final float cloudScaling = 1700f, cfinScl = -2f, cfinOffset = 0.3f, calphaFinOffset = 0.25f, cloudAlpha = 0.81f;
<b class="fc">&nbsp;    protected static final float[] cloudAlphas = {0, 0.5f, 1f, 0.1f, 0, 0f};</b>
&nbsp;
&nbsp;    //hacky way to pass item modules between methods
&nbsp;    private static ItemModule nextItems;
<b class="fc">&nbsp;    protected static final float[] thrusterSizes = {0f, 0f, 0f, 0f, 0.3f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 0f};</b>
&nbsp;
&nbsp;    public @Load(value = &quot;@-thruster1&quot;, fallback = &quot;clear-effect&quot;) TextureRegion thruster1; //top right
&nbsp;    public @Load(value = &quot;@-thruster2&quot;, fallback = &quot;clear-effect&quot;) TextureRegion thruster2; //bot left
<b class="fc">&nbsp;    public float thrusterLength = 14f/4f;</b>
&nbsp;    public boolean isFirstTier;
&nbsp;    /** If true, this core type requires a core zone to upgrade. */
&nbsp;    public boolean requiresCoreZone;
<b class="fc">&nbsp;    public boolean incinerateNonBuildable = false;</b>
&nbsp;
<b class="fc">&nbsp;    public UnitType unitType = UnitTypes.alpha;</b>
<b class="fc">&nbsp;    public float landDuration = 160f;</b>
<b class="fc">&nbsp;    public Music landMusic = Musics.land;</b>
<b class="fc">&nbsp;    public Music launchMusic = Musics.coreLaunch;</b>
<b class="fc">&nbsp;    public Effect launchEffect = Fx.launch;</b>
&nbsp;
<b class="fc">&nbsp;    public Interp landZoomInterp = Interp.pow3;</b>
<b class="fc">&nbsp;    public float landZoomFrom = 0.02f, landZoomTo = 4f;</b>
&nbsp;
<b class="fc">&nbsp;    public float captureInvicibility = 60f * 15f;</b>
&nbsp;
&nbsp;    public CoreBlock(String name){
<b class="fc">&nbsp;        super(name);</b>
&nbsp;
<b class="fc">&nbsp;        solid = true;</b>
<b class="fc">&nbsp;        update = true;</b>
<b class="fc">&nbsp;        hasItems = true;</b>
<b class="fc">&nbsp;        priority = TargetPriority.core;</b>
<b class="fc">&nbsp;        flags = EnumSet.of(BlockFlag.core);</b>
<b class="fc">&nbsp;        unitCapModifier = 10;</b>
<b class="fc">&nbsp;        loopSound = Sounds.respawning;</b>
<b class="fc">&nbsp;        loopSoundVolume = 1f;</b>
<b class="fc">&nbsp;        drawDisabled = false;</b>
<b class="fc">&nbsp;        canOverdrive = false;</b>
<b class="fc">&nbsp;        envEnabled |= Env.space;</b>
&nbsp;
&nbsp;        //support everything
<b class="fc">&nbsp;        replaceable = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Remote(called = Loc.server)
&nbsp;    public static void playerSpawn(Tile tile, Player player){
<b class="nc">&nbsp;        if(player == null || tile == null || !(tile.build instanceof CoreBuild core)) return;</b>
&nbsp;
<b class="nc">&nbsp;        UnitType spawnType = ((CoreBlock)core.block).unitType;</b>
<b class="nc">&nbsp;        if(core.wasVisible){</b>
<b class="nc">&nbsp;            Fx.spawn.at(core);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        player.set(core);</b>
&nbsp;
<b class="nc">&nbsp;        if(!net.client()){</b>
<b class="nc">&nbsp;            Unit unit = spawnType.create(tile.team());</b>
<b class="nc">&nbsp;            unit.set(core);</b>
<b class="nc">&nbsp;            unit.rotation(90f);</b>
<b class="nc">&nbsp;            unit.impulse(0f, 3f);</b>
<b class="nc">&nbsp;            unit.spawnedByCore(true);</b>
<b class="nc">&nbsp;            unit.controller(player);</b>
<b class="nc">&nbsp;            unit.add();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if(state.isCampaign() &amp;&amp; player == Vars.player){</b>
<b class="nc">&nbsp;            spawnType.unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setStats(){
<b class="nc">&nbsp;        super.setStats();</b>
&nbsp;
<b class="nc">&nbsp;        stats.remove(Stat.buildTime);</b>
<b class="nc">&nbsp;        stats.add(Stat.unitType, table -&gt; {</b>
<b class="nc">&nbsp;            table.row();</b>
<b class="nc">&nbsp;            table.table(Styles.grayPanel, b -&gt; {</b>
<b class="nc">&nbsp;                b.image(unitType.uiIcon).size(40).pad(10f).left().scaling(Scaling.fit);</b>
<b class="nc">&nbsp;                b.table(info -&gt; {</b>
<b class="nc">&nbsp;                    info.add(unitType.localizedName).left();</b>
<b class="nc">&nbsp;                    if(Core.settings.getBool(&quot;console&quot;)){</b>
<b class="nc">&nbsp;                        info.row();</b>
<b class="nc">&nbsp;                        info.add(unitType.name).left().color(Color.lightGray);</b>
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                b.button(&quot;?&quot;, Styles.flatBordert, () -&gt; ui.content.show(unitType)).size(40f).pad(10).right().grow().visible(() -&gt; unitType.unlockedNow());</b>
<b class="nc">&nbsp;            }).growX().pad(5).row();</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setBars(){
<b class="fc">&nbsp;        super.setBars();</b>
&nbsp;
<b class="fc">&nbsp;        addBar(&quot;capacity&quot;, (CoreBuild e) -&gt; new Bar(</b>
<b class="nc">&nbsp;            () -&gt; Core.bundle.format(&quot;bar.capacity&quot;, UI.formatAmount(e.storageCapacity)),</b>
<b class="nc">&nbsp;            () -&gt; Pal.items,</b>
<b class="nc">&nbsp;            () -&gt; e.items.total() / ((float)e.storageCapacity * content.items().count(UnlockableContent::unlockedNow))</b>
&nbsp;        ));
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void init(){
&nbsp;        //assign to update clipSize internally
<b class="fc">&nbsp;        lightRadius = 30f + 20f * size;</b>
<b class="fc">&nbsp;        fogRadius = Math.max(fogRadius, (int)(lightRadius / 8f * 3f) + 13);</b>
<b class="fc">&nbsp;        emitLight = true;</b>
&nbsp;
<b class="fc">&nbsp;        super.init();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canBreak(Tile tile){
<b class="nc">&nbsp;        return state.isEditor();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canReplace(Block other){
&nbsp;        //coreblocks can upgrade smaller cores
<b class="nc">&nbsp;        return super.canReplace(other) || (other instanceof CoreBlock &amp;&amp; size &gt;= other.size &amp;&amp; other != this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canPlaceOn(Tile tile, Team team, int rotation){
<b class="nc">&nbsp;        if(tile == null) return false;</b>
&nbsp;        //in the editor, you can place them anywhere for convenience
<b class="nc">&nbsp;        if(state.isEditor()) return true;</b>
&nbsp;
<b class="nc">&nbsp;        CoreBuild core = team.core();</b>
&nbsp;
&nbsp;        //special floor upon which cores can be placed
<b class="nc">&nbsp;        tile.getLinkedTilesAs(this, tempTiles);</b>
<b class="nc">&nbsp;        if(!tempTiles.contains(o -&gt; !o.floor().allowCorePlacement || o.block() instanceof CoreBlock)){</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        //must have all requirements
<b class="nc">&nbsp;        if(core == null || (!state.rules.infiniteResources &amp;&amp; !core.items.has(requirements, state.rules.buildCostMultiplier))) return false;</b>
&nbsp;
<b class="nc">&nbsp;        return tile.block() instanceof CoreBlock &amp;&amp; size &gt; tile.block().size &amp;&amp; (!requiresCoreZone || tempTiles.allMatch(o -&gt; o.floor().allowCorePlacement));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void placeBegan(Tile tile, Block previous, Unit builder){
&nbsp;        //finish placement immediately when a block is replaced.
<b class="nc">&nbsp;        if(previous instanceof CoreBlock){</b>
<b class="nc">&nbsp;            tile.setBlock(this, tile.team());</b>
<b class="nc">&nbsp;            tile.block().placeEffect.at(tile, tile.block().size);</b>
<b class="nc">&nbsp;            Fx.upgradeCore.at(tile.drawx(), tile.drawy(), 0f, tile.block());</b>
<b class="nc">&nbsp;            Fx.upgradeCoreBloom.at(tile, tile.block().size);</b>
&nbsp;
&nbsp;            //set up the correct items
<b class="nc">&nbsp;            if(nextItems != null){</b>
&nbsp;                //force-set the total items
<b class="nc">&nbsp;                if(tile.team().core() != null){</b>
<b class="nc">&nbsp;                    tile.team().core().items.set(nextItems);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                nextItems = null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Events.fire(new BlockBuildEndEvent(tile, builder, tile.team(), false, null));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void beforePlaceBegan(Tile tile, Block previous){
<b class="nc">&nbsp;        if(tile.build instanceof CoreBuild){</b>
&nbsp;            //right before placing, create a &quot;destination&quot; item array which is all the previous items minus core requirements
<b class="nc">&nbsp;            ItemModule items = tile.build.items.copy();</b>
<b class="nc">&nbsp;            if(!state.rules.infiniteResources){</b>
<b class="nc">&nbsp;                items.remove(ItemStack.mult(requirements, state.rules.buildCostMultiplier));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            nextItems = items;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void drawPlace(int x, int y, int rotation, boolean valid){
<b class="nc">&nbsp;        if(world.tile(x, y) == null) return;</b>
&nbsp;
<b class="nc">&nbsp;        if(!canPlaceOn(world.tile(x, y), player.team(), rotation)){</b>
&nbsp;
<b class="nc">&nbsp;            drawPlaceText(Core.bundle.get(</b>
<b class="nc">&nbsp;                isFirstTier ?</b>
&nbsp;                    //TODO better message
<b class="nc">&nbsp;                    &quot;bar.corefloor&quot; :</b>
<b class="nc">&nbsp;                    (player.team().core() != null &amp;&amp; player.team().core().items.has(requirements, state.rules.buildCostMultiplier)) || state.rules.infiniteResources ?</b>
<b class="nc">&nbsp;                    &quot;bar.corereq&quot; :</b>
<b class="nc">&nbsp;                    &quot;bar.noresources&quot;</b>
&nbsp;            ), x, y, valid);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void drawLanding(CoreBuild build, float x, float y){
<b class="nc">&nbsp;        float fin = renderer.getLandTimeIn();</b>
<b class="nc">&nbsp;        float fout = 1f - fin;</b>
&nbsp;
<b class="nc">&nbsp;        float scl = Scl.scl(4f) / renderer.getDisplayScale();</b>
<b class="nc">&nbsp;        float shake = 0f;</b>
<b class="nc">&nbsp;        float s = region.width * region.scl() * scl * 3.6f * Interp.pow2Out.apply(fout);</b>
<b class="nc">&nbsp;        float rotation = Interp.pow2In.apply(fout) * 135f;</b>
<b class="nc">&nbsp;        x += Mathf.range(shake);</b>
<b class="nc">&nbsp;        y += Mathf.range(shake);</b>
<b class="nc">&nbsp;        float thrustOpen = 0.25f;</b>
<b class="nc">&nbsp;        float thrusterFrame = fin &gt;= thrustOpen ? 1f : fin / thrustOpen;</b>
<b class="nc">&nbsp;        float thrusterSize = Mathf.sample(thrusterSizes, fin);</b>
&nbsp;
&nbsp;        //when launching, thrusters stay out the entire time.
<b class="nc">&nbsp;        if(renderer.isLaunching()){</b>
<b class="nc">&nbsp;            Interp i = Interp.pow2Out;</b>
<b class="nc">&nbsp;            thrusterFrame = i.apply(Mathf.clamp(fout*13f));</b>
<b class="nc">&nbsp;            thrusterSize = i.apply(Mathf.clamp(fout*9f));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Draw.color(Pal.lightTrail);</b>
&nbsp;        //TODO spikier heat
<b class="nc">&nbsp;        Draw.rect(&quot;circle-shadow&quot;, x, y, s, s);</b>
&nbsp;
<b class="nc">&nbsp;        Draw.scl(scl);</b>
&nbsp;
&nbsp;        //draw thruster flame
<b class="nc">&nbsp;        float strength = (1f + (size - 3)/2.5f) * scl * thrusterSize * (0.95f + Mathf.absin(2f, 0.1f));</b>
<b class="nc">&nbsp;        float offset = (size - 3) * 3f * scl;</b>
&nbsp;
<b class="nc">&nbsp;        for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;            Tmp.v1.trns(i * 90 + rotation, 1f);</b>
&nbsp;
<b class="nc">&nbsp;            Tmp.v1.setLength((size * tilesize/2f + 1f)*scl + strength*2f + offset);</b>
<b class="nc">&nbsp;            Draw.color(build.team.color);</b>
<b class="nc">&nbsp;            Fill.circle(Tmp.v1.x + x, Tmp.v1.y + y, 6f * strength);</b>
&nbsp;
<b class="nc">&nbsp;            Tmp.v1.setLength((size * tilesize/2f + 1f)*scl + strength*0.5f + offset);</b>
<b class="nc">&nbsp;            Draw.color(Color.white);</b>
<b class="nc">&nbsp;            Fill.circle(Tmp.v1.x + x, Tmp.v1.y + y, 3.5f * strength);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        drawLandingThrusters(x, y, rotation, thrusterFrame);</b>
&nbsp;
<b class="nc">&nbsp;        Drawf.spinSprite(region, x, y, rotation);</b>
&nbsp;
<b class="nc">&nbsp;        Draw.alpha(Interp.pow4In.apply(thrusterFrame));</b>
<b class="nc">&nbsp;        drawLandingThrusters(x, y, rotation, thrusterFrame);</b>
<b class="nc">&nbsp;        Draw.alpha(1f);</b>
&nbsp;
<b class="nc">&nbsp;        if(teamRegions[build.team.id] == teamRegion) Draw.color(build.team.color);</b>
&nbsp;
<b class="nc">&nbsp;        Drawf.spinSprite(teamRegions[build.team.id], x, y, rotation);</b>
&nbsp;
<b class="nc">&nbsp;        Draw.color();</b>
<b class="nc">&nbsp;        Draw.scl();</b>
<b class="nc">&nbsp;        Draw.reset();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void drawLandingThrusters(float x, float y, float rotation, float frame){
<b class="nc">&nbsp;        float length = thrusterLength * (frame - 1f) - 1f/4f;</b>
<b class="nc">&nbsp;        float alpha = Draw.getColorAlpha();</b>
&nbsp;
&nbsp;        //two passes for consistent lighting
<b class="nc">&nbsp;        for(int j = 0; j &lt; 2; j++){</b>
<b class="nc">&nbsp;            for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;                var reg = i &gt;= 2 ? thruster2 : thruster1;</b>
<b class="nc">&nbsp;                float rot = (i * 90) + rotation % 90f;</b>
<b class="nc">&nbsp;                Tmp.v1.trns(rot, length * Draw.xscl);</b>
&nbsp;
&nbsp;                //second pass applies extra layer of shading
<b class="nc">&nbsp;                if(j == 1){</b>
<b class="nc">&nbsp;                    Tmp.v1.rotate(-90f);</b>
<b class="nc">&nbsp;                    Draw.alpha((rotation % 90f) / 90f * alpha);</b>
<b class="nc">&nbsp;                    rot -= 90f;</b>
<b class="nc">&nbsp;                    Draw.rect(reg, x + Tmp.v1.x, y + Tmp.v1.y, rot);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    Draw.alpha(alpha);</b>
<b class="nc">&nbsp;                    Draw.rect(reg, x + Tmp.v1.x, y + Tmp.v1.y, rot);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Draw.alpha(1f);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public class CoreBuild extends Building{</b>
&nbsp;        public int storageCapacity;
<b class="fc">&nbsp;        public boolean noEffect = false;</b>
<b class="fc">&nbsp;        public Team lastDamage = Team.derelict;</b>
<b class="fc">&nbsp;        public float iframes = -1f;</b>
<b class="fc">&nbsp;        public float thrusterTime = 0f;</b>
&nbsp;
&nbsp;        protected float cloudSeed;
&nbsp;
&nbsp;        //utility methods for less Block-to-CoreBlock casts. also allows for more customization
&nbsp;        public float landDuration(){
<b class="nc">&nbsp;            return landDuration;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Music landMusic(){
<b class="nc">&nbsp;            return landMusic;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Music launchMusic(){
<b class="nc">&nbsp;            return launchMusic;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void draw(){
&nbsp;            //draw thrusters when just landed
<b class="nc">&nbsp;            if(thrusterTime &gt; 0){</b>
<b class="nc">&nbsp;                float frame = thrusterTime;</b>
&nbsp;
<b class="nc">&nbsp;                Draw.alpha(1f);</b>
<b class="nc">&nbsp;                drawThrusters(frame);</b>
<b class="nc">&nbsp;                Draw.rect(block.region, x, y);</b>
<b class="nc">&nbsp;                Draw.alpha(Interp.pow4In.apply(frame));</b>
<b class="nc">&nbsp;                drawThrusters(frame);</b>
<b class="nc">&nbsp;                Draw.reset();</b>
&nbsp;
<b class="nc">&nbsp;                drawTeamTop();</b>
<b class="nc">&nbsp;            }else{</b>
<b class="nc">&nbsp;                super.draw();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // `launchType` is null if it&#39;s landing instead of launching.
&nbsp;        public void beginLaunch(@Nullable CoreBlock launchType){
<b class="nc">&nbsp;            cloudSeed = Mathf.random(1f);</b>
<b class="nc">&nbsp;            if(launchType != null){</b>
<b class="nc">&nbsp;                Fx.coreLaunchConstruct.at(x, y, launchType.size);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!headless){</b>
&nbsp;                // Add fade-in and fade-out foreground when landing or launching.
<b class="nc">&nbsp;                if(renderer.isLaunching()){</b>
<b class="nc">&nbsp;                    float margin = 30f;</b>
&nbsp;
<b class="nc">&nbsp;                    Image image = new Image();</b>
<b class="nc">&nbsp;                    image.color.a = 0f;</b>
<b class="nc">&nbsp;                    image.touchable = Touchable.disabled;</b>
<b class="nc">&nbsp;                    image.setFillParent(true);</b>
<b class="nc">&nbsp;                    image.actions(Actions.delay((landDuration() - margin) / 60f), Actions.fadeIn(margin / 60f, Interp.pow2In), Actions.delay(6f / 60f), Actions.remove());</b>
<b class="nc">&nbsp;                    image.update(() -&gt; {</b>
<b class="nc">&nbsp;                        image.toFront();</b>
<b class="nc">&nbsp;                        ui.loadfrag.toFront();</b>
<b class="nc">&nbsp;                        if(state.isMenu()){</b>
<b class="nc">&nbsp;                            image.remove();</b>
&nbsp;                        }
&nbsp;                    });
<b class="nc">&nbsp;                    Core.scene.add(image);</b>
<b class="nc">&nbsp;                }else{</b>
<b class="nc">&nbsp;                    Image image = new Image();</b>
<b class="nc">&nbsp;                    image.color.a = 1f;</b>
<b class="nc">&nbsp;                    image.touchable = Touchable.disabled;</b>
<b class="nc">&nbsp;                    image.setFillParent(true);</b>
<b class="nc">&nbsp;                    image.actions(Actions.fadeOut(35f / 60f), Actions.remove());</b>
<b class="nc">&nbsp;                    image.update(() -&gt; {</b>
<b class="nc">&nbsp;                        image.toFront();</b>
<b class="nc">&nbsp;                        ui.loadfrag.toFront();</b>
<b class="nc">&nbsp;                        if(state.isMenu()){</b>
<b class="nc">&nbsp;                            image.remove();</b>
&nbsp;                        }
&nbsp;                    });
<b class="nc">&nbsp;                    Core.scene.add(image);</b>
&nbsp;
<b class="nc">&nbsp;                    Time.run(landDuration(), () -&gt; {</b>
<b class="nc">&nbsp;                        launchEffect.at(this);</b>
<b class="nc">&nbsp;                        Effect.shake(5f, 5f, this);</b>
<b class="nc">&nbsp;                        thrusterTime = 1f;</b>
&nbsp;
<b class="nc">&nbsp;                        if(state.isCampaign() &amp;&amp; Vars.showSectorLandInfo &amp;&amp; (state.rules.sector.preset == null || state.rules.sector.preset.showSectorLandInfo)){</b>
<b class="nc">&nbsp;                            ui.announce(&quot;[accent]&quot; + state.rules.sector.name() + &quot;\n&quot; +</b>
<b class="nc">&nbsp;                                (state.rules.sector.info.resources.any() ? &quot;[lightgray]&quot; + Core.bundle.get(&quot;sectors.resources&quot;) + &quot;[white] &quot; +</b>
<b class="nc">&nbsp;                                    state.rules.sector.info.resources.toString(&quot; &quot;, UnlockableContent::emoji) : &quot;&quot;), 5);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public void endLaunch(){}</b>
&nbsp;
&nbsp;        public void drawLanding(CoreBlock block){
<b class="nc">&nbsp;            var clouds = Core.assets.get(&quot;sprites/clouds.png&quot;, Texture.class);</b>
&nbsp;
<b class="nc">&nbsp;            float fin = renderer.getLandTimeIn();</b>
<b class="nc">&nbsp;            float cameraScl = renderer.getDisplayScale();</b>
&nbsp;
<b class="nc">&nbsp;            float fout = 1f - fin;</b>
<b class="nc">&nbsp;            float scl = Scl.scl(4f) / cameraScl;</b>
<b class="nc">&nbsp;            float pfin = Interp.pow3Out.apply(fin), pf = Interp.pow2In.apply(fout);</b>
&nbsp;
&nbsp;            //draw particles
<b class="nc">&nbsp;            Draw.color(Pal.lightTrail);</b>
<b class="nc">&nbsp;            Angles.randLenVectors(1, pfin, 100, 800f * scl * pfin, (ax, ay, ffin, ffout) -&gt; {</b>
<b class="nc">&nbsp;                Lines.stroke(scl * ffin * pf * 3f);</b>
<b class="nc">&nbsp;                Lines.lineAngle(x + ax, y + ay, Mathf.angle(ax, ay), (ffin * 20 + 1f) * scl);</b>
&nbsp;            });
<b class="nc">&nbsp;            Draw.color();</b>
&nbsp;
<b class="nc">&nbsp;            block.drawLanding(this, x, y);</b>
&nbsp;
<b class="nc">&nbsp;            Draw.color();</b>
<b class="nc">&nbsp;            Draw.mixcol(Color.white, Interp.pow5In.apply(fout));</b>
&nbsp;
&nbsp;            //accent tint indicating that the core was just constructed
<b class="nc">&nbsp;            if(renderer.isLaunching()){</b>
<b class="nc">&nbsp;                float f = Mathf.clamp(1f - fout * 12f);</b>
<b class="nc">&nbsp;                if(f &gt; 0.001f){</b>
<b class="nc">&nbsp;                    Draw.mixcol(Pal.accent, f);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //draw clouds
<b class="nc">&nbsp;            if(state.rules.cloudColor.a &gt; 0.0001f){</b>
<b class="nc">&nbsp;                float scaling = cloudScaling;</b>
<b class="nc">&nbsp;                float sscl = Math.max(1f + Mathf.clamp(fin + cfinOffset) * cfinScl, 0f) * cameraScl;</b>
&nbsp;
<b class="nc">&nbsp;                Tmp.tr1.set(clouds);</b>
<b class="nc">&nbsp;                Tmp.tr1.set(</b>
&nbsp;                    (Core.camera.position.x - Core.camera.width/2f * sscl) / scaling,
&nbsp;                    (Core.camera.position.y - Core.camera.height/2f * sscl) / scaling,
&nbsp;                    (Core.camera.position.x + Core.camera.width/2f * sscl) / scaling,
&nbsp;                    (Core.camera.position.y + Core.camera.height/2f * sscl) / scaling);
&nbsp;
<b class="nc">&nbsp;                Tmp.tr1.scroll(10f * cloudSeed, 10f * cloudSeed);</b>
&nbsp;
<b class="nc">&nbsp;                Draw.alpha(Mathf.sample(cloudAlphas, fin + calphaFinOffset) * cloudAlpha);</b>
<b class="nc">&nbsp;                Draw.mixcol(state.rules.cloudColor, state.rules.cloudColor.a);</b>
<b class="nc">&nbsp;                Draw.rect(Tmp.tr1, Core.camera.position.x, Core.camera.position.y, Core.camera.width, Core.camera.height);</b>
<b class="nc">&nbsp;                Draw.reset();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void drawThrusters(float frame){
<b class="nc">&nbsp;            float length = thrusterLength * (frame - 1f) - 1f/4f;</b>
<b class="nc">&nbsp;            for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;                var reg = i &gt;= 2 ? thruster2 : thruster1;</b>
<b class="nc">&nbsp;                float dx = Geometry.d4x[i] * length, dy = Geometry.d4y[i] * length;</b>
<b class="nc">&nbsp;                Draw.rect(reg, x + dx, y + dy, i * 90);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void damage(@Nullable Team source, float damage){
<b class="nc">&nbsp;            if(iframes &gt; 0) return;</b>
&nbsp;
<b class="nc">&nbsp;            if(source != null &amp;&amp; source != team){</b>
<b class="nc">&nbsp;                lastDamage = source;</b>
&nbsp;            }
<b class="nc">&nbsp;            super.damage(source, damage);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void created(){
<b class="fc">&nbsp;            super.created();</b>
&nbsp;
<b class="fc">&nbsp;            Events.fire(new CoreChangeEvent(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void changeTeam(Team next){
<b class="nc">&nbsp;            if(this.team == next) return;</b>
&nbsp;
<b class="nc">&nbsp;            onRemoved();</b>
&nbsp;
<b class="nc">&nbsp;            super.changeTeam(next);</b>
&nbsp;
<b class="nc">&nbsp;            onProximityUpdate();</b>
&nbsp;
<b class="nc">&nbsp;            Events.fire(new CoreChangeEvent(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double sense(LAccess sensor){
<b class="nc">&nbsp;            if(sensor == LAccess.itemCapacity) return storageCapacity;</b>
<b class="nc">&nbsp;            return super.sense(sensor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean canControlSelect(Unit player){
<b class="nc">&nbsp;            return player.isPlayer();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onControlSelect(Unit unit){
<b class="nc">&nbsp;            if(!unit.isPlayer()) return;</b>
<b class="nc">&nbsp;            Player player = unit.getPlayer();</b>
&nbsp;
<b class="nc">&nbsp;            Fx.spawn.at(player);</b>
<b class="nc">&nbsp;            if(net.client() &amp;&amp; player == Vars.player){</b>
<b class="nc">&nbsp;                control.input.controlledType = null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            player.clearUnit();</b>
<b class="nc">&nbsp;            player.deathTimer = Player.deathDelay + 1f;</b>
<b class="nc">&nbsp;            requestSpawn(player);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void requestSpawn(Player player){
&nbsp;            //do not try to respawn in unsupported environments at all
<b class="nc">&nbsp;            if(!unitType.supportsEnv(state.rules.env)) return;</b>
&nbsp;
<b class="nc">&nbsp;            Call.playerSpawn(tile, player);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void updateTile(){
<b class="fc">&nbsp;            iframes -= Time.delta;</b>
<b class="fc">&nbsp;            thrusterTime -= Time.delta/90f;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return Camera zoom while landing or launching. May optionally do other things such as setting camera position to itself. */
&nbsp;        public float zoomLaunching(){
<b class="nc">&nbsp;            Core.camera.position.set(this);</b>
<b class="nc">&nbsp;            return landZoomInterp.apply(Scl.scl(landZoomFrom), Scl.scl(landZoomTo), renderer.getLandTimeIn());</b>
&nbsp;        }
&nbsp;
&nbsp;        public void updateLaunching(){
<b class="nc">&nbsp;            updateLandParticles();</b>
&nbsp;        }
&nbsp;
&nbsp;        public void updateLandParticles(){
<b class="nc">&nbsp;            float in = renderer.getLandTimeIn() * landDuration();</b>
<b class="nc">&nbsp;            float tsize = Mathf.sample(thrusterSizes, (in + 35f) / landDuration());</b>
&nbsp;
<b class="nc">&nbsp;            renderer.setLandPTimer(renderer.getLandPTimer() + tsize * Time.delta);</b>
<b class="nc">&nbsp;            if(renderer.getLandTime() &gt;= 1f){</b>
<b class="nc">&nbsp;                tile.getLinkedTiles(t -&gt; {</b>
<b class="nc">&nbsp;                    if(Mathf.chance(0.4f)){</b>
<b class="nc">&nbsp;                        Fx.coreLandDust.at(t.worldx(), t.worldy(), angleTo(t.worldx(), t.worldy()) + Mathf.range(30f), Tmp.c1.set(t.floor().mapColor).mul(1.5f + Mathf.range(0.15f)));</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;                renderer.setLandPTimer(0f);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean canPickup(){
&nbsp;            //cores can never be picked up
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onDestroyed(){
<b class="nc">&nbsp;            if(state.rules.coreCapture){</b>
&nbsp;                //just create an explosion, no fire. this prevents immediate recapture
<b class="nc">&nbsp;                Damage.dynamicExplosion(x, y, 0, 0, 0, tilesize * block.size / 2f, state.rules.damageExplosions);</b>
<b class="nc">&nbsp;                Fx.commandSend.at(x, y, 140f);</b>
&nbsp;            }else{
<b class="nc">&nbsp;                super.onDestroyed();</b>
&nbsp;            }
&nbsp;
&nbsp;            //add a spawn to the map for future reference - waves should be disabled, so it shouldn&#39;t matter
<b class="nc">&nbsp;            if(state.isCampaign() &amp;&amp; team == state.rules.waveTeam &amp;&amp; team.cores().size &lt;= 1 &amp;&amp; state.rules.sector.planet.enemyCoreSpawnReplace){</b>
&nbsp;                //do not recache
<b class="nc">&nbsp;                tile.setOverlayQuiet(Blocks.spawn);</b>
&nbsp;
<b class="nc">&nbsp;                if(!spawner.getSpawns().contains(tile)){</b>
<b class="nc">&nbsp;                    spawner.getSpawns().add(tile);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Events.fire(new CoreChangeEvent(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void afterDestroyed(){
<b class="nc">&nbsp;            super.afterDestroyed();</b>
<b class="nc">&nbsp;            if(state.rules.coreCapture){</b>
<b class="nc">&nbsp;                if(!net.client()){</b>
<b class="nc">&nbsp;                    tile.setBlock(block, lastDamage);</b>
&nbsp;                }
&nbsp;
&nbsp;                //delay so clients don&#39;t destroy it afterwards
<b class="nc">&nbsp;                Core.app.post(() -&gt; tile.setNet(block, lastDamage, 0));</b>
&nbsp;
&nbsp;                //building does not exist on client yet
<b class="nc">&nbsp;                if(!net.client()){</b>
&nbsp;                    //core is invincible for several seconds to prevent recapture
<b class="nc">&nbsp;                    ((CoreBuild)tile.build).iframes = captureInvicibility;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void drawLight(){
<b class="nc">&nbsp;            Drawf.light(x, y, lightRadius, Pal.accent, 0.65f + Mathf.absin(20f, 0.1f));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean acceptItem(Building source, Item item){
<b class="nc">&nbsp;            return items.get(item) &lt; getMaximumAccepted(item);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getMaximumAccepted(Item item){
<b class="nc">&nbsp;            return state.rules.coreIncinerates ? storageCapacity * 20 : storageCapacity;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onProximityUpdate(){
<b class="fc">&nbsp;            super.onProximityUpdate();</b>
&nbsp;
<b class="fc">&nbsp;            for(Building other : state.teams.cores(team)){</b>
<b class="fc">&nbsp;                if(other.tile() != tile){</b>
<b class="fc">&nbsp;                    this.items = other.items;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            state.teams.registerCore(this);</b>
&nbsp;
<b class="fc">&nbsp;            storageCapacity = itemCapacity + proximity().sum(e -&gt; owns(e) ? e.block.itemCapacity : 0);</b>
<b class="fc">&nbsp;            proximity.each(this::owns, t -&gt; {</b>
<b class="fc">&nbsp;                t.items = items;</b>
<b class="fc">&nbsp;                ((StorageBuild)t).linkedCore = this;</b>
&nbsp;            });
&nbsp;
<b class="fc">&nbsp;            for(Building other : state.teams.cores(team)){</b>
<b class="fc">&nbsp;                if(other.tile() == tile) continue;</b>
<b class="fc">&nbsp;                storageCapacity += other.block.itemCapacity + other.proximity().sum(e -&gt; owns(other, e) ? e.block.itemCapacity : 0);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            //Team.sharded.core().items.set(Items.surgeAlloy, 12000)
<b class="fc">&nbsp;            if(!world.isGenerating()){</b>
<b class="fc">&nbsp;                for(Item item : content.items()){</b>
<b class="fc">&nbsp;                    items.set(item, Math.min(items.get(item), storageCapacity));</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            for(CoreBuild other : state.teams.cores(team)){</b>
<b class="fc">&nbsp;                other.storageCapacity = storageCapacity;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void handleStack(Item item, int amount, Teamc source){
<b class="nc">&nbsp;            boolean incinerate = incinerateNonBuildable &amp;&amp; !item.buildable;</b>
<b class="nc">&nbsp;            int realAmount = incinerate ? 0 : Math.min(amount, storageCapacity - items.get(item));</b>
<b class="nc">&nbsp;            super.handleStack(item, realAmount, source);</b>
&nbsp;
<b class="nc">&nbsp;            if(team == state.rules.defaultTeam &amp;&amp; state.isCampaign()){</b>
<b class="nc">&nbsp;                if(!incinerate){</b>
<b class="nc">&nbsp;                    state.rules.sector.info.handleCoreItem(item, amount);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(realAmount == 0 &amp;&amp; wasVisible){</b>
<b class="nc">&nbsp;                    Fx.coreBurn.at(x, y);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int removeStack(Item item, int amount){
<b class="nc">&nbsp;            int result = super.removeStack(item, amount);</b>
&nbsp;
<b class="nc">&nbsp;            if(team == state.rules.defaultTeam &amp;&amp; state.isCampaign()){</b>
<b class="nc">&nbsp;                state.rules.sector.info.handleCoreItem(item, -result);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void drawSelect(){
&nbsp;            //do not draw a pointless single outline when there&#39;s no storage
<b class="nc">&nbsp;            if(team.cores().size &lt;= 1 &amp;&amp; !proximity.contains(storage -&gt; storage.items == items)) return;</b>
&nbsp;
<b class="nc">&nbsp;            Lines.stroke(1f, Pal.accent);</b>
<b class="nc">&nbsp;            Cons&lt;Building&gt; outline = b -&gt; {</b>
<b class="nc">&nbsp;                for(int i = 0; i &lt; 4; i++){</b>
<b class="nc">&nbsp;                    Point2 p = Geometry.d8edge[i];</b>
<b class="nc">&nbsp;                    float offset = -Math.max(b.block.size - 1, 0) / 2f * tilesize;</b>
<b class="nc">&nbsp;                    Draw.rect(&quot;block-select&quot;, b.x + offset * p.x, b.y + offset * p.y, i * 90);</b>
&nbsp;                }
&nbsp;            };
<b class="nc">&nbsp;            team.cores().each(core -&gt; {</b>
<b class="nc">&nbsp;                outline.get(core);</b>
<b class="nc">&nbsp;                core.proximity.each(storage -&gt; storage.items == items, outline);</b>
&nbsp;            });
<b class="nc">&nbsp;            Draw.reset();</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean owns(Building tile){
<b class="fc">&nbsp;            return owns(this, tile);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean owns(Building core, Building tile){
<b class="fc">&nbsp;            return tile instanceof StorageBuild b &amp;&amp; ((StorageBlock)b.block).coreMerge &amp;&amp; (b.linkedCore == core || b.linkedCore == null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void damage(float amount){
<b class="nc">&nbsp;            if(player != null &amp;&amp; team == player.team()){</b>
<b class="nc">&nbsp;                Events.fire(Trigger.teamCoreDamage);</b>
&nbsp;            }
<b class="nc">&nbsp;            super.damage(amount);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onRemoved(){
<b class="fc">&nbsp;            int total = proximity.count(e -&gt; e.items != null &amp;&amp; e.items == items);</b>
<b class="fc">&nbsp;            float fract = 1f / total / state.teams.cores(team).size;</b>
&nbsp;
<b class="fc">&nbsp;            proximity.each(e -&gt; owns(e) &amp;&amp; e.items == items &amp;&amp; owns(e), t -&gt; {</b>
<b class="nc">&nbsp;                StorageBuild ent = (StorageBuild)t;</b>
<b class="nc">&nbsp;                ent.linkedCore = null;</b>
<b class="nc">&nbsp;                ent.items = new ItemModule();</b>
<b class="nc">&nbsp;                for(Item item : content.items()){</b>
<b class="nc">&nbsp;                    ent.items.set(item, (int)(fract * items.get(item)));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            });
&nbsp;
<b class="fc">&nbsp;            state.teams.unregisterCore(this);</b>
&nbsp;
<b class="fc">&nbsp;            for(CoreBuild other : state.teams.cores(team)){</b>
<b class="fc">&nbsp;                other.onProximityUpdate();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void placed(){
<b class="nc">&nbsp;            super.placed();</b>
<b class="nc">&nbsp;            state.teams.registerCore(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void itemTaken(Item item){
<b class="nc">&nbsp;            if(state.isCampaign() &amp;&amp; team == state.rules.defaultTeam){</b>
&nbsp;                //update item taken amount
<b class="nc">&nbsp;                state.rules.sector.info.handleCoreItem(item, -1);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void handleItem(Building source, Item item){
<b class="nc">&nbsp;            boolean incinerate = incinerateNonBuildable &amp;&amp; !item.buildable;</b>
&nbsp;
<b class="nc">&nbsp;            if(team == state.rules.defaultTeam){</b>
<b class="nc">&nbsp;                state.stats.coreItemCount.increment(item);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(net.server() || !net.active()){</b>
<b class="nc">&nbsp;                if(team == state.rules.defaultTeam &amp;&amp; state.isCampaign() &amp;&amp; !incinerate){</b>
<b class="nc">&nbsp;                    state.rules.sector.info.handleCoreItem(item, 1);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(items.get(item) &gt;= storageCapacity || incinerate){</b>
&nbsp;                    //create item incineration effect at random intervals
<b class="nc">&nbsp;                    if(!noEffect){</b>
<b class="nc">&nbsp;                        incinerateEffect(this, source);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    noEffect = false;</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    super.handleItem(source, item);</b>
&nbsp;                }
<b class="nc">&nbsp;            }else if(((state.rules.coreIncinerates &amp;&amp; items.get(item) &gt;= storageCapacity) || incinerate) &amp;&amp; !noEffect){</b>
&nbsp;                //create item incineration effect at random intervals
<b class="nc">&nbsp;                incinerateEffect(this, source);</b>
<b class="nc">&nbsp;                noEffect = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 14:03</div>
</div>
</body>
</html>
