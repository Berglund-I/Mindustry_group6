


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Mods</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">mindustry.mod</a>
</div>

<h1>Coverage Summary for Class: Mods (mindustry.mod)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Mods</td>
<td class="coverageStat">
  <span class="percent">
    49.1%
  </span>
  <span class="absValue">
    (26/53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.3%
  </span>
  <span class="absValue">
    (225/466)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Mods$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$1LoadRun</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$1RegionEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$3$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$LoadedMod</td>
<td class="coverageStat">
  <span class="percent">
    21.7%
  </span>
  <span class="absValue">
    (5/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34.9%
  </span>
  <span class="absValue">
    (15/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$ModDependency</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$ModLoadException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$ModMeta</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (16/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$ModResolutionContext</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Mods$ModState</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (39/104)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.8%
  </span>
  <span class="absValue">
    (276/616)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package mindustry.mod;
&nbsp;
&nbsp;import arc.*;
&nbsp;import arc.assets.*;
&nbsp;import arc.files.*;
&nbsp;import arc.func.*;
&nbsp;import arc.graphics.*;
&nbsp;import arc.graphics.Texture.*;
&nbsp;import arc.graphics.g2d.*;
&nbsp;import arc.graphics.g2d.TextureAtlas.*;
&nbsp;import arc.scene.ui.*;
&nbsp;import arc.struct.*;
&nbsp;import arc.util.*;
&nbsp;import arc.util.io.*;
&nbsp;import arc.util.serialization.*;
&nbsp;import arc.util.serialization.Jval.*;
&nbsp;import mindustry.core.*;
&nbsp;import mindustry.ctype.*;
&nbsp;import mindustry.game.EventType.*;
&nbsp;import mindustry.gen.*;
&nbsp;import mindustry.graphics.*;
&nbsp;import mindustry.graphics.MultiPacker.*;
&nbsp;import mindustry.mod.ContentParser.*;
&nbsp;import mindustry.type.*;
&nbsp;import mindustry.ui.*;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.*;
&nbsp;
&nbsp;import static mindustry.Vars.*;
&nbsp;
<b class="nc">&nbsp;public class Mods implements Loadable{</b>
<b class="fc">&nbsp;    private static final String[] metaFiles = {&quot;mod.json&quot;, &quot;mod.hjson&quot;, &quot;plugin.json&quot;, &quot;plugin.hjson&quot;};</b>
<b class="fc">&nbsp;    private static final ObjectSet&lt;String&gt; blacklistedMods = ObjectSet.with(&quot;ui-lib&quot;, &quot;braindustry&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    private Json json = new Json();</b>
&nbsp;    private @Nullable Scripts scripts;
<b class="fc">&nbsp;    private ContentParser parser = new ContentParser();</b>
<b class="fc">&nbsp;    private ObjectMap&lt;String, Seq&lt;Fi&gt;&gt; bundles = new ObjectMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private ObjectSet&lt;String&gt; specialFolders = ObjectSet.with(&quot;bundles&quot;, &quot;sprites&quot;, &quot;sprites-override&quot;, &quot;.git&quot;);</b>
&nbsp;
&nbsp;    private int totalSprites;
<b class="fc">&nbsp;    private ObjectFloatMap&lt;String&gt; textureResize = new ObjectFloatMap&lt;&gt;();</b>
&nbsp;    private MultiPacker packer;
&nbsp;
&nbsp;    /** Ordered mods cache. Set to null to invalidate. */
<b class="fc">&nbsp;    private @Nullable Seq&lt;LoadedMod&gt; lastOrderedMods = new Seq&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private ModClassLoader mainLoader = new ModClassLoader(getClass().getClassLoader());</b>
&nbsp;
<b class="fc">&nbsp;    Seq&lt;LoadedMod&gt; mods = new Seq&lt;&gt;();</b>
<b class="fc">&nbsp;    private ObjectMap&lt;Class&lt;?&gt;, ModMeta&gt; metas = new ObjectMap&lt;&gt;();</b>
&nbsp;    private boolean requiresReload;
&nbsp;
<b class="fc">&nbsp;    public Mods(){</b>
<b class="fc">&nbsp;        Events.on(ClientLoadEvent.class, e -&gt; Core.app.post(this::checkWarnings));</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return the main class loader for all mods */
&nbsp;    public ClassLoader mainLoader(){
<b class="nc">&nbsp;        return mainLoader;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return the folder where configuration files for this mod should go. Call this in init(). */
&nbsp;    public Fi getConfigFolder(Mod mod){
<b class="nc">&nbsp;        ModMeta load = metas.get(mod.getClass());</b>
<b class="nc">&nbsp;        if(load == null) throw new IllegalArgumentException(&quot;Mod is not loaded yet (or missing)!&quot;);</b>
<b class="nc">&nbsp;        Fi result = modDirectory.child(load.name);</b>
<b class="nc">&nbsp;        result.mkdirs();</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return a file named &#39;config.json&#39; in the config folder for the specified mod.
&nbsp;     * Call this in init(). */
&nbsp;    public Fi getConfig(Mod mod){
<b class="nc">&nbsp;        return getConfigFolder(mod).child(&quot;config.json&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Returns a list of files per mod subdirectory. */
&nbsp;    public void listFiles(String directory, Cons2&lt;LoadedMod, Fi&gt; cons){
<b class="fc">&nbsp;        eachEnabled(mod -&gt; {</b>
<b class="fc">&nbsp;            Fi file = mod.root.child(directory);</b>
<b class="fc">&nbsp;            if(file.exists()){</b>
<b class="fc">&nbsp;                for(Fi child : file.list()){</b>
<b class="fc">&nbsp;                    cons.get(mod, child);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /** @return the loaded mod found by name, or null if not found. */
&nbsp;    public @Nullable LoadedMod getMod(String name){
<b class="nc">&nbsp;        return mods.find(m -&gt; m.name.equals(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return the loaded mod found by class, or null if not found. */
&nbsp;    public @Nullable LoadedMod getMod(Class&lt;? extends Mod&gt; type){
<b class="nc">&nbsp;        return mods.find(m -&gt; m.main != null &amp;&amp; m.main.getClass() == type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Imports an external mod file. Folders are not supported here. */
&nbsp;    public LoadedMod importMod(Fi file) throws IOException{
&nbsp;        //for some reason, android likes to add colons to file names, e.g. primary:ExampleJavaMod.jar, which breaks dexing
<b class="nc">&nbsp;        String baseName = file.nameWithoutExtension().replace(&#39;:&#39;, &#39;_&#39;).replace(&#39; &#39;, &#39;_&#39;);</b>
<b class="nc">&nbsp;        String finalName = baseName;</b>
&nbsp;        //find a name to prevent any name conflicts
<b class="nc">&nbsp;        int count = 1;</b>
<b class="nc">&nbsp;        while(modDirectory.child(finalName + &quot;.zip&quot;).exists()){</b>
<b class="nc">&nbsp;            finalName = baseName + &quot;&quot; + count++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Fi dest = modDirectory.child(finalName + &quot;.zip&quot;);</b>
&nbsp;
&nbsp;        try{
<b class="nc">&nbsp;            file.copyTo(dest);</b>
&nbsp;
<b class="nc">&nbsp;            var loaded = loadMod(dest, true, true);</b>
<b class="nc">&nbsp;            mods.add(loaded);</b>
&nbsp;            //invalidate ordered mods cache
<b class="nc">&nbsp;            lastOrderedMods = null;</b>
<b class="nc">&nbsp;            requiresReload = true;</b>
&nbsp;            //enable the mod on import
<b class="nc">&nbsp;            Core.settings.put(&quot;mod-&quot; + loaded.name + &quot;-enabled&quot;, true);</b>
<b class="nc">&nbsp;            sortMods();</b>
&nbsp;            //try to load the mod&#39;s icon so it displays on import
<b class="nc">&nbsp;            Core.app.post(() -&gt; loadIcon(loaded));</b>
&nbsp;
<b class="nc">&nbsp;            Events.fire(Trigger.importMod);</b>
&nbsp;
<b class="nc">&nbsp;            return loaded;</b>
<b class="nc">&nbsp;        }catch(IOException e){</b>
<b class="nc">&nbsp;            dest.delete();</b>
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        }catch(Throwable t){</b>
<b class="nc">&nbsp;            dest.delete();</b>
<b class="nc">&nbsp;            throw new IOException(t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Repacks all in-game sprites. */
&nbsp;    @Override
&nbsp;    public void loadAsync(){
<b class="nc">&nbsp;        if(!mods.contains(LoadedMod::enabled)) return;</b>
<b class="nc">&nbsp;        Time.mark();</b>
&nbsp;
&nbsp;        //TODO this should estimate sprite sizes per page
<b class="nc">&nbsp;        packer = new MultiPacker();</b>
&nbsp;        //all packing tasks to await
<b class="nc">&nbsp;        var tasks = new Seq&lt;Future&lt;Runnable&gt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        eachEnabled(mod -&gt; {</b>
<b class="nc">&nbsp;            Seq&lt;Fi&gt; sprites = mod.root.child(&quot;sprites&quot;).findAll(f -&gt; f.extension().equals(&quot;png&quot;));</b>
<b class="nc">&nbsp;            Seq&lt;Fi&gt; overrides = mod.root.child(&quot;sprites-override&quot;).findAll(f -&gt; f.extension().equals(&quot;png&quot;));</b>
&nbsp;
<b class="nc">&nbsp;            packSprites(sprites, mod, true, tasks);</b>
<b class="nc">&nbsp;            packSprites(overrides, mod, false, tasks);</b>
&nbsp;
<b class="nc">&nbsp;            Log.debug(&quot;Packed @ images for mod &#39;@&#39;.&quot;, sprites.size + overrides.size, mod.meta.name);</b>
<b class="nc">&nbsp;            totalSprites += sprites.size + overrides.size;</b>
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        for(var result : tasks){</b>
&nbsp;            try{
<b class="nc">&nbsp;                var packRun = result.get();</b>
<b class="nc">&nbsp;                if(packRun != null){ //can be null for very strange reasons, ignore if that&#39;s the case</b>
&nbsp;                    try{
&nbsp;                        //actually pack the image
<b class="nc">&nbsp;                        packRun.run();</b>
<b class="nc">&nbsp;                    }catch(Exception e){ //the image can fail to fit in the spritesheet</b>
<b class="nc">&nbsp;                        Log.err(&quot;Failed to fit image into the spritesheet, skipping.&quot;);</b>
<b class="nc">&nbsp;                        Log.err(e);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }catch(Exception e){ //this means loading the image failed, log it and move on</b>
<b class="nc">&nbsp;                Log.err(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Log.debug(&quot;Time to pack textures: @&quot;, Time.elapsed());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void loadIcons(){
<b class="nc">&nbsp;        for(LoadedMod mod : mods){</b>
<b class="nc">&nbsp;            loadIcon(mod);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void loadIcon(LoadedMod mod){
&nbsp;        //try to load icon for each mod that can have one
<b class="nc">&nbsp;        if(mod.root.child(&quot;icon.png&quot;).exists() &amp;&amp; !headless){</b>
&nbsp;            try{
<b class="nc">&nbsp;                mod.iconTexture = new Texture(mod.root.child(&quot;icon.png&quot;));</b>
<b class="nc">&nbsp;                mod.iconTexture.setFilter(TextureFilter.linear);</b>
<b class="nc">&nbsp;            }catch(Throwable t){</b>
<b class="nc">&nbsp;                Log.err(&quot;Failed to load icon for mod &#39;&quot; + mod.name + &quot;&#39;.&quot;, t);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void packSprites(Seq&lt;Fi&gt; sprites, LoadedMod mod, boolean prefix, Seq&lt;Future&lt;Runnable&gt;&gt; tasks){
<b class="nc">&nbsp;        boolean bleed = Core.settings.getBool(&quot;linear&quot;, true) &amp;&amp; !mod.meta.pregenerated;</b>
<b class="nc">&nbsp;        float textureScale = mod.meta.texturescale;</b>
&nbsp;
<b class="nc">&nbsp;        for(Fi file : sprites){</b>
&nbsp;            String
<b class="nc">&nbsp;            baseName = file.nameWithoutExtension(),</b>
<b class="nc">&nbsp;            regionName = baseName.contains(&quot;.&quot;) ? baseName.substring(0, baseName.indexOf(&quot;.&quot;)) : baseName;</b>
&nbsp;
<b class="nc">&nbsp;            if(!prefix &amp;&amp; !Core.atlas.has(regionName)){</b>
<b class="nc">&nbsp;                Log.warn(&quot;Sprite &#39;@&#39; in mod &#39;@&#39; attempts to override a non-existent sprite. Ignoring.&quot;, regionName, mod.name);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;
&nbsp;                //(horrible code below)
&nbsp;            }
&nbsp;
&nbsp;            //read and bleed pixmaps in parallel
<b class="nc">&nbsp;            tasks.add(mainExecutor.submit(() -&gt; {</b>
&nbsp;
&nbsp;                try{
<b class="nc">&nbsp;                    Pixmap pix = new Pixmap(file.readBytes());</b>
&nbsp;                    //only bleeds when linear filtering is on at startup
<b class="nc">&nbsp;                    if(bleed){</b>
<b class="nc">&nbsp;                        Pixmaps.bleed(pix, 2);</b>
&nbsp;                    }
&nbsp;                    //this returns a *runnable* which actually packs the resulting pixmap; this has to be done synchronously outside the method
<b class="nc">&nbsp;                    return () -&gt; {</b>
&nbsp;                        //don&#39;t prefix with mod name if it&#39;s already prefixed by a category, e.g. `block-modname-content-full`.
<b class="nc">&nbsp;                        int hyphen = baseName.indexOf(&#39;-&#39;);</b>
<b class="nc">&nbsp;                        String fullName = ((prefix &amp;&amp; !(hyphen != -1 &amp;&amp; baseName.substring(hyphen + 1).startsWith(mod.name + &quot;-&quot;))) ? mod.name + &quot;-&quot; : &quot;&quot;) + baseName;</b>
&nbsp;
<b class="nc">&nbsp;                        packer.add(getPage(file), fullName, new PixmapRegion(pix));</b>
<b class="nc">&nbsp;                        if(textureScale != 1.0f){</b>
<b class="nc">&nbsp;                            textureResize.put(fullName, textureScale);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        pix.dispose();</b>
&nbsp;                    };
<b class="nc">&nbsp;                }catch(Exception e){</b>
&nbsp;                    //rethrow exception with details about the cause of failure
<b class="nc">&nbsp;                    throw new Exception(&quot;Failed to load image &quot; + file + &quot; for mod &quot; + mod.name, e);</b>
&nbsp;                }
&nbsp;            }));
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void loadSync(){
<b class="nc">&nbsp;        loadIcons();</b>
&nbsp;
<b class="nc">&nbsp;        if(packer == null) return;</b>
<b class="nc">&nbsp;        Time.mark();</b>
&nbsp;
&nbsp;        //get textures packed
<b class="nc">&nbsp;        if(totalSprites &gt; 0){</b>
&nbsp;
&nbsp;            class RegionEntry{
&nbsp;                String name;
&nbsp;                PixmapRegion region;
&nbsp;                int[] splits, pads;
&nbsp;
<b class="nc">&nbsp;                RegionEntry(String name, PixmapRegion region, int[] splits, int[] pads){</b>
<b class="nc">&nbsp;                    this.name = name;</b>
<b class="nc">&nbsp;                    this.region = region;</b>
<b class="nc">&nbsp;                    this.splits = splits;</b>
<b class="nc">&nbsp;                    this.pads = pads;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Seq&lt;RegionEntry&gt;[] entries = new Seq[PageType.all.length];</b>
<b class="nc">&nbsp;            for(int i = 0; i &lt; PageType.all.length; i++){</b>
<b class="nc">&nbsp;                entries[i] = new Seq&lt;&gt;();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            ObjectMap&lt;Texture, PageType&gt; pageTypes = ObjectMap.of(</b>
<b class="nc">&nbsp;            Core.atlas.find(&quot;white&quot;).texture, PageType.main,</b>
<b class="nc">&nbsp;            Core.atlas.find(&quot;stone1&quot;).texture, PageType.environment,</b>
<b class="nc">&nbsp;            Core.atlas.find(&quot;clear-editor&quot;).texture, PageType.editor,</b>
<b class="nc">&nbsp;            Core.atlas.find(&quot;whiteui&quot;).texture, PageType.ui,</b>
<b class="nc">&nbsp;            Core.atlas.find(&quot;rubble-1-0&quot;).texture, PageType.rubble</b>
&nbsp;            );
&nbsp;
<b class="nc">&nbsp;            for(AtlasRegion region : Core.atlas.getRegions()){</b>
<b class="nc">&nbsp;                PageType type = pageTypes.get(region.texture, PageType.main);</b>
&nbsp;
<b class="nc">&nbsp;                if(!packer.has(type, region.name)){</b>
<b class="nc">&nbsp;                    entries[type.ordinal()].add(new RegionEntry(region.name, Core.atlas.getPixmap(region), region.splits, region.pads));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //sort each page type by size first, for optimal packing
<b class="nc">&nbsp;            for(int i = 0; i &lt; PageType.all.length; i++){</b>
<b class="nc">&nbsp;                var rects = entries[i];</b>
<b class="nc">&nbsp;                var type = PageType.all[i];</b>
&nbsp;                //TODO is this in reverse order?
<b class="nc">&nbsp;                rects.sort(Structs.comparingInt(o -&gt; -Math.max(o.region.width, o.region.height)));</b>
&nbsp;
<b class="nc">&nbsp;                for(var entry : rects){</b>
<b class="nc">&nbsp;                    packer.add(type, entry.name, entry.region, entry.splits, entry.pads);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Core.atlas.dispose();</b>
&nbsp;
&nbsp;            //dead shadow-atlas for getting regions, but not pixmaps
<b class="nc">&nbsp;            var shadow = Core.atlas;</b>
&nbsp;            //dummy texture atlas that returns the &#39;shadow&#39; regions; used for mod loading
<b class="nc">&nbsp;            Core.atlas = new TextureAtlas(){</b>
&nbsp;                {
&nbsp;                    //needed for the correct operation of the found() method in the TextureRegion
<b class="nc">&nbsp;                    error = shadow.find(&quot;error&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AtlasRegion find(String name){
<b class="nc">&nbsp;                    var base = packer.get(name);</b>
&nbsp;
<b class="nc">&nbsp;                    if(base != null){</b>
<b class="nc">&nbsp;                        var reg = new AtlasRegion(shadow.find(name).texture, base.x, base.y, base.width, base.height);</b>
<b class="nc">&nbsp;                        reg.name = name;</b>
<b class="nc">&nbsp;                        reg.pixmapRegion = base;</b>
<b class="nc">&nbsp;                        return reg;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return shadow.find(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isFound(TextureRegion region){
<b class="nc">&nbsp;                    return region != shadow.find(&quot;error&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TextureRegion find(String name, TextureRegion def){
<b class="nc">&nbsp;                    return !has(name) ? def : find(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean has(String s){
<b class="nc">&nbsp;                    return shadow.has(s) || packer.get(s) != null;</b>
&nbsp;                }
&nbsp;
&nbsp;                //return the *actual* pixmap regions, not the disposed ones.
&nbsp;                @Override
&nbsp;                public PixmapRegion getPixmap(AtlasRegion region){
<b class="nc">&nbsp;                    PixmapRegion out = packer.get(region.name);</b>
&nbsp;                    //this should not happen in normal situations
<b class="nc">&nbsp;                    if(out == null) return packer.get(&quot;error&quot;);</b>
<b class="nc">&nbsp;                    return out;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
<b class="nc">&nbsp;            TextureFilter filter = Core.settings.getBool(&quot;linear&quot;, true) ? TextureFilter.linear : TextureFilter.nearest;</b>
&nbsp;
<b class="nc">&nbsp;            Time.mark();</b>
&nbsp;            //generate new icons
<b class="nc">&nbsp;            for(Seq&lt;Content&gt; arr : content.getContentMap()){</b>
<b class="nc">&nbsp;                arr.each(c -&gt; {</b>
&nbsp;                    //TODO this can be done in parallel
<b class="nc">&nbsp;                    if(c instanceof UnlockableContent u &amp;&amp; c.minfo.mod != null){</b>
<b class="nc">&nbsp;                        u.load();</b>
<b class="nc">&nbsp;                        u.loadIcon();</b>
<b class="nc">&nbsp;                        if(u.generateIcons &amp;&amp; !c.minfo.mod.meta.pregenerated){</b>
<b class="nc">&nbsp;                            u.createIcons(packer);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                });
&nbsp;            }
<b class="nc">&nbsp;            Log.debug(&quot;Time to generate icons: @&quot;, Time.elapsed());</b>
&nbsp;
&nbsp;            //dispose old atlas data
<b class="nc">&nbsp;            Core.atlas = packer.flush(filter, new TextureAtlas(){</b>
<b class="nc">&nbsp;                PixmapRegion fake = new PixmapRegion(new Pixmap(1, 1));</b>
<b class="nc">&nbsp;                boolean didWarn = false;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public PixmapRegion getPixmap(AtlasRegion region){
<b class="nc">&nbsp;                    var other = super.getPixmap(region);</b>
<b class="nc">&nbsp;                    if(other.pixmap.isDisposed()){</b>
<b class="nc">&nbsp;                        if(!didWarn){</b>
<b class="nc">&nbsp;                            Log.err(new RuntimeException(&quot;Calling getPixmap outside of createIcons is not supported! This will be a crash in the future.&quot;));</b>
<b class="nc">&nbsp;                            didWarn = true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return fake;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return other;</b>
&nbsp;                }
&nbsp;            });
&nbsp;
<b class="nc">&nbsp;            textureResize.each(e -&gt; Core.atlas.find(e.key).scale = e.value);</b>
&nbsp;
<b class="nc">&nbsp;            Core.atlas.setErrorRegion(&quot;error&quot;);</b>
<b class="nc">&nbsp;            Log.debug(&quot;Total pages: @&quot;, Core.atlas.getTextures().size);</b>
&nbsp;
<b class="nc">&nbsp;            packer.printStats();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        packer.dispose();</b>
<b class="nc">&nbsp;        packer = null;</b>
<b class="nc">&nbsp;        Log.debug(&quot;Total time to generate &amp; flush textures synchronously: @&quot;, Time.elapsed());</b>
&nbsp;    }
&nbsp;
&nbsp;    private PageType getPage(Fi file){
<b class="nc">&nbsp;        String path = file.path();</b>
&nbsp;        return
<b class="nc">&nbsp;            path.contains(&quot;sprites/blocks/environment&quot;) || path.contains(&quot;sprites-override/blocks/environment&quot;) ? PageType.environment :</b>
<b class="nc">&nbsp;            path.contains(&quot;sprites/editor&quot;) || path.contains(&quot;sprites-override/editor&quot;) ? PageType.editor :</b>
<b class="nc">&nbsp;            path.contains(&quot;sprites/rubble&quot;) || path.contains(&quot;sprites-override/rubble&quot;) ? PageType.rubble :</b>
<b class="nc">&nbsp;            path.contains(&quot;sprites/ui&quot;) || path.contains(&quot;sprites-override/ui&quot;) ? PageType.ui :</b>
<b class="nc">&nbsp;            PageType.main;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Removes a mod file and marks it for requiring a restart. */
&nbsp;    public void removeMod(LoadedMod mod){
<b class="nc">&nbsp;        if(mod.root instanceof ZipFi){</b>
<b class="nc">&nbsp;            mod.root.delete();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean deleted = mod.file.isDirectory() ? mod.file.deleteDirectory() : mod.file.delete();</b>
&nbsp;
<b class="nc">&nbsp;        if(!deleted){</b>
<b class="nc">&nbsp;            ui.showErrorMessage(&quot;@mod.delete.error&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        mods.remove(mod);</b>
<b class="nc">&nbsp;        mod.dispose();</b>
<b class="nc">&nbsp;        requiresReload = true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Scripts getScripts(){
<b class="fc">&nbsp;        if(scripts == null) scripts = platform.createScripts();</b>
<b class="fc">&nbsp;        return scripts;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return whether the scripting engine has been initialized. */
&nbsp;    public boolean hasScripts(){
<b class="nc">&nbsp;        return scripts != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean requiresReload(){
<b class="nc">&nbsp;        return requiresReload;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return whether to skip mod loading due to previous initialization failure. */
&nbsp;    public boolean skipModLoading(){
<b class="fc">&nbsp;        return failedToLaunch &amp;&amp; Core.settings.getBool(&quot;modcrashdisable&quot;, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Loads all mods from the folder, but does not call any methods on them.*/
&nbsp;    public void load(){
<b class="fc">&nbsp;        var candidates = new Seq&lt;Fi&gt;();</b>
&nbsp;
&nbsp;        // Add local mods
<b class="fc">&nbsp;        Seq.with(modDirectory.list())</b>
<b class="fc">&nbsp;        .retainAll(f -&gt; f.extEquals(&quot;jar&quot;) || f.extEquals(&quot;zip&quot;) || (f.isDirectory() &amp;&amp; Structs.contains(metaFiles, meta -&gt; f.child(meta).exists())))</b>
<b class="fc">&nbsp;        .each(candidates::add);</b>
&nbsp;
&nbsp;        // Add Steam workshop mods
<b class="fc">&nbsp;        platform.getWorkshopContent(LoadedMod.class)</b>
<b class="fc">&nbsp;        .each(candidates::add);</b>
&nbsp;
<b class="fc">&nbsp;        var mapping = new ObjectMap&lt;String, Fi&gt;();</b>
<b class="fc">&nbsp;        var metas = new Seq&lt;ModMeta&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for(Fi file : candidates){</b>
<b class="fc">&nbsp;            ModMeta meta = null;</b>
&nbsp;
&nbsp;            try{
<b class="fc">&nbsp;                Fi zip = file.isDirectory() ? file : new ZipFi(file);</b>
&nbsp;
<b class="fc">&nbsp;                if(zip.list().length == 1 &amp;&amp; zip.list()[0].isDirectory()){</b>
<b class="fc">&nbsp;                    zip = zip.list()[0];</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                meta = findMeta(zip);</b>
<b class="nc">&nbsp;            }catch(Throwable ignored){</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            if(meta == null || meta.name == null) continue;</b>
<b class="fc">&nbsp;            metas.add(meta);</b>
<b class="fc">&nbsp;            mapping.put(meta.internalName, file);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        var resolved = resolveDependencies(metas);</b>
<b class="fc">&nbsp;        for(var entry : resolved){</b>
<b class="fc">&nbsp;            var file = mapping.get(entry.key);</b>
<b class="fc">&nbsp;            var steam = platform.getWorkshopContent(LoadedMod.class).contains(file);</b>
&nbsp;
<b class="fc">&nbsp;            Log.debug(&quot;[Mods] Loading mod @&quot;, file);</b>
&nbsp;
&nbsp;            try{
<b class="fc">&nbsp;                LoadedMod mod = loadMod(file, false, entry.value == ModState.enabled);</b>
<b class="fc">&nbsp;                mod.state = entry.value;</b>
<b class="fc">&nbsp;                mods.add(mod);</b>
&nbsp;                //invalidate ordered mods cache
<b class="fc">&nbsp;                lastOrderedMods = null;</b>
<b class="fc">&nbsp;                if(steam) mod.addSteamID(file.name());</b>
<b class="nc">&nbsp;            }catch(Throwable e){</b>
<b class="nc">&nbsp;                if(e instanceof ClassNotFoundException &amp;&amp; e.getMessage().contains(&quot;mindustry.plugin.Plugin&quot;)){</b>
<b class="nc">&nbsp;                    Log.info(&quot;Plugin &#39;@&#39; is outdated and needs to be ported to 6.0! Update its main class to inherit from &#39;mindustry.mod.Plugin&#39;. See https://mindustrygame.github.io/wiki/modding/6-migrationv6/&quot;, file.name());</b>
<b class="nc">&nbsp;                }else if(steam){</b>
<b class="nc">&nbsp;                    Log.err(&quot;Failed to load mod workshop file @. Skipping.&quot;, file);</b>
<b class="nc">&nbsp;                    Log.err(e);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    Log.err(&quot;Failed to load mod file @. Skipping.&quot;, file);</b>
<b class="nc">&nbsp;                    Log.err(e);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Resolve the state
<b class="fc">&nbsp;        mods.each(this::updateDependencies);</b>
<b class="fc">&nbsp;        for(var mod : mods){</b>
&nbsp;            // Skip mods where the state has already been resolved
<b class="fc">&nbsp;            if(mod.state != ModState.enabled) continue;</b>
<b class="fc">&nbsp;            if(!mod.isSupported()){</b>
<b class="nc">&nbsp;                mod.state = ModState.unsupported;</b>
<b class="fc">&nbsp;            }else if(!mod.shouldBeEnabled()){</b>
<b class="nc">&nbsp;                mod.state = ModState.disabled;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        sortMods();</b>
<b class="fc">&nbsp;        buildFiles();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sortMods(){
&nbsp;        //sort mods to make sure servers handle them properly and they appear correctly in the dialog
<b class="fc">&nbsp;        mods.sort(Structs.comps(Structs.comparingInt(m -&gt; m.state.ordinal()), Structs.comparing(m -&gt; m.name)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateDependencies(LoadedMod mod){
<b class="fc">&nbsp;        mod.dependencies.clear();</b>
<b class="fc">&nbsp;        mod.missingDependencies.clear();</b>
<b class="fc">&nbsp;        mod.dependencies = mod.meta.dependencies.map(this::locateMod);</b>
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; mod.dependencies.size; i++){</b>
<b class="nc">&nbsp;            if(mod.dependencies.get(i) == null){</b>
<b class="nc">&nbsp;                mod.missingDependencies.add(mod.meta.dependencies.get(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @return mods ordered in the correct way needed for dependencies. */
&nbsp;    public Seq&lt;LoadedMod&gt; orderedMods(){
&nbsp;        //update cache if it&#39;s &quot;dirty&quot;/empty
<b class="fc">&nbsp;        if(lastOrderedMods == null){</b>
&nbsp;            //only enabled mods participate; this state is resolved in load()
<b class="fc">&nbsp;            Seq&lt;LoadedMod&gt; enabled = mods.select(LoadedMod::enabled);</b>
&nbsp;
<b class="fc">&nbsp;            var mapping = enabled.asMap(m -&gt; m.meta.internalName);</b>
<b class="fc">&nbsp;            lastOrderedMods = resolveDependencies(enabled.map(m -&gt; m.meta)).orderedKeys().map(mapping::get);</b>
&nbsp;        }
<b class="fc">&nbsp;        return lastOrderedMods;</b>
&nbsp;    }
&nbsp;
&nbsp;    public LoadedMod locateMod(String name){
<b class="fc">&nbsp;        return mods.find(mod -&gt; mod.enabled() &amp;&amp; mod.name.equals(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void buildFiles(){
<b class="fc">&nbsp;        for(LoadedMod mod : orderedMods()){</b>
<b class="fc">&nbsp;            boolean zipFolder = !mod.file.isDirectory() &amp;&amp; mod.root.parent() != null;</b>
<b class="fc">&nbsp;            String parentName = zipFolder ? mod.root.name() : null;</b>
<b class="fc">&nbsp;            for(Fi file : mod.root.list()){</b>
&nbsp;                //ignore special folders like bundles or sprites
<b class="fc">&nbsp;                if(file.isDirectory() &amp;&amp; !specialFolders.contains(file.name())){</b>
<b class="fc">&nbsp;                    file.walk(f -&gt; tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :</b>
<b class="fc">&nbsp;                        zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //load up bundles.
<b class="fc">&nbsp;            Fi folder = mod.root.child(&quot;bundles&quot;);</b>
<b class="fc">&nbsp;            if(folder.exists()){</b>
<b class="fc">&nbsp;                for(Fi file : folder.list()){</b>
<b class="fc">&nbsp;                    if(file.name().startsWith(&quot;bundle&quot;) &amp;&amp; file.extension().equals(&quot;properties&quot;)){</b>
<b class="fc">&nbsp;                        String name = file.nameWithoutExtension();</b>
<b class="fc">&nbsp;                        bundles.get(name, Seq::new).add(file);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        Events.fire(new FileTreeInitEvent());</b>
&nbsp;
&nbsp;        //add new keys to each bundle
<b class="fc">&nbsp;        I18NBundle bundle = Core.bundle;</b>
<b class="fc">&nbsp;        while(bundle != null){</b>
<b class="fc">&nbsp;            String str = bundle.getLocale().toString();</b>
<b class="fc">&nbsp;            String locale = &quot;bundle&quot; + (str.isEmpty() ? &quot;&quot; : &quot;_&quot; + str);</b>
<b class="fc">&nbsp;            for(Fi file : bundles.get(locale, Seq::new)){</b>
&nbsp;                try{
<b class="fc">&nbsp;                    PropertiesUtils.load(bundle.getProperties(), file.reader());</b>
<b class="nc">&nbsp;                }catch(Throwable e){</b>
<b class="nc">&nbsp;                    Log.err(&quot;Error loading bundle: &quot; + file + &quot;/&quot; + locale, e);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            bundle = bundle.getParent();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Check all warnings related to content and show relevant dialogs. Client only. */
&nbsp;    private void checkWarnings(){
&nbsp;        //show &#39;scripts have errored&#39; info
<b class="nc">&nbsp;        if(scripts != null &amp;&amp; scripts.hasErrored()){</b>
<b class="nc">&nbsp;           ui.showErrorMessage(&quot;@mod.scripts.disable&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //show list of errored content
<b class="nc">&nbsp;        if(mods.contains(LoadedMod::hasContentErrors)){</b>
<b class="nc">&nbsp;            ui.loadfrag.hide();</b>
<b class="nc">&nbsp;            new Dialog(&quot;&quot;){{</b>
&nbsp;
<b class="nc">&nbsp;                setFillParent(true);</b>
<b class="nc">&nbsp;                cont.margin(15);</b>
<b class="nc">&nbsp;                cont.add(&quot;@error.title&quot;);</b>
<b class="nc">&nbsp;                cont.row();</b>
<b class="nc">&nbsp;                cont.image().width(300f).pad(2).colspan(2).height(4f).color(Color.scarlet);</b>
<b class="nc">&nbsp;                cont.row();</b>
<b class="nc">&nbsp;                cont.add(&quot;@mod.errors&quot;).wrap().growX().center().get().setAlignment(Align.center);</b>
<b class="nc">&nbsp;                cont.row();</b>
<b class="nc">&nbsp;                cont.pane(p -&gt; {</b>
<b class="nc">&nbsp;                    mods.each(m -&gt; m.enabled() &amp;&amp; m.hasContentErrors(), m -&gt; {</b>
<b class="nc">&nbsp;                        p.add(m.name).color(Pal.accent).left();</b>
<b class="nc">&nbsp;                        p.row();</b>
<b class="nc">&nbsp;                        p.image().fillX().pad(4).color(Pal.accent);</b>
<b class="nc">&nbsp;                        p.row();</b>
<b class="nc">&nbsp;                        p.table(d -&gt; {</b>
<b class="nc">&nbsp;                            d.left().marginLeft(15f);</b>
<b class="nc">&nbsp;                            for(Content c : m.erroredContent){</b>
<b class="nc">&nbsp;                                d.add(c.minfo.sourceFile.nameWithoutExtension()).left().padRight(10);</b>
<b class="nc">&nbsp;                                d.button(&quot;@details&quot;, Icon.downOpen, Styles.cleart, () -&gt; {</b>
<b class="nc">&nbsp;                                    new Dialog(&quot;&quot;){{</b>
<b class="nc">&nbsp;                                        setFillParent(true);</b>
<b class="nc">&nbsp;                                        cont.pane(e -&gt; e.add(c.minfo.error).wrap().grow().labelAlign(Align.center, Align.left)).grow();</b>
<b class="nc">&nbsp;                                        cont.row();</b>
<b class="nc">&nbsp;                                        cont.button(&quot;@ok&quot;, Icon.left, this::hide).size(240f, 60f);</b>
<b class="nc">&nbsp;                                    }}.show();</b>
<b class="nc">&nbsp;                                }).size(190f, 50f).left().marginLeft(6);</b>
<b class="nc">&nbsp;                                d.row();</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        }).left();</b>
<b class="nc">&nbsp;                        p.row();</b>
&nbsp;                    });
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;                cont.row();</b>
<b class="nc">&nbsp;                cont.button(&quot;@ok&quot;, this::hide).size(300, 50);</b>
<b class="nc">&nbsp;            }}.show();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasContentErrors(){
<b class="fc">&nbsp;        return mods.contains(LoadedMod::hasContentErrors) || (scripts != null &amp;&amp; scripts.hasErrored());</b>
&nbsp;    }
&nbsp;
&nbsp;    /** This must be run on the main thread! */
&nbsp;    public void loadScripts(){
<b class="fc">&nbsp;        Time.mark();</b>
<b class="fc">&nbsp;        boolean[] any = {false};</b>
&nbsp;
&nbsp;        try{
<b class="fc">&nbsp;            eachEnabled(mod -&gt; {</b>
<b class="fc">&nbsp;                if(mod.root.child(&quot;scripts&quot;).exists()){</b>
<b class="fc">&nbsp;                    content.setCurrentMod(mod);</b>
&nbsp;                    //if there&#39;s only one script file, use it (for backwards compatibility); if there isn&#39;t, use &quot;main.js&quot;
<b class="fc">&nbsp;                    Seq&lt;Fi&gt; allScripts = mod.root.child(&quot;scripts&quot;).findAll(f -&gt; f.extEquals(&quot;js&quot;));</b>
<b class="fc">&nbsp;                    Fi main = allScripts.size == 1 ? allScripts.first() : mod.root.child(&quot;scripts&quot;).child(&quot;main.js&quot;);</b>
<b class="fc">&nbsp;                    if(main.exists() &amp;&amp; !main.isDirectory()){</b>
&nbsp;                        try{
<b class="fc">&nbsp;                            if(scripts == null){</b>
<b class="fc">&nbsp;                                scripts = platform.createScripts();</b>
&nbsp;                            }
<b class="fc">&nbsp;                            any[0] = true;</b>
<b class="fc">&nbsp;                            scripts.run(mod, main);</b>
<b class="nc">&nbsp;                        }catch(Throwable e){</b>
<b class="nc">&nbsp;                            Core.app.post(() -&gt; {</b>
<b class="nc">&nbsp;                                Log.err(&quot;Error loading main script @ for mod @.&quot;, main.name(), mod.meta.name);</b>
<b class="nc">&nbsp;                                Log.err(e);</b>
&nbsp;                            });
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        Core.app.post(() -&gt; Log.err(&quot;No main.js found for mod @.&quot;, mod.meta.name));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            });
&nbsp;        }finally{
<b class="fc">&nbsp;            content.setCurrentMod(null);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if(any[0]){</b>
<b class="fc">&nbsp;            Log.info(&quot;Time to initialize modded scripts: @&quot;, Time.elapsed());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Creates all the content found in mod files. */
&nbsp;    public void loadContent(){
&nbsp;
&nbsp;        //load class mod content first
<b class="fc">&nbsp;        for(LoadedMod mod : orderedMods()){</b>
&nbsp;            //hidden mods can&#39;t load content
<b class="fc">&nbsp;            if(mod.main != null &amp;&amp; !mod.meta.hidden){</b>
<b class="fc">&nbsp;                content.setCurrentMod(mod);</b>
<b class="fc">&nbsp;                mod.main.loadContent();</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        content.setCurrentMod(null);</b>
&nbsp;
&nbsp;        class LoadRun implements Comparable&lt;LoadRun&gt;{
&nbsp;            final ContentType type;
&nbsp;            final Fi file;
&nbsp;            final LoadedMod mod;
&nbsp;
<b class="fc">&nbsp;            public LoadRun(ContentType type, Fi file, LoadedMod mod){</b>
<b class="fc">&nbsp;                this.type = type;</b>
<b class="fc">&nbsp;                this.file = file;</b>
<b class="fc">&nbsp;                this.mod = mod;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int compareTo(LoadRun l){
<b class="fc">&nbsp;                int mod = this.mod.name.compareTo(l.mod.name);</b>
<b class="fc">&nbsp;                if(mod != 0) return mod;</b>
<b class="fc">&nbsp;                return this.file.name().compareTo(l.file.name());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Seq&lt;LoadRun&gt; runs = new Seq&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for(LoadedMod mod : orderedMods()){</b>
<b class="fc">&nbsp;            Seq&lt;LoadRun&gt; unorderedContent = new Seq&lt;&gt;();</b>
<b class="fc">&nbsp;            ObjectMap&lt;String, LoadRun&gt; orderedContent = new ObjectMap&lt;&gt;();</b>
<b class="fc">&nbsp;            String[] contentOrder = mod.meta.contentOrder;</b>
<b class="fc">&nbsp;            ObjectSet&lt;String&gt; orderSet = contentOrder == null ? null : ObjectSet.with(contentOrder);</b>
&nbsp;
<b class="fc">&nbsp;            if(mod.root.child(&quot;content&quot;).exists()){</b>
<b class="fc">&nbsp;                Fi contentRoot = mod.root.child(&quot;content&quot;);</b>
<b class="fc">&nbsp;                for(ContentType type : ContentType.all){</b>
<b class="fc">&nbsp;                    String lower = type.name().toLowerCase(Locale.ROOT);</b>
<b class="fc">&nbsp;                    Fi folder = contentRoot.child(lower + (lower.endsWith(&quot;s&quot;) ? &quot;&quot; : &quot;s&quot;));</b>
<b class="fc">&nbsp;                    if(folder.exists()){</b>
<b class="fc">&nbsp;                        for(Fi file : folder.findAll(f -&gt; f.extension().equals(&quot;json&quot;) || f.extension().equals(&quot;hjson&quot;))){</b>
&nbsp;
&nbsp;                            //if this is part of the ordered content, put it aside to be dealt with later
<b class="fc">&nbsp;                            if(orderSet != null &amp;&amp; orderSet.contains(file.nameWithoutExtension())){</b>
<b class="nc">&nbsp;                                orderedContent.put(file.nameWithoutExtension(), new LoadRun(type, file, mod));</b>
&nbsp;                            }else{
<b class="fc">&nbsp;                                unorderedContent.add(new LoadRun(type, file, mod));</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //ordered content will be loaded first, if it exists
<b class="fc">&nbsp;            if(contentOrder != null){</b>
<b class="nc">&nbsp;                for(String contentName : contentOrder){</b>
<b class="nc">&nbsp;                    LoadRun run = orderedContent.get(contentName);</b>
<b class="nc">&nbsp;                    if(run != null){</b>
<b class="nc">&nbsp;                        runs.add(run);</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        Log.warn(&quot;Cannot find content defined in contentOrder: @&quot;, contentName);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //unordered content is sorted alphabetically per mod
<b class="fc">&nbsp;            runs.addAll(unorderedContent.sort());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for(LoadRun l : runs){</b>
<b class="fc">&nbsp;            Content current = content.getLastAdded();</b>
&nbsp;            try{
&nbsp;                //this binds the content but does not load it entirely
<b class="fc">&nbsp;                Content loaded = parser.parse(l.mod, l.file.nameWithoutExtension(), l.file.readString(&quot;UTF-8&quot;), l.file, l.type);</b>
<b class="fc">&nbsp;                Log.debug(&quot;[@] Loaded &#39;@&#39;.&quot;, l.mod.meta.name, (loaded instanceof UnlockableContent u ? u.localizedName : loaded));</b>
<b class="nc">&nbsp;            }catch(Throwable e){</b>
<b class="nc">&nbsp;                if(current != content.getLastAdded() &amp;&amp; content.getLastAdded() != null){</b>
<b class="nc">&nbsp;                    parser.markError(content.getLastAdded(), l.mod, l.file, e);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    ErrorContent error = new ErrorContent();</b>
<b class="nc">&nbsp;                    parser.markError(error, l.mod, l.file, e);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        //this finishes parsing content fields
<b class="fc">&nbsp;        parser.finishParsing();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void handleContentError(Content content, Throwable error){
<b class="nc">&nbsp;        parser.markError(content, error);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Adds a listener for parsed JSON objects. */
&nbsp;    public void addParseListener(ParseListener hook){
<b class="nc">&nbsp;        parser.listeners.add(hook);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @return a list of mods and versions, in the format name:version. */
&nbsp;    public Seq&lt;String&gt; getModStrings(){
<b class="fc">&nbsp;        return mods.select(l -&gt; !l.meta.hidden &amp;&amp; l.enabled()).map(l -&gt; l.name + &quot;:&quot; + l.meta.version);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Makes a mod enabled or disabled. shifts it.*/
&nbsp;    public void setEnabled(LoadedMod mod, boolean enabled){
<b class="nc">&nbsp;        if(mod.enabled() != enabled){</b>
<b class="nc">&nbsp;            Core.settings.put(&quot;mod-&quot; + mod.name + &quot;-enabled&quot;, enabled);</b>
<b class="nc">&nbsp;            requiresReload = true;</b>
<b class="nc">&nbsp;            mod.state = enabled ? ModState.enabled : ModState.disabled;</b>
<b class="nc">&nbsp;            mods.each(this::updateDependencies);</b>
<b class="nc">&nbsp;            sortMods();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @return the mods that the client is missing.
&nbsp;     * The inputted array is changed to contain the extra mods that the client has but the server doesn&#39;t.*/
&nbsp;    public Seq&lt;String&gt; getIncompatibility(Seq&lt;String&gt; out){
<b class="nc">&nbsp;        Seq&lt;String&gt; mods = getModStrings();</b>
<b class="nc">&nbsp;        Seq&lt;String&gt; result = mods.copy();</b>
<b class="nc">&nbsp;        for(String mod : mods){</b>
<b class="nc">&nbsp;            if(out.remove(mod)){</b>
<b class="nc">&nbsp;                result.remove(mod);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Seq&lt;LoadedMod&gt; list(){
<b class="fc">&nbsp;        return mods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Iterates through each mod with a main class. */
&nbsp;    public void eachClass(Cons&lt;Mod&gt; cons){
<b class="fc">&nbsp;        orderedMods().each(p -&gt; p.main != null, p -&gt; contextRun(p, () -&gt; cons.get(p.main)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Iterates through each enabled mod. */
&nbsp;    public void eachEnabled(Cons&lt;LoadedMod&gt; cons){
<b class="fc">&nbsp;        orderedMods().each(LoadedMod::enabled, cons);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void contextRun(LoadedMod mod, Runnable run){
&nbsp;        try{
<b class="fc">&nbsp;            run.run();</b>
<b class="nc">&nbsp;        }catch(Throwable t){</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Error loading mod &quot; + mod.meta.name, t);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Tries to find the config file of a mod/plugin. */
&nbsp;    public @Nullable ModMeta findMeta(Fi file){
<b class="fc">&nbsp;        Fi metaFile = null;</b>
<b class="fc">&nbsp;        for(String name : metaFiles){</b>
<b class="fc">&nbsp;            if((metaFile = file.child(name)).exists()){</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if(!metaFile.exists()){</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        ModMeta meta = json.fromJson(ModMeta.class, Jval.read(metaFile.readString()).toString(Jformat.plain));</b>
<b class="fc">&nbsp;        meta.cleanup();</b>
<b class="fc">&nbsp;        return meta;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Resolves the loading order of a list mods/plugins using their internal names. */
&nbsp;    public OrderedMap&lt;String, ModState&gt; resolveDependencies(Seq&lt;ModMeta&gt; metas){
<b class="fc">&nbsp;        var context = new ModResolutionContext();</b>
&nbsp;
<b class="fc">&nbsp;        for(var meta : metas){</b>
<b class="fc">&nbsp;            Seq&lt;ModDependency&gt; dependencies = new Seq&lt;&gt;();</b>
<b class="fc">&nbsp;            for(var dependency : meta.dependencies){</b>
<b class="nc">&nbsp;                dependencies.add(new ModDependency(dependency, true));</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            for(var dependency : meta.softDependencies){</b>
<b class="nc">&nbsp;                dependencies.add(new ModDependency(dependency, false));</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            context.dependencies.put(meta.internalName, dependencies);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for(var key : context.dependencies.keys()){</b>
<b class="fc">&nbsp;            if(context.ordered.contains(key)){</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            resolve(key, context);</b>
<b class="fc">&nbsp;            context.visited.clear();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        var result = new OrderedMap&lt;String, ModState&gt;();</b>
<b class="fc">&nbsp;        for(var name : context.ordered){</b>
<b class="fc">&nbsp;            result.put(name, ModState.enabled);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        result.putAll(context.invalid);</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean resolve(String element, ModResolutionContext context){
<b class="fc">&nbsp;        context.visited.add(element);</b>
<b class="fc">&nbsp;        for(final var dependency : context.dependencies.get(element)){</b>
&nbsp;            // Circular dependencies ?
<b class="nc">&nbsp;            if(context.visited.contains(dependency.name) &amp;&amp; !context.ordered.contains(dependency.name)){</b>
<b class="nc">&nbsp;                context.invalid.put(dependency.name, ModState.circularDependencies);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;                // If dependency present, resolve it, or if it&#39;s not required, ignore it
<b class="nc">&nbsp;            }else if(context.dependencies.containsKey(dependency.name)){</b>
<b class="nc">&nbsp;                if(((!context.ordered.contains(dependency.name) &amp;&amp; !resolve(dependency.name, context)) || !Core.settings.getBool(&quot;mod-&quot; + dependency.name + &quot;-enabled&quot;, true)) &amp;&amp; dependency.required){</b>
<b class="nc">&nbsp;                    context.invalid.put(element, ModState.incompleteDependencies);</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                // The dependency is missing, but if not required, skip
<b class="nc">&nbsp;            }else if(dependency.required){</b>
<b class="nc">&nbsp;                context.invalid.put(element, ModState.missingDependencies);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        if(!context.ordered.contains(element)){</b>
<b class="fc">&nbsp;            context.ordered.add(element);</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Loads a mod file+meta, but does not add it to the list.
&nbsp;     * Note that directories can be loaded as mods. */
&nbsp;    private LoadedMod loadMod(Fi sourceFile) throws Exception{
<b class="nc">&nbsp;        return loadMod(sourceFile, false, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Loads a mod file+meta, but does not add it to the list.
&nbsp;     * Note that directories can be loaded as mods. */
&nbsp;    private LoadedMod loadMod(Fi sourceFile, boolean overwrite, boolean initialize) throws Exception{
<b class="fc">&nbsp;        Time.mark();</b>
&nbsp;
<b class="fc">&nbsp;        ZipFi rootZip = null;</b>
&nbsp;
&nbsp;        try{
<b class="fc">&nbsp;            Fi zip = sourceFile.isDirectory() ? sourceFile : (rootZip = new ZipFi(sourceFile));</b>
<b class="fc">&nbsp;            if(zip.list().length == 1 &amp;&amp; zip.list()[0].isDirectory()){</b>
<b class="fc">&nbsp;                zip = zip.list()[0];</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            ModMeta meta = findMeta(zip);</b>
&nbsp;
<b class="fc">&nbsp;            if(meta == null){</b>
<b class="nc">&nbsp;                Log.warn(&quot;Mod @ doesn&#39;t have a &#39;[mod/plugin].[h]json&#39; file, skipping.&quot;, zip);</b>
<b class="nc">&nbsp;                throw new ModLoadException(&quot;Invalid file: No mod.json found.&quot;);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            String camelized = meta.name.replace(&quot; &quot;, &quot;&quot;);</b>
<b class="fc">&nbsp;            String mainClass = meta.main == null ? camelized.toLowerCase(Locale.ROOT) + &quot;.&quot; + camelized + &quot;Mod&quot; : meta.main;</b>
<b class="fc">&nbsp;            String baseName = meta.name.toLowerCase(Locale.ROOT).replace(&quot; &quot;, &quot;-&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            var other = mods.find(m -&gt; m.name.equals(baseName));</b>
&nbsp;
<b class="fc">&nbsp;            if(other != null){</b>
&nbsp;                //steam mods can&#39;t really be deleted, they need to be unsubscribed
<b class="nc">&nbsp;                if(overwrite &amp;&amp; !other.hasSteamID()){</b>
&nbsp;                    //close zip file
<b class="nc">&nbsp;                    if(other.root instanceof ZipFi){</b>
<b class="nc">&nbsp;                        other.root.delete();</b>
&nbsp;                    }
&nbsp;                    //delete the old mod directory
<b class="nc">&nbsp;                    if(other.file.isDirectory()){</b>
<b class="nc">&nbsp;                        other.file.deleteDirectory();</b>
&nbsp;                    }else{
<b class="nc">&nbsp;                        other.file.delete();</b>
&nbsp;                    }
&nbsp;                    //unload
<b class="nc">&nbsp;                    mods.remove(other);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    throw new ModLoadException(&quot;A mod with the name &#39;&quot; + baseName + &quot;&#39; is already imported.&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            ClassLoader loader = null;</b>
&nbsp;            Mod mainMod;
<b class="fc">&nbsp;            Fi mainFile = zip;</b>
&nbsp;
<b class="fc">&nbsp;            if(android){</b>
<b class="nc">&nbsp;                mainFile = mainFile.child(&quot;classes.dex&quot;);</b>
&nbsp;            }else{
<b class="fc">&nbsp;                String[] path = (mainClass.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;).split(&quot;/&quot;);</b>
<b class="fc">&nbsp;                for(String str : path){</b>
<b class="fc">&nbsp;                    if(!str.isEmpty()){</b>
<b class="fc">&nbsp;                        mainFile = mainFile.child(str);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //make sure the main class exists before loading it; if it doesn&#39;t just don&#39;t put it there
&nbsp;            //if the mod is explicitly marked as java, try loading it anyway
<b class="fc">&nbsp;            if(</b>
<b class="fc">&nbsp;                (mainFile.exists() || meta.java) &amp;&amp;</b>
<b class="fc">&nbsp;                !skipModLoading() &amp;&amp;</b>
<b class="fc">&nbsp;                Core.settings.getBool(&quot;mod-&quot; + baseName + &quot;-enabled&quot;, true) &amp;&amp;</b>
<b class="fc">&nbsp;                Version.isAtLeast(meta.minGameVersion) &amp;&amp;</b>
<b class="fc">&nbsp;                (meta.getMinMajor() &gt;= 136 || headless) &amp;&amp;</b>
&nbsp;                initialize
&nbsp;            ){
<b class="fc">&nbsp;                if(ios){</b>
<b class="nc">&nbsp;                    throw new ModLoadException(&quot;Java class mods are not supported on iOS.&quot;);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                loader = platform.loadJar(sourceFile, mainLoader);</b>
<b class="fc">&nbsp;                mainLoader.addChild(loader);</b>
<b class="fc">&nbsp;                Class&lt;?&gt; main = Class.forName(mainClass, true, loader);</b>
&nbsp;
&nbsp;                //detect mods that incorrectly package mindustry in the jar
<b class="fc">&nbsp;                if((main.getSuperclass().getName().equals(&quot;mindustry.mod.Plugin&quot;) || main.getSuperclass().getName().equals(&quot;mindustry.mod.Mod&quot;)) &amp;&amp;</b>
<b class="fc">&nbsp;                    main.getSuperclass().getClassLoader() != Mod.class.getClassLoader()){</b>
<b class="nc">&nbsp;                    throw new ModLoadException(</b>
&nbsp;                        &quot;This mod/plugin has loaded Mindustry dependencies from its own class loader. &quot; +
&nbsp;                        &quot;You are incorrectly including Mindustry dependencies in the mod JAR - &quot; +
&nbsp;                        &quot;make sure Mindustry is declared as `compileOnly` in Gradle, and that the JAR is created with `runtimeClasspath`!&quot;
&nbsp;                    );
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                metas.put(main, meta);</b>
<b class="fc">&nbsp;                mainMod = (Mod)main.getDeclaredConstructor().newInstance();</b>
<b class="fc">&nbsp;            }else{</b>
<b class="fc">&nbsp;                mainMod = null;</b>
&nbsp;            }
&nbsp;
&nbsp;            //all plugins are hidden implicitly
<b class="fc">&nbsp;            if(mainMod instanceof Plugin){</b>
<b class="nc">&nbsp;                meta.hidden = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            //disallow putting a description after the version
<b class="fc">&nbsp;            if(meta.version != null){</b>
<b class="fc">&nbsp;                int line = meta.version.indexOf(&#39;\n&#39;);</b>
<b class="fc">&nbsp;                if(line != -1){</b>
<b class="nc">&nbsp;                    meta.version = meta.version.substring(0, line);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            //skip mod loading if it failed
<b class="fc">&nbsp;            if(skipModLoading()){</b>
<b class="nc">&nbsp;                Core.settings.put(&quot;mod-&quot; + baseName + &quot;-enabled&quot;, false);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if(!headless &amp;&amp; Core.settings.getBool(&quot;mod-&quot; + baseName + &quot;-enabled&quot;, true)){</b>
<b class="nc">&nbsp;                Log.info(&quot;Loaded mod &#39;@&#39; in @ms&quot;, meta.name, Time.elapsed());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return new LoadedMod(sourceFile, zip, mainMod, loader, meta);</b>
<b class="nc">&nbsp;        }catch(Exception e){</b>
&nbsp;            //delete root zip file so it can be closed on windows
<b class="nc">&nbsp;            if(rootZip != null) rootZip.delete();</b>
<b class="nc">&nbsp;            throw e;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Represents a mod&#39;s state. May be a jar file, folder or zip. */
&nbsp;    public static class LoadedMod implements Publishable, Disposable{
&nbsp;        /** The location of this mod&#39;s zip file/folder on the disk. */
&nbsp;        public final Fi file;
&nbsp;        /** The root zip file; points to the contents of this mod. In the case of folders, this is the same as the mod&#39;s file. */
&nbsp;        public final Fi root;
&nbsp;        /** The mod&#39;s main class; may be null. */
&nbsp;        public final @Nullable Mod main;
&nbsp;        /** Internal mod name. Used for textures. */
&nbsp;        public final String name;
&nbsp;        /** This mod&#39;s metadata. */
&nbsp;        public final ModMeta meta;
&nbsp;        /** This mod&#39;s dependencies as already-loaded mods. */
<b class="fc">&nbsp;        public Seq&lt;LoadedMod&gt; dependencies = new Seq&lt;&gt;();</b>
&nbsp;        /** All missing dependencies of this mod as strings. */
<b class="fc">&nbsp;        public Seq&lt;String&gt; missingDependencies = new Seq&lt;&gt;();</b>
&nbsp;        /** Content with initialization code. */
<b class="fc">&nbsp;        public ObjectSet&lt;Content&gt; erroredContent = new ObjectSet&lt;&gt;();</b>
&nbsp;        /** Current state of this mod. */
<b class="fc">&nbsp;        public ModState state = ModState.enabled;</b>
&nbsp;        /** Icon texture. Should be disposed. */
&nbsp;        public @Nullable Texture iconTexture;
&nbsp;        /** Class loader for JAR mods. Null if the mod isn&#39;t loaded or this isn&#39;t a jar mod. */
&nbsp;        public @Nullable ClassLoader loader;
&nbsp;
<b class="fc">&nbsp;        public LoadedMod(Fi file, Fi root, Mod main, ClassLoader loader, ModMeta meta){</b>
<b class="fc">&nbsp;            this.root = root;</b>
<b class="fc">&nbsp;            this.file = file;</b>
<b class="fc">&nbsp;            this.loader = loader;</b>
<b class="fc">&nbsp;            this.main = main;</b>
<b class="fc">&nbsp;            this.meta = meta;</b>
<b class="fc">&nbsp;            this.name = meta.name.toLowerCase(Locale.ROOT).replace(&quot; &quot;, &quot;-&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return whether this is a java class mod. */
&nbsp;        public boolean isJava(){
<b class="nc">&nbsp;            return meta.java || main != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        public String getRepo(){
<b class="nc">&nbsp;            return Core.settings.getString(&quot;mod-&quot; + name + &quot;-repo&quot;, meta.repo);</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setRepo(String repo){
<b class="nc">&nbsp;            Core.settings.put(&quot;mod-&quot; + name + &quot;-repo&quot;, repo);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean enabled(){
<b class="fc">&nbsp;            return state == ModState.enabled || state == ModState.contentErrors;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean shouldBeEnabled(){
<b class="fc">&nbsp;            return Core.settings.getBool(&quot;mod-&quot; + name + &quot;-enabled&quot;, true);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean hasUnmetDependencies(){
<b class="nc">&nbsp;            return !missingDependencies.isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean hasContentErrors(){
<b class="fc">&nbsp;            return !erroredContent.isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return whether this mod is supported by the game version */
&nbsp;        public boolean isSupported(){
&nbsp;            //no unsupported mods on servers
<b class="fc">&nbsp;            if(headless) return true;</b>
&nbsp;
<b class="nc">&nbsp;            if(isOutdated() || isBlacklisted()) return false;</b>
&nbsp;
<b class="nc">&nbsp;            return Version.isAtLeast(meta.minGameVersion);</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Some mods are known to cause issues with the game; this detects and returns whether a mod is manually blacklisted. */
&nbsp;        public boolean isBlacklisted(){
<b class="nc">&nbsp;            return blacklistedMods.contains(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @return whether this mod is outdated, e.g. not compatible with v7. */
&nbsp;        public boolean isOutdated(){
&nbsp;            //must be at least 136 to indicate v7 compat
<b class="nc">&nbsp;            return getMinMajor() &lt; 136;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getMinMajor(){
<b class="nc">&nbsp;            return meta.getMinMajor();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void dispose(){
<b class="nc">&nbsp;            if(iconTexture != null){</b>
<b class="nc">&nbsp;                iconTexture.dispose();</b>
<b class="nc">&nbsp;                iconTexture = null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getSteamID(){
<b class="nc">&nbsp;            return Core.settings.getString(name + &quot;-steamid&quot;, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void addSteamID(String id){
<b class="nc">&nbsp;            Core.settings.put(name + &quot;-steamid&quot;, id);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void removeSteamID(){
<b class="nc">&nbsp;            Core.settings.remove(name + &quot;-steamid&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String steamTitle(){
<b class="nc">&nbsp;            return meta.name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String steamDescription(){
<b class="nc">&nbsp;            return meta.description;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String steamTag(){
<b class="nc">&nbsp;            return &quot;mod&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Fi createSteamFolder(String id){
<b class="nc">&nbsp;            return file;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Fi createSteamPreview(String id){
<b class="nc">&nbsp;            return file.child(&quot;preview.png&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean prePublish(){
<b class="nc">&nbsp;            if(!file.isDirectory()){</b>
<b class="nc">&nbsp;                ui.showErrorMessage(&quot;@mod.folder.missing&quot;);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!file.child(&quot;preview.png&quot;).exists()){</b>
<b class="nc">&nbsp;                ui.showErrorMessage(&quot;@mod.preview.missing&quot;);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString(){
<b class="nc">&nbsp;            return &quot;LoadedMod{&quot; +</b>
&nbsp;            &quot;file=&quot; + file +
&nbsp;            &quot;, root=&quot; + root +
&nbsp;            &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;            &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Mod metadata information.*/
<b class="fc">&nbsp;    public static class ModMeta{</b>
&nbsp;        /** Name as defined in mod.json. Stripped of colors, but may contain spaces. */
&nbsp;        public String name;
&nbsp;        /** Name without spaces in all lower case. */
&nbsp;        public String internalName;
&nbsp;        /** Minimum game version that this mod requires, e.g. &quot;140.1&quot; */
<b class="fc">&nbsp;        public String minGameVersion = &quot;0&quot;;</b>
&nbsp;        public @Nullable String displayName, author, description, subtitle, version, main, repo;
<b class="fc">&nbsp;        public Seq&lt;String&gt; dependencies = Seq.with();</b>
<b class="fc">&nbsp;        public Seq&lt;String&gt; softDependencies = Seq.with();</b>
&nbsp;        /** Hidden mods are only server-side or client-side, and do not support adding new content. */
&nbsp;        public boolean hidden;
&nbsp;        /** If true, this mod should be loaded as a Java class mod. This is technically optional, but highly recommended. */
&nbsp;        public boolean java;
&nbsp;        /** To rescale textures with a different size. Represents the size in pixels of the sprite of a 1x1 block. */
<b class="fc">&nbsp;        public float texturescale = 1.0f;</b>
&nbsp;        /** If true, bleeding is skipped and no content icons are generated. */
&nbsp;        public boolean pregenerated;
&nbsp;        /** If set, load the mod content in this order by content names */
&nbsp;        public String[] contentOrder;
&nbsp;
&nbsp;        public String displayName(){
&nbsp;            //useless, kept for legacy reasons
<b class="nc">&nbsp;            return displayName;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String shortDescription(){
<b class="nc">&nbsp;            return Strings.truncate(subtitle == null ? (description == null || description.length() &gt; maxModSubtitleLength ? &quot;&quot; : description) : subtitle, maxModSubtitleLength, &quot;...&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //removes all colors
&nbsp;        public void cleanup(){
<b class="fc">&nbsp;            if(name != null) name = Strings.stripColors(name);</b>
<b class="fc">&nbsp;            if(displayName != null) displayName = Strings.stripColors(displayName);</b>
<b class="fc">&nbsp;            if(displayName == null) displayName = name;</b>
<b class="fc">&nbsp;            if(version == null) version = &quot;0&quot;;</b>
<b class="fc">&nbsp;            if(author != null) author = Strings.stripColors(author);</b>
<b class="fc">&nbsp;            if(description != null) description = Strings.stripColors(description);</b>
<b class="fc">&nbsp;            if(subtitle != null) subtitle = Strings.stripColors(subtitle).replace(&quot;\n&quot;, &quot;&quot;);</b>
<b class="fc">&nbsp;            if(name != null) internalName = name.toLowerCase(Locale.ROOT).replace(&quot; &quot;, &quot;-&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getMinMajor(){
<b class="fc">&nbsp;            String ver = minGameVersion == null ? &quot;0&quot; : minGameVersion;</b>
<b class="fc">&nbsp;            int dot = ver.indexOf(&quot;.&quot;);</b>
<b class="fc">&nbsp;            return dot != -1 ? Strings.parseInt(ver.substring(0, dot), 0) : Strings.parseInt(ver, 0);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString(){
<b class="nc">&nbsp;            return &quot;ModMeta{&quot; +</b>
&nbsp;            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;            &quot;, minGameVersion=&#39;&quot; + minGameVersion + &#39;\&#39;&#39; +
&nbsp;            &quot;, displayName=&#39;&quot; + displayName + &#39;\&#39;&#39; +
&nbsp;            &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
&nbsp;            &quot;, description=&#39;&quot; + description + &#39;\&#39;&#39; +
&nbsp;            &quot;, subtitle=&#39;&quot; + subtitle + &#39;\&#39;&#39; +
&nbsp;            &quot;, version=&#39;&quot; + version + &#39;\&#39;&#39; +
&nbsp;            &quot;, main=&#39;&quot; + main + &#39;\&#39;&#39; +
&nbsp;            &quot;, repo=&#39;&quot; + repo + &#39;\&#39;&#39; +
&nbsp;            &quot;, dependencies=&quot; + dependencies +
&nbsp;            &quot;, softDependencies=&quot; + softDependencies +
&nbsp;            &quot;, hidden=&quot; + hidden +
&nbsp;            &quot;, java=&quot; + java +
&nbsp;            &quot;, texturescale=&quot; + texturescale +
&nbsp;            &quot;, pregenerated=&quot; + pregenerated +
&nbsp;            &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ModLoadException extends RuntimeException{
&nbsp;        public ModLoadException(String message){
<b class="nc">&nbsp;            super(message);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public enum ModState{</b>
<b class="fc">&nbsp;        enabled,</b>
<b class="fc">&nbsp;        contentErrors,</b>
<b class="fc">&nbsp;        missingDependencies,</b>
<b class="fc">&nbsp;        incompleteDependencies,</b>
<b class="fc">&nbsp;        circularDependencies,</b>
<b class="fc">&nbsp;        unsupported,</b>
<b class="fc">&nbsp;        disabled,</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static class ModResolutionContext {</b>
<b class="fc">&nbsp;        public final ObjectMap&lt;String, Seq&lt;ModDependency&gt;&gt; dependencies = new ObjectMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public final ObjectSet&lt;String&gt; visited = new ObjectSet&lt;&gt;();</b>
<b class="fc">&nbsp;        public final OrderedSet&lt;String&gt; ordered = new OrderedSet&lt;&gt;();</b>
<b class="fc">&nbsp;        public final ObjectMap&lt;String, ModState&gt; invalid = new OrderedMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static final class ModDependency{
&nbsp;        public final String name;
&nbsp;        public final boolean required;
&nbsp;
<b class="nc">&nbsp;        public ModDependency(String name, boolean required){</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.required = required;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 14:03</div>
</div>
</body>
</html>
